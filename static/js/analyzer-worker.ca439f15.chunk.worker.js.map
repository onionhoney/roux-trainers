{"version":3,"sources":["../webpack/bootstrap","lib/min2phase/min2phase.js","../../../src/comlink.ts","lib/Defs.tsx","lib/Math.ts","lib/CubeLib.tsx","lib/Pruner.tsx","lib/Solver.tsx","lib/min2phase/min2phase-wrapper.ts","lib/CachedSolver.tsx","lib/Evaluator.tsx","lib/Analyzer.ts","worker/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createArray","length","arr","Array","bitCount","get8Parity","idx","get12Parity","binarySearch","mid","val","fact","perm3","ud2std","std2ud","Cnk","length1","length2","j","createArrays","move2str","urfMove","ckmv","ckmv2","CubieCube","this","cp","co","ep","eo","getFlip","getFlipSym","FlipR2S","k","EdgeConjugate","SymInv","temps","FlipS2R","setFlip","bitOdd","getTwist","getTwistSym","TwistR2S","CornConjugate","TwistS2R","setTwist","twst","getUDSlice","setUDSlice","getMPerm","setMPerm","getMid3","idxA","idxB","mask","setMid3","edge","getURtoUL","getDRtoDL","setEdgePerm","getEdgePerm","getCPermSym","EPermR2S","get8Perm","e2c","CPermS2R","getEPermSym","EPermS2R","URFConjugate","CornMult","urf2","urf1","EdgeMult","invCubieCube","corn","ori","copy","init","cperm","twist","eperm","flip","set8Perm","cctemp","v","a","b","prod","oriA","oriB","ed","CubeSym","moveCube","SymMult","SymMove","Sym8Mult","Sym8Move","Sym8MultInv","SymMoveUD","MtoEPerm","merge","UDSliceMove","TwistMove","FlipMove","UDSliceConj","UDSliceTwistPrun","UDSliceFlipPrun","TwistFlipPrun","Mid3Move","Mid32MPerm","CParity","CPermMove","EPermMove","MPermMove","MPermConj","MCPermPrun","MEPermPrun","urfidx","move","csym","mid3","e1","e2","tsym","fsym","slice","corn0","csym0","mid30","e10","e20","prun","maxlength2","sol","valid1","valid2","solution","phase1","maxl","lm","Math","min","cornx","ex","get4Parity","esym","max","phase2","sb","urf","init2","slicex","twistx","tsymx","flipx","fsymx","depth","midx","edgex","esymx","csymx","initialized","initialize","mc","temp","f2","u4","lr2","found","occ","count","CubieInit","SymState","SymStateF","inv","select","check","done","sym","symF","fsymxx","idxx","symx","CoordInit","solve","cc","Solve","randomCube","random","proxyMarker","createEndpoint","releaseProxy","throwMarker","isObject","proxyTransferHandler","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","transferHandlers","Map","_ref","serialized","Error","isError","message","stack","assign","arguments","undefined","self","addEventListener","callback","ev","data","id","type","path","argumentList","map","fromWireValue","returnValue","parent","reduce","prop","rawValue","apply","proxy","transfer","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","constructor","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","_target","requestResponseMessage","toString","set","_thisArg","rawArgumentList","last","processArguments","construct","processed","concat","transferCache","WeakMap","transfers","handler","serializedValue","msg","fill","floor","Number","MAX_SAFE_INTEGER","join","Face","U","D","F","B","L","R","Typ","C","E","T","corners_coord","edges_coord","centers_coord","cstimer_corners_coord","cstimer_edges_coord","u","cpc","coc","epc","eoc","tpc","f","e","u_face","f_face","color_map","rand_int","rand_incl","rand_choice","cartesianProduct","_len","allEntries","_key","results","entries","result","entry","subResults","getParity","perm","visited","follow","cnt","res","x","arrayEqual","arr1","arr2","JSON","parse","tp","stringify","Id","clone","_apply_partial","oc","pc","mod","o_new","p_new","src","dst","_apply_partial_perm","apply_one","static","_","Function","generate_apply_partial_func","generate_apply_partial_func_perm","isArray","MoveSeq","moves","cube","fs","faces","last_face","first_face","_to_facelet_mapping","facelet_mapping","pos","piece","_rotate_coord","push","_from_facelet_mapping","fm","custom_corners_coord","custom_edges_coord","custom_centers_coord","match_pos_piece","coord","parity","expected","has","_backward_rotate_coord","console","warn","coord_pair","newOri","newpos","newPerm","to_cstimer_cube","is_solveable","perm_correct","ori_correct","y","changeBasis","transformed_mapping","mapping","face_mapping","fromEntries","face_pos","face_target","_face_mapping$f","_face_mapping$f2","Move","arg","from_moves","from_cube","get_change","acc_p","acc_o","all","generate_base_moves","make_rot_set","us","rs","ls","ds","bs","ms","es","ss","rws","lws","uws","fws","xs","ys","zs","flat","moves_dict","forEach","toQuarter","nm","quarterMap","move1","move2","getCnt","getStr","remove_setup","rotset","Set","shift","parse_line","str","tokens","token","comment_idx","search","ch","ord","charCodeAt","split","collapse","newMoves","nextMove","pop","combined","_combine","reverse","auf_moves","auf_move","useMetric","FaceletCube","mult_move","face","face_new","work","typ","mod_for_typ","p1","p2","p_curr","o_curr","typ_curr","color_of_c","o1","o2","color_of_e","color_of_t","color_of_sticker","sticker","d_face","l_face","r_face","b_face","from_cubie","facelet","from_cubie_partial_masked","_ref2","X","from_cubie_partial","to_unfolded_cube_str","faceletCube","face_count","str_face_map","color_cube","face_char","as_actrm","fcube","uu_only","nmcll_faces","u_or_nmcll_faces","stickers","includes","fidx","as_kata","log","shape_maps","match_count","alert","lse_mask","ext","find_pairs","edge_stickers","filter","corner_stickers","ep_stickers","cp_stickers","epcp_pairs","efs","cfs","match","get_color","connected_pairs","u_premove","m2_premove","oris","get_random_with_mask","_ref4","cp_rand","ep_rand","par","random_ori","ori_mask","sum","random_perm","perm_mask","undecided","tmp","rand_shuffle","ColorScheme","save","window","localStorage","setItem","load","item","getItem","_setDefault","suppressLoad","super","colors","toUserInput","newScheme","color","setWithDefault","default_colors","getColorsForOri","valid_schemes_map","valid_schemes","PrunerPiece","globalThis","$RefreshReg$","$RefreshSig$","S","I","htm_rwm","rrwmu","rrwmu_m_first","rrwmu_f","rrwmu_b","htm_rwm_uw","htm_rwm_fws","xyz","fbdrPrunerConfigGen","max_depth","size","pow","encode","c1","c2","enc_c","e3","e4","solved_states","moveset","fbdrPrunerConfig","fbAtBLPrunerConfig","esize","csize","enc_e","t1","fbAtBLPrunerConfigGen","fbAtDLPrunerConfig","fbAtDLPrunerConfigGen","fbPrunerConfig","sbPrunerConfig","lpSbSbPrunerConfigGen","lp_front","lpSbDiagPrunerConfigGen","fbssPrunerConfigs","fbssPrunerConfigsManual","is_front","c3","lsePrunerConfig","edge_encode","enc","edge_enc","eodmPrunerConfig","edge_idx","centerPrunerConfig","Solver","config","MAX_STATE_COUNT","accum","min_depth","SState","is_solved","pruners","state_count","prune_count","solve_depth","min_depth_","max_depth_","accum_","nextMoves","STOP","CONTINUE","solutions","capacity","flag","try_push","query","availableMoves","seen_encodings","pruneSeenEncodings","add","BigInt","new_cube","_seen_encodings","st","expand","getAvailableMove","base","generateNextMoveTable","depth_l","depth_r","getPruners","solverFactory","prunerConfig","pruner","CachedPruner","solverFactory2","prunerConfigs","every","SsSolver","ssPrunerConfig","SsDpSolver","v0","v1","ssDpPrunerConfig","FbssSolver","LpsbSolver","FsSolver","v2","fsPrunerConfig","FsPseudoSolver","fsPseudoPrunerConfig","FELineP1Solver","fELineP1PrunerConfig","FsDrSolver","v3","fsDrPrunerConfig","EOLRSolver","center_flag","barbie_mode","moves_ac","moves_mc","barb_moves","eolrPrunerConfig","Min2PhaseSolver","min2phase_init","assert","transformed_cube","state","min2phaseSolve","toMin2Phase","cache","pcs","dist","moveset_str","level_states","Uint8Array","frontier","total_expanded","new_frontier","newState","rev_lookup_depth","equal","cube1","cube2","Pruner","CachedSolver","DPGrip","Evaluator","SeqEvaluator","evaluate","moveCost","moveCost_gen","QTMEvaluator","RawEvaluator","TwoGramEvaluator","moves_input","score","two_gram","curr_score","parseFloat","meter","isNaN","two_gram_meter","DPEvaluator","HI","R_AWAY","R2_AWAY","HOME","Rp_AWAY","DEAD_END","evaluate_with_plan","cost","len","DP","DP_path","regripCost","moveTransition","prev_grip","shifted_grip","cur_scheme","cur_grip","optimal_cost","optimal_ending_grip","grip","current_grip","optimal_plan","previous_grip","previous_shifted_grip","grip_str","desc","current_segment","g1","g2","alg","moveTransition_gen","regripCost_gen","MovementEvaluator","movement","stationary","solver_str","solver","premoves","num_solution","upper_limit","getEvaluator","evaluator","solver_num_solution","pm","premove","sort","get_oris","preori","analyze","scramble","post_scramble","stage","orientation","pre_orientation","fb_stage","fb_stage_solvers","fb_tag","solvers","analyze_fb","_state$full_solution$","full_solution","analyze_ss","analyze_sp","analyze_lse"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,qBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,kBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,kBAIjBlC,EAAoBA,EAAoBmC,EAAI,G,gBCjFrD,SAASC,EAAYC,GACpB,MAAMC,EAAMC,MAAMF,GAClB,IAAK,IAAIjC,EAAE,EAAGA,EAAEiC,EAAQjC,IACvBkC,EAAIlC,GAAK,EAEV,OAAOkC,EAsBR,SAASE,EAASpC,GAGjB,OADAA,GAAS,WADTA,GAAUA,IAAM,EAAK,cACIA,IAAM,EAAK,aACvBA,IAAM,IAAMA,IAAM,GAAM,GAatC,SAASqC,EAAWC,GAEnB,IADA,IAAIR,EAAI,EACC9B,EAAE,EAAGA,GAAG,EAAGA,IACnB8B,GAAKQ,GAAO,EAAEtC,GACdsC,KAASA,GAAO,EAAEtC,IAGnB,OADA8B,GAAK,EAIN,SAASS,EAAYD,GAEpB,IADA,IAAIR,EAAI,EACC9B,EAAE,GAAIA,GAAG,EAAGA,IACpB8B,GAAKQ,GAAO,GAAGtC,GACfsC,KAASA,GAAO,GAAGtC,IAGpB,OADA8B,GAAK,EAKN,SAASU,EAAaN,EAAKX,GAC1B,IAAIU,EAASC,EAAID,OACjB,GAAIV,GAAOW,EAAID,EAAO,GAGrB,IAFA,IAAIhC,EAAI,EACJa,EAAImB,EAAO,EACRhC,GAAKa,GAAG,CACd,IAAI2B,EAAOxC,EAAEa,IAAK,EACd4B,EAAMR,EAAIO,GACd,GAAIlB,EAAMmB,EACTzC,EAAIwC,EAAM,MACJ,MAAIlB,EAAMmB,GAGhB,OAAQD,EAFR3B,EAAI2B,EAAM,GAMb,OAAO,MAeR,IAZA,IAAIE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,IAAK,KAAM,MAAO,OAAQ,QAAS,SAAU,WAC1EC,EAAQ,CAAC,CAAC,GAAI,GAAI,GAAI,CAAC,GAAI,GAAI,GAAI,CAAC,GAAI,EAAG,IAAK,CAAC,EAAG,GAAI,IAAK,CAAC,GAAI,EAAG,IAAK,CAAC,EAAG,GAAI,KAClFC,EAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,IACxCC,EAASd,EAAY,IACrBe,EAhFJ,SAAsBC,EAASC,GAC9B,MAAMf,EAAMC,MAAMa,GAClB,IAAK,IAAIhD,EAAE,EAAGA,EAAEgD,EAAShD,IAAK,CAC7BkC,EAAIlC,GAAKmC,MAAMc,GACf,IAAK,IAAIC,EAAE,EAAGA,EAAED,EAASC,IACxBhB,EAAIlC,GAAGkD,GAAK,EAGd,OAAOhB,EAwEEiB,CAAa,GAAI,IACvBC,EAAW,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAClHC,EAAU,CAAC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IACvD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,GAAG,GAAG,GAAI,EAAE,GAAG,GAAG,GAAG,GAAG,IACnD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAI,EAAE,GAAG,IACnD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,GAAG,GAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,IACnD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAI,EAAE,GAAG,GAAG,IACnD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAI,IACtDrD,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxB+C,EAAI/C,GAAG,GAAK,EACZ+C,EAAI/C,GAAGA,GAAK,EACZ+C,EAAI/C,GAAGA,EAAE,GAAK,EACd,IAAK,IAAIkD,EAAE,EAAGA,EAAElD,EAAGkD,IAClBH,EAAI/C,GAAGkD,GAAMH,EAAI/C,EAAE,GAAGkD,EAAE,GAAKH,EAAI/C,EAAE,GAAGkD,GAGxC,IAASlD,EAAE,EAAGA,EAAE,GAAIA,IACnB8C,EAAOD,EAAO7C,IAAMA,EAGrB,IAAIsD,EAAOnB,MAAM,IACboB,EAAQpB,MAAM,IAClBmB,EAAK,IAAMnB,MAAM,IACjBoB,EAAM,IAAMpB,MAAM,IAClB,IAASnC,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxBsD,EAAKtD,GAAKmC,MAAM,IAChB,IAASe,EAAE,EAAGA,EAAE,GAAIA,IACnBI,EAAKtD,GAAGkD,MAASlD,EAAE,OAASkD,EAAE,OAAYlD,EAAE,GAAG,MAAQkD,EAAE,GAAG,GAAOlD,GAAGkD,EAEvEI,EAAK,IAAItD,IAAK,EAEf,IAASA,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxBuD,EAAMvD,GAAKmC,MAAM,IACjB,IAASe,EAAE,EAAGA,EAAE,GAAIA,IACnBK,EAAMvD,GAAGkD,GAAKI,EAAKT,EAAO7C,IAAI6C,EAAOK,IAEtCK,EAAM,IAAIvD,IAAK,EAMhB,SAASwD,IACRC,KAAKC,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChCD,KAAKE,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChCF,KAAKG,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC7CH,KAAKI,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5CJ,KAAKK,QAAU,WAEd,IADA,IAAIxB,EAAM,EACDtC,EAAE,EAAGA,EAAE,GAAIA,IACnBsC,GAAOmB,KAAKI,GAAG7D,IAAMA,EAEtB,OAAOsC,GAGRmB,KAAKM,WAAa,WACjB,GAAe,GAAXC,EACH,OAAOA,EAAQP,KAAKK,WAErB,IAAK,IAAIG,EAAE,EAAGA,EAAE,GAAIA,GAAG,EAAG,CACzBC,EAAcT,KAAMU,EAAOF,GAAIG,GAC/B,IAAI9B,EAAME,EAAa6B,EAASD,EAAMN,WACtC,GAAW,OAAPxB,EACH,OAASA,GAAO,EAAM2B,IAAM,EAG9B,OAAO,GAGRR,KAAKa,QAAU,SAAiBhC,GAC/BmB,KAAKI,GAAG,IA3IV,SAAgB7D,GAKf,OAJAA,GAAKA,IAAM,EACXA,GAAKA,IAAM,EACXA,GAAKA,IAAM,EAEA,GADXA,EAAKA,IAAM,GAuIIuE,CAAOjC,GACrB,IAAK,IAAItC,EAAE,EAAGA,EAAE,GAAIA,IACnByD,KAAKI,GAAG7D,GAAW,EAANsC,EACbA,KAAS,GAIXmB,KAAKe,SAAW,WAEf,IADA,IAAIlC,EAAM,EACDtC,EAAE,EAAGA,EAAE,EAAGA,IAClBsC,GAAO,EACPA,GAAOmB,KAAKE,GAAG3D,GAEhB,OAAOsC,GAGRmB,KAAKgB,YAAc,WAClB,GAAgB,MAAZC,EACH,OAAOA,EAASjB,KAAKe,YAEtB,IAAK,IAAIP,EAAE,EAAGA,EAAE,GAAIA,GAAG,EAAG,CACzBU,EAAclB,KAAMU,EAAOF,GAAIG,GAC/B,IAAI9B,EAAME,EAAaoC,EAAUR,EAAMI,YACvC,GAAW,OAAPlC,EACH,OAASA,GAAO,EAAM2B,IAAM,EAG9B,OAAO,GAIRR,KAAKoB,SAAW,SAAkBvC,GAEjC,IADA,IAAIwC,EAAO,EACF9E,EAAE,EAAGA,GAAG,EAAGA,IACnB8E,GAAQrB,KAAKE,GAAG3D,GAAKsC,EAAM,EAC3BA,KAASA,EAAI,GAEdmB,KAAKE,GAAG,IAAM,GAAKmB,GAAQ,GAG5BrB,KAAKsB,WAAa,WAGjB,IAFA,IAAIzC,EAAM,EACNxB,EAAI,EACCd,EAAE,EAAGA,EAAE,GAAIA,IACfyD,KAAKG,GAAG5D,IAAM,IACjBsC,GAAOS,EAAI,GAAG/C,GAAGc,GACjBA,KAGF,OAAOwB,GAGRmB,KAAKuB,WAAa,SAAoB1C,GAErC,IADA,IAAIxB,EAAI,EACCd,EAAE,EAAGA,EAAE,GAAIA,IACfsC,GAAOS,EAAI,GAAG/C,GAAGc,IACpBwB,GAAOS,EAAI,GAAG/C,GAAGc,GACjBA,IACA2C,KAAKG,GAAG5D,GAAM,GAAGc,GAEjB2C,KAAKG,GAAG5D,GAAMA,EAAEc,EAAE,GAIrB2C,KAAKwB,SAAW,WAGf,IAFA,IAAI7E,EAAK,GAAKqD,KAAKG,GAAG,IAClBtB,EAAM,EACDtC,EAAE,GAAIA,GAAG,IAAKA,EAAG,CACzB,IAAIkB,EAAI,GAAKuC,KAAKG,GAAG5D,GACrBsC,GAAOF,EAAShC,EAAKc,EAAI,GAAMyB,EAAK,GAAG3C,GACvCI,GAAKc,EAEN,OAAOoB,GAERmB,KAAKyB,SAAW,SAAkB5C,GACjCmB,KAAKG,GAAG,IAAM,EACd,IAAK,IAAI5D,EAAE,GAAIA,GAAG,EAAGA,IAAK,CACzByD,KAAKG,GAAG5D,GAAMsC,GAAO,GAAGtC,GAAK,EAC7BsC,KAASA,GAAO,GAAGtC,IACnB,IAAK,IAAIkD,EAAElD,EAAE,EAAGkD,EAAE,GAAIA,IACjBO,KAAKG,GAAGV,IAAMO,KAAKG,GAAG5D,IACzByD,KAAKG,GAAGV,OAKZO,KAAK0B,QAAU,WAKd,IAJA,IAAIC,EAAO,EACPC,EAAO,EACPC,EAAO,EACPxE,EAAI,EACCd,EAAE,GAAIA,GAAG,EAAGA,IACpB,GAAIyD,KAAKG,GAAG5D,IAAM,EAAG,CACpBoF,GAAQrC,EAAI/C,GAAGc,KACf,IAAII,EAAI,GAAKuC,KAAKG,GAAG5D,GACrBqF,GAAQjD,EAASkD,EAAQpE,EAAI,GAAMyB,EAAK,EAAE7B,GAC1CwE,GAAQpE,EAGV,OAAe,EAAPkE,EAAWC,GAGpB5B,KAAK8B,QAAU,SAAiBH,GAC/B,IAAII,EAAO5C,EAAMwC,EAAO,GACxBA,KAAUA,EAAO,GAEjB,IADA,IAAItE,EAAI,EACCd,EAAE,GAAIA,GAAG,EAAGA,IAChBoF,GAAQrC,EAAI/C,GAAGc,IAClBsE,GAAQrC,EAAI/C,GAAGc,KACf2C,KAAKG,GAAG5D,GAAKwF,EAAK,EAAE1E,IAEpB2C,KAAKG,GAAG5D,GAAM,EAAEA,EAAEc,GAKrB2C,KAAKgC,UAAY,WAKhB,IAJA,IAAIL,EAAO,EACPC,EAAO,EACPC,EAAO,EACPxE,EAAI,EACCd,EAAE,GAAIA,GAAG,EAAGA,IACpB,GAAIyD,KAAKG,GAAG5D,IAAM,EAAG,CACpBoF,GAAQrC,EAAI/C,GAAGc,KACf,IAAII,EAAI,GAAKuC,KAAKG,GAAG5D,GACrBqF,GAAQjD,EAASkD,EAAQpE,EAAI,GAAMyB,EAAK,EAAE7B,GAC1CwE,GAAQpE,EAGV,OAAe,EAAPkE,EAAWC,GAGpB5B,KAAKiC,UAAY,WAKhB,IAJA,IAAIN,EAAO,EACPC,EAAO,EACPC,EAAO,EACPxE,EAAI,EACCd,EAAE,GAAIA,GAAG,EAAGA,IACpB,GAAI,GAAKyD,KAAKG,GAAG5D,IAAMyD,KAAKG,GAAG5D,IAAM,EAAG,CACvCoF,GAAQrC,EAAI/C,GAAGc,KACf,IAAII,EAAI,GAAKuC,KAAKG,GAAG5D,GACrBqF,GAAQjD,EAASkD,EAAQpE,EAAI,GAAMyB,EAAK,EAAE7B,GAC1CwE,GAAQpE,EAGV,OAAe,EAAPkE,EAAWC,GAGpB5B,KAAKkC,YAAc,SAAqBrD,GACvCmB,KAAKG,GAAG,IAAM,EACd,IAAK,IAAI5D,EAAE,GAAIA,GAAG,EAAGA,IAAK,CACzByD,KAAKG,GAAG5D,GAAMsC,GAAO,GAAGtC,GACxBsC,KAASA,GAAK,GAAGtC,IACjB,IAAK,IAAIkD,EAAElD,EAAE,EAAGkD,EAAE,GAAIA,IACjBO,KAAKG,GAAGV,IAAMO,KAAKG,GAAG5D,IACzByD,KAAKG,GAAGV,OAKZO,KAAKmC,YAAc,WAGlB,IAFA,IAAIxF,EAAK,GAAKqD,KAAKG,GAAG,IAClBtB,EAAM,EACDtC,EAAE,GAAIA,GAAG,IAAKA,EAAG,CACzB,IAAIkB,EAAI,GAAKuC,KAAKG,GAAG5D,GACrBsC,GAAOF,EAAShC,EAAKc,EAAI,GAAMyB,EAAK,GAAG3C,GACvCI,GAAKc,EAEN,OAAOoB,GAGRmB,KAAKoC,YAAc,WAClB,GAAgB,MAAZC,EAAkB,CACrB,IAAIxD,EAAMwD,EAASC,EAAStC,KAAKC,KAEjC,OADApB,GAAO0D,EAAQ,GAAJ1D,GAGZ,IAAK,IAAI2B,EAAE,EAAGA,EAAE,GAAIA,IAAK,CAGxB,GAFAU,EAAclB,KAAMU,EAAOF,GAAIG,GAEpB,QADP9B,EAAME,EAAayD,EAAUF,EAAS3B,EAAMV,MAE/C,OAASpB,GAAO,EAAK2B,EAGvB,OAAO,GAGRR,KAAKyC,YAAc,WAClB,GAAgB,MAAZJ,EACH,OAAOA,EAASC,EAAStC,KAAKG,KAE/B,IAAK,IAAIK,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxBC,EAAcT,KAAMU,EAAOF,GAAIG,GAC/B,IAAI9B,EAAME,EAAa2D,EAAUJ,EAAS3B,EAAMR,KAChD,GAAW,OAAPtB,EACH,OAASA,GAAO,EAAK2B,EAGvB,OAAO,GAGRR,KAAK2C,aAAe,WACnBC,EAASC,EAAM7C,KAAMW,GACrBiC,EAASjC,EAAOmC,EAAM9C,MACtB+C,EAASF,EAAM7C,KAAMW,GACrBoC,EAASpC,EAAOmC,EAAM9C,OAGvBA,KAAKgD,aAAe,WACnB,IAAK,IAAIjB,EAAK,EAAGA,EAAK,GAAIA,IACzBpB,EAAMR,GAAGH,KAAKG,GAAG4B,IAASA,EAC3B,IAASA,EAAK,EAAGA,EAAK,GAAIA,IACzBpB,EAAMP,GAAG2B,GAAQ/B,KAAKI,GAAGO,EAAMR,GAAG4B,IACnC,IAAK,IAAIkB,EAAK,EAAGA,EAAK,EAAGA,IACxBtC,EAAMV,GAAGD,KAAKC,GAAGgD,IAASA,EAC3B,IAASA,EAAK,EAAGA,EAAK,EAAGA,IAAQ,CAChC,IAAIC,EAAMlD,KAAKE,GAAGS,EAAMV,GAAGgD,IAC3BtC,EAAMT,GAAG+C,IAASC,EACdvC,EAAMT,GAAG+C,GAAQ,IACpBtC,EAAMT,GAAG+C,IAAS,GAEpBjD,KAAKmD,KAAKxC,IAIXX,KAAKoD,KAAO,SAAcC,EAAOC,EAAOC,EAAOC,GAC9CC,EAASzD,KAAKC,GAAIoD,GAClBrD,KAAKoB,SAASkC,GACdtD,KAAKkC,YAAYqB,GACjBvD,KAAKa,QAAQ2C,IAGdxD,KAAKmD,KAAO,SAAcvG,GACzB,IAAK,IAAIL,EAAE,EAAGA,EAAE,EAAGA,IAClByD,KAAKC,GAAG1D,GAAKK,EAAEqD,GAAG1D,GAClByD,KAAKE,GAAG3D,GAAKK,EAAEsD,GAAG3D,GAEnB,IAASA,EAAI,EAAGA,EAAI,GAAIA,IACvByD,KAAKG,GAAG5D,GAAKK,EAAEuD,GAAG5D,GAClByD,KAAKI,GAAG7D,GAAKK,EAAEwD,GAAG7D,IAKrB,MAAMmH,EAAS,IAAI3D,EACbY,EAAQ,IAAIZ,EAElB,SAAS0D,EAAShF,EAAKI,GAEtB,IADA,IAAII,EAAM,WACD1C,EAAE,EAAGA,EAAE,EAAGA,IAAK,CACvB,IAAI8B,EAAIa,EAAK,EAAE3C,GACXoH,KAAO9E,EAAMR,GACjBQ,GAAOR,EACPsF,IAAM,EACNlF,EAAIlC,GAAO0C,GAAO0E,EAAK,EACvB,IAAIhH,GAAK,GAAKgH,GAAK,EACnB1E,GAAOA,EAAMtC,IAAOsC,GAAO,GAAMtC,GAElC8B,EAAI,GAAKQ,EAGV,SAASqD,EAAS7D,GAGjB,IAFA,IAAII,EAAM,EACNI,EAAM,WACD1C,EAAE,EAAGA,EAAE,EAAGA,IAAK,CACvB,IAAIoH,EAAIlF,EAAIlC,IAAM,EAClBsC,GAAO,EAAItC,GAAKsC,GAAQI,GAAO0E,EAAK,GACpC1E,GAAO,WAAc0E,EAEtB,OAAO9E,EAGR,SAAS+D,EAASgB,EAAGC,EAAGC,GACvB,IAAK,IAAIb,EAAK,EAAGA,EAAK,EAAGA,IAAQ,CAChCa,EAAK7D,GAAGgD,GAAQW,EAAE3D,GAAG4D,EAAE5D,GAAGgD,IAC1B,IAAIc,EAAOH,EAAE1D,GAAG2D,EAAE5D,GAAGgD,IACjBe,EAAOH,EAAE3D,GAAG+C,GACZC,EAAMa,EACVb,GAAQa,EAAK,EAAKC,EAAO,EAAEA,EAC3Bd,GAAO,EACHa,EAAO,EAAIC,EAAO,IACrBd,GAAO,GAERY,EAAK5D,GAAG+C,GAAQC,GAIlB,SAASH,EAASa,EAAGC,EAAGC,GACvB,IAAK,IAAIG,EAAG,EAAGA,EAAG,GAAIA,IACrBH,EAAK3D,GAAG8D,GAAML,EAAEzD,GAAG0D,EAAE1D,GAAG8D,IACxBH,EAAK1D,GAAG6D,GAAOJ,EAAEzD,GAAG6D,GAAML,EAAExD,GAAGyD,EAAE1D,GAAG8D,IAItC,SAAS/C,EAAc0C,EAAG/E,EAAKgF,GAC9BjB,EAASsB,EAAQxD,EAAO7B,IAAO+E,EAAGF,GAClCd,EAASc,EAAQQ,EAAQrF,GAAMgF,GAGhC,SAASpD,EAAcmD,EAAG/E,EAAKgF,GAC9Bd,EAASmB,EAAQxD,EAAO7B,IAAO+E,EAAGF,GAClCX,EAASW,EAAQQ,EAAQrF,GAAMgF,GAGhC,IAAIK,EAAUxF,MAAM,IAChByF,EAAWzF,MAAM,IACjBgC,EAAShC,MAAM,IACf0F,EAAU1F,MAAM,IAChB2F,EAAU3F,MAAM,IAChB4F,EAAW5F,MAAM,GACjB6F,EAAW7F,MAAM,GACjB8F,EAAc9F,MAAM,GACpB+F,EAAY/F,MAAM,IAClBkC,EAAUlC,MAAM,KAChByC,EAAWzC,MAAM,KACjB8D,EAAW9D,MAAM,MACjBgE,EAAWF,EACXjC,EAAU7B,MAAM,MAChBuC,EAAWvC,MAAM,MACjB2D,EAAW9D,EAAY,OAC3B,IAAShC,EAAE,EAAGA,EAAE,MAAOA,IACtB8F,EAAS9F,GAAK,EAEf,IAAImI,EAAWhG,MAAM,OACjBiG,EAAQjG,MAAM,IACd6D,EAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACxD,MAAMO,EAAO,IAAI/C,EACjB+C,EAAKM,KAAK,KAAM,KAAM,SAAU,MAChC,MAAMP,EAAO,IAAI9C,EACjB8C,EAAKO,KAAK,KAAM,KAAM,UAAW,KA+LjC,IAAIwB,EAAclG,MAAM,KACpBmG,EAAYnG,MAAM,KAClBoG,EAAWpG,MAAM,KACjBqG,EAAcrG,MAAM,KACpBsG,EAAmBtG,MAAM,QACzBuG,EAAkBvG,MAAM,QAExBwG,GAAgBxG,MAAM,QAGtByG,GAAWzG,MAAM,MACjB0G,GAAa1G,MAAM,IACnB2G,GAAU3G,MAAM,IAGhB4G,GAAY5G,MAAM,MAClB6G,GAAY7G,MAAM,MAClB8G,GAAY9G,MAAM,IAClB+G,GAAY/G,MAAM,IAClBgH,GAAahH,MAAM,OACnBiH,GAAajH,MAAM,OAoYvB,IAOIkH,GAPAC,GAAOnH,MAAM,IAEbuE,GAAOvE,MAAM,IACboH,GAAOpH,MAAM,IACbqH,GAAOrH,MAAM,IACbsH,GAAKtH,MAAM,IACXuH,GAAKvH,MAAM,IAGX4E,GAAQ5E,MAAM,GACdwH,GAAOxH,MAAM,GACb8E,GAAO9E,MAAM,GACbyH,GAAOzH,MAAM,GACb0H,GAAQ1H,MAAM,GACd2H,GAAQ3H,MAAM,GACd4H,GAAQ5H,MAAM,GACd6H,GAAQ7H,MAAM,GACd8H,GAAM9H,MAAM,GACZ+H,GAAM/H,MAAM,GACZgI,GAAOhI,MAAM,GAEba,GAAU,EACVoH,GAAa,EACbC,GAAM,IACNC,GAAS,EACTC,GAAS,EACTC,GAAW,GAmDf,SAASC,GAAO1D,EAAO4C,EAAM1C,EAAM2C,EAAMC,EAAOa,EAAMC,GACrD,GAAW,GAAP5D,GAAkB,GAANE,GAAkB,GAAP4C,GAAYa,EAAO,EAC7C,OAAe,GAARA,GA8BT,WAICH,GAASK,KAAKC,IAAIN,GAAQD,IAC1B,IAAK,IAAItK,EAAEsK,GAAQtK,EAAEgD,GAAShD,IAAK,CAClC,IAAII,EAAIkJ,GAAKtJ,GACb0G,GAAK1G,EAAE,GAAK+I,GAAUrC,GAAK1G,IAAI8H,EAAQyB,GAAKvJ,IAAII,IAChDmJ,GAAKvJ,EAAE,GAAK6H,EAAoB,GAAZnB,GAAK1G,EAAE,IAASuJ,GAAKvJ,IACzC0G,GAAK1G,EAAE,MAAQ,EACfwJ,GAAKxJ,EAAE,GAAK4I,GAASY,GAAKxJ,IAAII,GAE/BkK,GAAStH,GACT,IAAIP,EAAMoG,GAAWW,GAAKxG,IAAW,IACjCmH,EAAOhB,GAA2B,GAAhBzC,GAAK1D,IAAgBkG,GAAUzG,GAAK8G,GAAKvG,MAC/D,GAAImH,GAAQC,GACX,OAAO,EAER,IAASpK,EAAEuK,GAAQvK,EAAEgD,GAAShD,IAC7ByJ,GAAGzJ,EAAE,GAAK4I,GAASa,GAAGzJ,IAAIsJ,GAAKtJ,IAC/B0J,GAAG1J,EAAE,GAAK4I,GAASc,GAAG1J,IAAIsJ,GAAKtJ,IAEhCuK,GAASvH,GACT,IAAI8H,EAAQpE,GAAK1D,IACb+H,EAAmD,KAA9C3C,KAASqB,GAAGzG,IAAS,OAAO0G,GAAG1G,IAAS,IAC7B,GAAdyG,GAAGzG,IAAgB0G,GAAG1G,IAAW,EAAI,GAAO8F,GAAQgC,IAAQ,MAAY,EAANA,GAAU,EAnqCnF,SAAoBxI,GAEnB,IADA,IAAIR,EAAI,EACC9B,EAAE,EAAGA,GAAG,EAAGA,IACnB8B,GAAKQ,GAAO,EAAEtC,GACdsC,KAASA,GAAO,EAAEtC,IAGnB,OADK,EAAL8B,EA6pCuFkJ,CAAWvI,IAC9F+C,EAAO2C,EAAS4C,GAChBE,EAAc,GAAPzF,EAGX,GAFAA,KAAU,GACT2E,EAAOS,KAAKM,IAAI9B,GAAkB,GAAP5D,EAAY0D,GAAUzG,GAAKwI,IAAQd,KACnDC,GACX,OAAO,EAEP,IAAIO,EAAc,GAAT3H,GAAa,GAAKF,EAA6B,KAAnBwG,GAAKtG,GAAQ,GAAG,GAAK,GAC3D,IAAShD,EAAEmK,EAAMnK,EAAEoK,GAAYpK,IAC9B,GAAImL,GAAO3F,EAAMyF,EAAMvE,GAAK1D,IAAUuG,GAAKvG,IAAUP,EAAKzC,EAAGgD,GAAS2H,GAAK,CAC1EN,GAAMrH,GAAUhD,EAChB,IAAIoL,EAAK,GACLC,EAAMhC,GAIV,IAFCgC,GAAOA,EAAM,GAAK,GAET,EAAG,CACZ,IAAK,IAAItJ,EAAE,EAAGA,EAAEiB,GAASjB,IACxBqJ,GAAMhI,EAASC,EAAQgI,GAAK/B,GAAKvH,KAAO,IAEzC,IAASA,EAAEiB,GAASjB,EAAEsI,GAAKtI,IAC1BqJ,GAAMhI,EAASC,EAAQgI,GAAK/B,GAAKvH,KAAO,QAEnC,CACN,IAASA,EAAEsI,GAAI,EAAGtI,GAAGiB,GAASjB,IAC7BqJ,GAAMhI,EAASC,EAAQgI,GAAK/B,GAAKvH,KAAO,IAEzC,IAASA,EAAEiB,GAAQ,EAAGjB,GAAG,EAAGA,IAC3BqJ,GAAMhI,EAASC,EAAQgI,GAAK/B,GAAKvH,KAAO,IAK1C,OADAyI,GAAWY,GACJ,EAGT,OAAO,EA5FcE,GAErB,IAAK,IAAIlL,EAAE,EAAGA,EAAE,GAAIA,IACnB,GAAIkD,EAAKqH,GAAIvK,GACZA,GAAG,MADJ,CAIA,IAAImL,EAASlD,EAAYwB,GAAOzJ,GAC5BoL,EAASlD,EAAUvB,GAAOiB,EAAS2B,GAAMvJ,IACzCqL,EAAQ1D,EAAkB,EAATyD,GAAY7B,GAEjC,KAAIlB,EAA0B,KAD9B+C,KAAY,GACwBhD,EAAY+C,GAAQE,KAAWf,GAAnE,CAGA,IAAIgB,EAAQnD,EAAStB,GAAMe,EAAS4B,GAAMxJ,IACtCuL,EAAQ5D,EAAiB,EAAR2D,GAAW9B,GAEhC,KAAIjB,GAAuB,KAAT6C,IADlBE,KAAW,IACiC,EAAIzD,EAAY0D,GAAOF,MAAYf,GAC3EhC,EAAwB,IAARgD,EAAclD,EAAY+C,GAAQI,KAAWjB,KAGjEpB,GAAKtG,GAAQ0H,GAAQtK,EACrBkK,GAASM,KAAKC,IAAIP,GAAQtH,GAAQ0H,GAC9BD,GAAOe,EAAQC,EAAOC,EAAOC,EAAOJ,EAAQb,EAAK,EAAGtK,IACvD,OAAO,GAGT,OAAO,EAoER,SAAS+K,GAAO3F,EAAMyF,EAAMvE,EAAM6C,EAAM9G,EAAKiI,EAAMkB,EAAOjB,GACzD,GAAU,GAANnF,GAAiB,GAANkB,GAAgB,GAALjE,EACzB,OAAO,EAER,IAAK,IAAIrC,EAAE,EAAGA,EAAE,GAAIA,IACnB,IAAImD,EAAMoH,GAAIvK,GAAd,CAGA,IAAIyL,EAAO5C,GAAUxG,GAAKrC,GACtB0L,EAAQ9C,GAAUxD,GAAM0C,EAAU+C,GAAM7K,IACxC2L,EAAQlE,EAAgB,GAARiE,GAAYb,GAEhC,KAAI7B,GAAmB,IADvB0C,KAAW,GACiB5C,GAAU2C,GAAME,KAAWrB,GAAvD,CAGA,IAAII,EAAQ/B,GAAUrC,GAAMoB,EAAQyB,GAAM1G,EAAOzC,KAC7C4L,EAAQnE,EAAgB,GAARiD,GAAYvB,GAEhC,KAAIJ,GAAmB,IADvB2B,KAAW,GACiB5B,GAAU2C,GAAMG,KAAWtB,KAGvDpB,GAAKsC,GAAS/I,EAAOzC,GACjB+K,GAAOW,EAAOC,EAAOjB,EAAOkB,EAAOH,EAAMnB,EAAK,EAAGkB,EAAM,EAAGxL,IAC7D,OAAO,GAGT,OAAO,EAGR,IAAI6L,IAAc,EAElB,SAASC,KACJD,MAlyBL,WACC,IAAIE,EAAKhK,MAAM,GACfgK,EAAG,GAAK,IAAI3I,EACZ2I,EAAG,GAAGtF,KAAK,MAAO,EAAG,UAAW,GAChCsF,EAAG,GAAK,IAAI3I,EACZ2I,EAAG,GAAGtF,KAAK,MAAO,KAAM,UAAW,GACnCsF,EAAG,GAAK,IAAI3I,EACZ2I,EAAG,GAAGtF,KAAK,KAAM,KAAM,SAAU,KACjCsF,EAAG,GAAK,IAAI3I,EACZ2I,EAAG,GAAGtF,KAAK,EAAG,EAAG,KAAM,GACvBsF,EAAG,GAAK,IAAI3I,EACZ2I,EAAG,GAAGtF,KAAK,KAAM,IAAK,QAAS,GAC/BsF,EAAG,GAAK,IAAI3I,EACZ2I,EAAG,GAAGtF,KAAK,IAAK,IAAK,OAAQ,MAC7B,IAAK,IAAIzG,EAAE,EAAGA,EAAE,EAAGA,IAAK,CACvBwH,EAAW,EAAFxH,GAAO+L,EAAG/L,GACnB,IAAK,IAAI0B,EAAE,EAAGA,EAAE,EAAGA,IAClB8F,EAAW,EAAFxH,EAAI0B,EAAE,GAAK,IAAI0B,EACxBgD,EAASoB,EAAW,EAAFxH,EAAI0B,GAAIqK,EAAG/L,GAAIwH,EAAW,EAAFxH,EAAI0B,EAAE,IAChDuE,EAASuB,EAAW,EAAFxH,EAAI0B,GAAIqK,EAAG/L,GAAIwH,EAAW,EAAFxH,EAAI0B,EAAE,IAGlD,IAEIsK,EAFA/L,EAAI,IAAImD,EACRlD,EAAI,IAAIkD,EAER6I,EAAK,IAAI7I,EACb6I,EAAGxF,KAAK,MAAO,EAAG,UAAW,GAC7B,IAAIyF,EAAK,IAAI9I,EACb8I,EAAGzF,KAAK,MAAO,EAAG,UAAW,MAC7B,IAAI0F,EAAM,IAAI/I,EACd+I,EAAI1F,KAAK,KAAM,EAAG,SAAU,GAC5B0F,EAAI5I,GAAK,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChC,IAAK,IAAI3D,EAAE,EAAGA,EAAE,GAAIA,IACnB6H,EAAQ7H,GAAKmC,MAAM,IACnB2F,EAAQ9H,GAAKmC,MAAM,IACnB+F,EAAUlI,GAAKmC,MAAM,IACrBwF,EAAQ3H,GAAK,IAAIwD,EACjBmE,EAAQ3H,GAAG4G,KAAKvG,GAChBgG,EAAShG,EAAGiM,EAAIhM,GAChBkG,EAASnG,EAAGiM,EAAIhM,GAChB8L,EAAO9L,EAAGA,EAAID,EAAGA,EAAI+L,EACjBpM,EAAI,GAAK,IACZqG,EAAShG,EAAGkM,EAAKjM,GACjBkG,EAASnG,EAAGkM,EAAKjM,GACjB8L,EAAO9L,EAAGA,EAAID,EAAGA,EAAI+L,GAElBpM,EAAI,GAAK,IACZqG,EAAShG,EAAGgM,EAAI/L,GAChBkG,EAASnG,EAAGgM,EAAI/L,GAChB8L,EAAO9L,EAAGA,EAAID,EAAGA,EAAI+L,GAIvB,IAAK,IAAIlJ,EAAE,EAAGA,EAAE,GAAIA,IACnB,IAAK,IAAIe,EAAE,EAAGA,EAAE,GAAIA,IAEnB,GADAoC,EAASsB,EAAQzE,GAAIyE,EAAQ1D,GAAI5D,GAClB,GAAXA,EAAEqD,GAAG,IAAsB,GAAXrD,EAAEqD,GAAG,IAAsB,GAAXrD,EAAEqD,GAAG,GAAS,CACjDS,EAAOjB,GAAKe,EACZ,MAIH,IAASjE,EAAE,EAAGA,EAAE,GAAIA,IACnB,IAASkD,EAAE,EAAGA,EAAE,GAAIA,IAEnB,IADAmD,EAASsB,EAAQ3H,GAAI2H,EAAQzE,GAAI7C,GACxB4D,EAAE,EAAGA,EAAE,GAAIA,IACnB,GAAI0D,EAAQ1D,GAAGP,GAAG,IAAMrD,EAAEqD,GAAG,IAAMiE,EAAQ1D,GAAGP,GAAG,IAAMrD,EAAEqD,GAAG,IAAMiE,EAAQ1D,GAAGP,GAAG,IAAMrD,EAAEqD,GAAG,GAAI,CAC9FmE,EAAQ7H,GAAGkD,GAAKe,EAChB,MAKJ,IAASf,EAAE,EAAGA,EAAE,GAAIA,IACnB,IAAK,IAAInB,EAAE,EAAGA,EAAE,GAAIA,IAEnB,IADA4C,EAAciD,EAAS1E,GAAIiB,EAAOpC,GAAI1B,GAC7BD,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxB,IAAIoM,EAAQ,EACZ,IAASxM,EAAE,EAAGA,EAAE,EAAGA,IAClB,GAAIK,EAAEqD,GAAG1D,IAAM4H,EAASxH,GAAGsD,GAAG1D,IAAMK,EAAEsD,GAAG3D,IAAM4H,EAASxH,GAAGuD,GAAG3D,GAAI,CACjEwM,EAAQ,EACR,MAGEA,IACH1E,EAAQ/F,GAAGmB,GAAK9C,GAKpB,IAAS8C,EAAE,EAAGA,EAAE,GAAIA,IACnB,IAASnB,EAAE,EAAGA,EAAE,GAAIA,IACnBmG,EAAUnG,GAAGmB,GAAKJ,EAAOgF,EAAQ/F,GAAGc,EAAOK,KAG7C,IAASA,EAAE,EAAGA,EAAE,EAAGA,IAIlB,IAHA6E,EAAS7E,GAAKf,MAAM,GACpB6F,EAAS9E,GAAKf,MAAM,IACpB8F,EAAY/E,GAAKf,MAAM,GACdJ,EAAE,EAAGA,EAAE,EAAGA,IAClBgG,EAAS7E,GAAGnB,GAAM8F,EAAQ3E,GAAG,GAAGnB,GAAG,KAAK,EAG1C,IAASmB,EAAE,EAAGA,EAAE,GAAIA,IACnB,IAASnB,EAAE,EAAGA,EAAE,EAAGA,IAClBiG,EAASjG,GAAGmB,GAAK4E,EAAQ/F,GAAG,GAAGmB,GAGjC,IAASA,EAAE,EAAGA,EAAE,EAAGA,IAClB,IAASnB,EAAE,EAAGA,EAAE,EAAGA,IAClBkG,EAAY/E,GAAGnB,GAAKgG,EAAS7E,GAAGiB,EAAOpC,GAAG,IAAI,GAIhD,MAAM0K,EAAM,IAAItK,MAAM,MAEtB,IAAIuK,EAAQ,EACZ,IAAS1M,EAAE,EAAGA,EAAE,GAAIyM,EAAIzM,KAAO,GAE/B,IAASA,EAAE,EAAGA,EAAE,KAAMA,IACrB,GAAkC,IAA7ByM,EAAIzM,IAAI,GAAI,IAAM,GAAFA,IAAgB,CAEpC,IADAK,EAAEiE,QAAQtE,GACD+B,EAAE,EAAGA,EAAE,GAAIA,GAAG,EACtBmC,EAAc7D,EAAG0B,EAAGzB,GAEpBmM,GADInK,EAAMhC,EAAEwD,aACF,IAAM,IAAQ,GAAJxB,GACpB0B,EAAQ1B,GAASoK,GAAS,EAAM3K,IAAM,EAEvCsC,EAAQqI,KAAW1M,EAKrB,IADA0M,EAAQ,EACC1M,EAAE,EAAGA,EAAE,GAAIyM,EAAIzM,KAAO,GAC/B,IAASA,EAAE,EAAGA,EAAE,KAAMA,IACrB,GAAkC,IAA7ByM,EAAIzM,IAAI,GAAI,IAAM,GAAFA,IAAgB,CAEpC,IADAK,EAAEwE,SAAS7E,GACF+B,EAAE,EAAGA,EAAE,GAAIA,GAAG,EACtB4C,EAActE,EAAG0B,EAAGzB,GAEpBmM,GADInK,EAAMhC,EAAEkE,cACF,IAAM,IAAQ,GAAJlC,GACpBoC,EAASpC,GAAUoK,GAAS,EAAM3K,IAAM,EAEzC6C,EAAS8H,KAAW1M,EAKtB,IAAIsF,EAAOnD,MAAM,IACjB,IAASnC,EAAE,EAAGA,EAAE,GAAIA,IACnBsF,EAAKtF,GAAKmC,MAAM,GAChBiG,EAAMpI,GAAKmC,MAAM,IAElB,IAASnC,EAAE,EAAGA,EAAE,MAAOA,IAAK,CAC3BkH,EAAS7G,EAAEuD,GAAI5D,GACf,IAAIqH,KAAOhH,EAAEoF,YAAc,GACvB6B,KAAOjH,EAAEqF,YAAc,GAC3BJ,EAAK+B,GAAGC,IAAI,IAAM,IAAQ,GAAFA,GAGzB,IAAStH,EAAE,EAAGA,EAAE,GAAIA,IAEnB,IADA0M,EAAQ,EACCxJ,EAAE,EAAGA,EAAE,GAAIA,IACmB,IAAjCoC,EAAKtF,GAAGkD,IAAI,GAAI,IAAM,GAAFA,MACxBkF,EAAMpI,GAAGkD,GAAKwJ,KAKjB,IADAA,EAAQ,EACC1M,EAAE,EAAGA,EAAE,KAAMyM,EAAIzM,KAAO,GACjC,IAASA,EAAE,EAAGA,EAAE,MAAOA,IACtB,GAAkC,IAA7ByM,EAAIzM,IAAI,GAAI,IAAM,GAAFA,IAAgB,CAEpC,IADAkH,EAAS7G,EAAEuD,GAAI5D,GACN+B,EAAE,EAAGA,EAAE,GAAIA,IAAK,CAExB,IAAIO,EADJ4B,EAAc7D,EAAG0B,EAAGzB,GAEpBmM,GADInK,EAAMyD,EAASzF,EAAEsD,OACX,IAAM,IAAQ,GAAJtB,GAChB+E,EAAI/G,EAAEmF,YACN6B,EAAIhH,EAAEoF,YACNtF,EAA+B,KAA1BgI,KAASf,EAAE,OAAOC,EAAE,IAAiB,GAAJD,EAASC,EAAI,EAAI,EAAIjF,EAAWC,GAC1E6F,EAAS/H,GAAMsM,GAAS,EAAI3K,EAC5B+D,EAASxD,GAAQoK,GAAS,EAAI3K,EAE/BoE,EAASuG,KAAW1M,GA8mBtB2M,GAllBD,WACC,IAEI3M,EAFAK,EAAI,IAAImD,EACRlD,EAAI,IAAIkD,EAEZ,IAAKxD,EAAE,EAAGA,EAAE,KAAMA,IAGjB,IAFA+I,GAAU/I,GAAKmC,MAAM,IACrB+E,EAAS7G,EAAEqD,GAAIuC,EAASjG,IACnBkD,EAAE,EAAGA,EAAE,GAAIA,IACfmD,EAAShG,EAAGuH,EAAS1E,GAAI5C,GACzByI,GAAU/I,GAAGkD,GAAK5C,EAAEuF,cAGtB,IAAK7F,EAAE,EAAGA,EAAE,KAAMA,IAGjB,IAFAgJ,GAAUhJ,GAAKmC,MAAM,IACrB+E,EAAS7G,EAAEuD,GAAIuC,EAASnG,IACnBkD,EAAE,EAAGA,EAAE,GAAIA,IACfsD,EAASnG,EAAGuH,EAAS/E,EAAOK,IAAK5C,GACjC0I,GAAUhJ,GAAGkD,GAAK5C,EAAE4F,cAGtB,IAAKlG,EAAE,EAAGA,EAAE,IAAKA,IAGhB,IAFAuI,EAASvI,GAAKmC,MAAM,IACpB9B,EAAEiE,QAAQD,EAAQrE,IACbkD,EAAE,EAAGA,EAAE,GAAIA,IACfsD,EAASnG,EAAGuH,EAAS1E,GAAI5C,GACzBiI,EAASvI,GAAGkD,GAAK5C,EAAEyD,aAGrB,IAAK/D,EAAE,EAAGA,EAAE,IAAKA,IAGhB,IAFAsI,EAAUtI,GAAKmC,MAAM,IACrB9B,EAAEwE,SAASD,EAAS5E,IACfkD,EAAE,EAAGA,EAAE,GAAIA,IACfmD,EAAShG,EAAGuH,EAAS1E,GAAI5C,GACzBgI,EAAUtI,GAAGkD,GAAK5C,EAAEmE,cAGtB,IAAKzE,EAAE,EAAGA,EAAE,IAAKA,IAGhB,IAFAqI,EAAYrI,GAAKmC,MAAM,IACvB9B,EAAE2E,WAAWhF,GACRkD,EAAE,EAAGA,EAAE,GAAIA,IACfsD,EAASnG,EAAGuH,EAAS1E,GAAI5C,GACzB+H,EAAYrI,GAAGkD,GAAK5C,EAAEyE,aAGxB,IAAK/E,EAAE,EAAGA,EAAE,IAAKA,IAGhB,IAFAwI,EAAYxI,GAAKmC,MAAM,GACvB9B,EAAE2E,WAAWhF,GACRkD,EAAE,EAAGA,EAAE,GAAIA,GAAG,EAClBgB,EAAc7D,EAAG8D,EAAOjB,GAAI5C,GAC5BkI,EAAYxI,GAAGkD,IAAI,GAAK5C,EAAEyE,aAG5B,IAAK/E,EAAE,EAAGA,EAAE,KAAMA,IAGjB,IAFA4I,GAAS5I,GAAKmC,MAAM,IACpB9B,EAAEkF,QAAQvF,GACLkD,EAAE,EAAGA,EAAE,GAAIA,IACfsD,EAASnG,EAAGuH,EAAS1E,GAAI5C,GACzBsI,GAAS5I,GAAGkD,GAAK5C,EAAE6E,UAGrB,IAAKnF,EAAE,EAAGA,EAAE,GAAIA,IACfK,EAAE6E,SAASlF,GACX6I,GAAWxI,EAAE8E,UAAY,IAAMnF,EAEhC,IAAKA,EAAE,EAAGA,EAAE,KAAMA,IACjB8I,GAAQ9I,IAAI,IAAOqC,EAAW4D,EAASjG,MAAa,EAAJA,GAEjD,IAAKA,EAAE,EAAGA,EAAE,GAAIA,IAGf,IAFAiJ,GAAUjJ,GAAKmC,MAAM,IACrB9B,EAAE6E,SAASlF,GACNkD,EAAE,EAAGA,EAAE,GAAIA,IACfsD,EAASnG,EAAGuH,EAAS/E,EAAOK,IAAK5C,GACjC2I,GAAUjJ,GAAGkD,GAAK5C,EAAE2E,WAGtB,IAAKjF,EAAE,EAAGA,EAAE,GAAIA,IAGf,IAFAkJ,GAAUlJ,GAAKmC,MAAM,IACrB9B,EAAE6E,SAASlF,GACNkD,EAAE,EAAGA,EAAE,GAAIA,IACfgB,EAAc7D,EAAG8D,EAAOjB,GAAI5C,GAC5B4I,GAAUlJ,GAAGkD,GAAK5C,EAAE2E,WAItB,IAAI2H,EAAWzK,MAAM,KACrB,IAAKnC,EAAE,EAAGA,EAAE,IAAKA,IAAK,CACrBK,EAAEwE,SAASD,EAAS5E,IACpB,IAAK,IAAIkD,EAAE,EAAGA,EAAE,EAAGA,IAClByB,EAActE,EAAG6C,GAAG,EAAG5C,GACqB,OAAxCkC,EAAaoC,EAAUtE,EAAEkE,cAC5BoI,EAAS5M,IAAO,GAAKkD,GAIxB,IAAI2J,EAAY1K,MAAM,KACtB,IAAKnC,EAAE,EAAGA,EAAE,IAAKA,IAEhB,IADAK,EAAEiE,QAAQD,EAAQrE,IACTkD,EAAE,EAAGA,EAAE,EAAGA,IAClBgB,EAAc7D,EAAG6C,GAAG,EAAG5C,GACmB,OAAtCkC,EAAa6B,EAAS/D,EAAEwD,aAC3B+I,EAAU7M,IAAO,GAAKkD,GAIzB,IAAKlD,EAAE,EAAGA,EAAE,OAAWA,IACtB2I,GAAc3I,IAAM,EAErB,IAAKA,EAAE,EAAGA,EAAE,EAAGA,IACd2I,GAAc3I,GAAK,EAQpB,IANA,IAEI8M,EACAC,EACAC,EAJApB,EAAQ,EACRqB,EAAO,EAKJA,EAAO,QAKb,IAHAF,GADAD,EAAMlB,EAAQ,IACE,EAAIA,EACpBoB,EAAQF,EAAMlB,GAAS,EACvBA,IACK5L,EAAE,EAAGA,EAAE,OAAWA,IACtB,GAAI2I,GAAc3I,IAAM+M,EAAxB,CAEA,IAAIhG,KAAW/G,EAAI,MACfiH,EAAOjH,EAAI,KACX4J,EAAW,EAAJ5J,EACXiH,KAAU,EACV,IAAK,IAAI7G,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxB,IACIqL,EAAiB,GADjBD,EAASlD,EAAUvB,GAAO3G,IAE9BoL,KAAY,EACZ,IAAIE,EAAQnD,EAAStB,GAAMe,EAAS4B,GAAMxJ,IACtCuL,EAAQ1D,EAAYF,EAAiB,EAAR2D,GAAW9B,IAAO6B,GAGnD,GAAI9C,GADArG,GAAe,KAATkJ,IADVE,KAAW,IACyB,EAAIC,KACdqB,EAAO,CAEhC,GADAC,IACIH,EAAK,CACRnE,GAAc3I,GAAK4L,EACnB,MAEAjD,GAAcrG,IAAOsJ,EACrB,IAAIsB,EAAMN,EAASpB,GACf2B,EAAON,EAAUnB,GACrB,GAAW,GAAPwB,GAAoB,GAARC,EACf,IAASjK,EAAE,EAAGA,EAAE,EAAGA,IAAKiK,IAAS,EAChC,GAAkB,IAAN,EAAPA,GAEJ,IADA,IAAIC,EAASnF,EAAY0D,GAAOzI,GACvBe,EAAE,EAAGA,EAAE,EAAGA,IAClB,GAAwB,IAAnBiJ,EAAO,GAAKjJ,GAAU,CAC1B,IAAIoJ,EAAgB,KAAT7B,GAAiBE,GAAS,EAAIzD,EAAYmF,GAAQnJ,KACjC,GAAxB0E,GAAc0E,KACjB1E,GAAc0E,GAAQzB,EACtBqB,QAaX,IAAKjN,EAAE,EAAGA,EAAE,OAASA,IACpByI,EAAiBzI,IAAM,EAKxB,IAHAyI,EAAiB,GAAK,EACtBmD,EAAQ,EACRqB,EAAO,EACAA,EAAO,QAKb,IAHAF,GADAD,EAAMlB,EAAQ,IACE,EAAIA,EACpBoB,EAAQF,EAAMlB,GAAS,EACvBA,IACK5L,EAAE,EAAGA,EAAE,OAASA,IACpB,GAAIyI,EAAiBzI,IAAM+M,EAC1B,KAAIlD,EAAQ7J,EAAI,IAEhB,IADI+G,KAAW/G,EAAI,KACVI,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxB,IAAIoL,EACA8B,EAAgB,GADhB9B,EAASlD,EAAUvB,GAAO3G,IAE1BmL,EAAS/C,EAAYH,EAAYwB,GAAOzJ,IAAIkN,GAGhD,GAAI7E,EADAnG,GAAe,KADnBkJ,KAAY,GACaD,IACIyB,EAAO,CAEnC,GADAC,IACIH,EAAK,CACRrE,EAAiBzI,GAAK4L,EACtB,MAIA,GAFAnD,EAAiBnG,IAAOsJ,EAEb,IADPsB,EAAMN,EAASpB,IAElB,IAAStI,EAAE,EAAGA,EAAE,EAAGA,IAED,IAAN,GADXgK,IAAQ,MAEHG,EAAgB,IAAT7B,EAAehD,EAAY+C,GAAQrI,IACf,GAA3BuF,EAAiB4E,KACpB5E,EAAiB4E,GAAQzB,EACzBqB,QAaV,IAAKjN,EAAE,EAAGA,EAAE,OAASA,IACpB0I,EAAgB1I,IAAM,EAKvB,IAHA0I,EAAgB,GAAK,EACrBkD,EAAQ,EACRqB,EAAO,EACAA,EAAO,QAKb,IAHAF,GADAD,EAAMlB,EAAQ,IACE,EAAIA,EACpBoB,EAAQF,EAAMlB,GAAS,EACvBA,IACK5L,EAAE,EAAGA,EAAE,OAASA,IACpB,GAAI0I,EAAgB1I,IAAM+M,EAGzB,IAFIlD,EAAQ7J,EAAI,IACZiH,KAAUjH,EAAI,KACTI,EAAE,EAAGA,EAAE,GAAIA,IAMnB,GAJIkN,EAAe,GADf5B,EAAQnD,EAAStB,GAAM7G,IAEvBmL,EAAS/C,EAAYH,EAAYwB,GAAOzJ,IAAIkN,GAG5C5E,EADApG,GAAc,KADlBoJ,KAAW,GACaH,IACIyB,EAAO,CAElC,GADAC,IACIH,EAAK,CACRpE,EAAgB1I,GAAK4L,EACrB,MAIA,GAFAlD,EAAgBpG,IAAOsJ,EAEZ,IADPsB,EAAML,EAAUnB,IAEnB,IAASxI,EAAE,EAAGA,EAAE,EAAGA,IAED,IAAN,GADXgK,IAAQ,MAEHG,EAAe,IAAR3B,EAAclD,EAAY+C,GAAQrI,IACf,GAA1BwF,EAAgB2E,KACnB3E,EAAgB2E,GAAQzB,EACxBqB,MAeV,IADAL,EAAWzK,MAAM,MACZnC,EAAE,EAAGA,EAAE,KAAMA,IAEjB,IADAkH,EAAS7G,EAAEuD,GAAIuC,EAASnG,IACnBkD,EAAE,EAAGA,EAAE,GAAIA,IACfgB,EAAc7D,EAAG6C,EAAG5C,GAC0B,OAA1CkC,EAAa2D,EAAUJ,EAASzF,EAAEsD,OACrCgJ,EAAS5M,IAAO,GAAKkD,GAIxB,IAAKlD,EAAE,EAAGA,EAAE,MAASA,IACpBoJ,GAAWpJ,IAAM,EAGlB,IADAoJ,GAAW,GAAK,EACT6D,EAAO,OAKb,IAHAF,GADAD,EAAMlB,EAAQ,IACE,EAAIA,EACpBoB,EAAQF,EAAMlB,GAAS,EACvBA,IACK5L,EAAE,EAAGA,EAAE,MAASA,IACpB,GAAIoJ,GAAWpJ,IAAM+M,EACpB,KAAItK,EAAMzC,EAAI,GACVwF,MAAUxF,EAAI,IAClB,IAASI,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxB,IAAI0L,GAAQ9C,GAAUxD,IAAMpF,GAExByL,IADAyB,EAAe,GAARxB,GACA5C,GAAUD,GAAUxG,GAAKrC,IAAIkN,IAGxC,GAAIlE,GADA9G,GAAc,IADlBwJ,MAAW,GACYD,KACAmB,EAAO,CAE7B,GADAC,IACIH,EAAK,CACR1D,GAAWpJ,GAAK4L,EAChB,MAIA,GAFAxC,GAAW9G,IAAOsJ,EAEP,IADPsB,EAAMN,EAASd,KAElB,IAAK5I,EAAE,EAAGA,EAAE,GAAIA,IAEE,IAAN,GADXgK,IAAQ,MAEHG,EAAe,GAARvB,GAAa5C,GAAU2C,IAAM3I,IACf,GAArBkG,GAAWiE,KACdjE,GAAWiE,GAAQzB,EACnBqB,QAaV,IAAKjN,EAAE,EAAGA,EAAE,MAASA,IACpBmJ,GAAWnJ,IAAM,EAKlB,IAHAmJ,GAAW,GAAK,EAChByC,EAAQ,EACRqB,EAAO,EACAA,EAAO,OAKb,IAHAF,GADAD,EAAMlB,EAAQ,IACE,EAAIA,EACpBoB,EAAQF,EAAMlB,GAAS,EACvBA,IACK5L,EAAE,EAAGA,EAAE,MAASA,IACpB,GAAImJ,GAAWnJ,IAAM+M,EACpB,CAAItK,EAAMzC,EAAI,GAAd,IACI0G,MAAU1G,EAAI,IAClB,IAASI,EAAE,EAAGA,EAAE,GAAIA,IAAK,CACxB,IAIIkC,GAJAwI,GAAQ/B,GAAUrC,IAAM7D,EAAOzC,IAKnC,GAJIkN,EAAgB,GAARxC,GACRe,GAAO3C,GAAUD,GAAUxG,GAAKrC,IAAIkN,GAGpCnE,GADA7G,GAAc,IADlBwI,MAAW,GACYe,KACAmB,EAAO,CAE7B,GADAC,IACIH,EAAK,CACR3D,GAAWnJ,GAAK4L,EAChB,MAIA,GAFAzC,GAAW7G,IAAOsJ,EAEP,IADPsB,EAAMN,EAAS9B,KAElB,IAAK5H,EAAE,EAAGA,EAAE,GAAIA,IAEE,IAAN,GADXgK,IAAQ,MAEHG,EAAe,GAARvC,GAAa5B,GAAU2C,IAAM3I,EAAI8C,EAAI9C,KACvB,GAArBiG,GAAWkE,KACdlE,GAAWkE,GAAQzB,EACnBqB,SA4OVM,GACAtB,IAAc,GAaflM,EAAOD,QAAQoM,WAAaA,GAC5BnM,EAAOD,QAAQ0N,MAXf,SAAenN,GACd6L,KACA,MAAMuB,EAAK,IAAIjK,EAKf,OAJAiK,EAAG/J,GAAKrD,EAAEqD,GACV+J,EAAG9J,GAAKtD,EAAEsD,GACV8J,EAAG7J,GAAKvD,EAAEuD,GACV6J,EAAG5J,GAAKxD,EAAEwD,GA/LX,SAAexD,GACdA,EAAE+D,MAAQ,IAAIZ,EACd,IAAK,IAAIxD,EAAE,EAAGA,EAAE,EAAGA,IAClB+G,GAAM/G,GAAKK,EAAEoE,cACbkF,GAAK3J,GAAgB,EAAX+G,GAAM/G,GAChB+G,GAAM/G,MAAQ,EACdiH,GAAKjH,GAAKK,EAAE0D,aACZ6F,GAAK5J,GAAe,EAAViH,GAAKjH,GACfiH,GAAKjH,MAAQ,EACb6J,GAAM7J,GAAKK,EAAE0E,aACb+E,GAAM9J,GAAKK,EAAEwF,cACbkE,GAAM/J,GAAgB,GAAX8J,GAAM9J,GACjB8J,GAAM9J,MAAQ,EACdgK,GAAMhK,GAAKK,EAAE8E,UACb8E,GAAIjK,GAAKK,EAAEoF,YACXyE,GAAIlK,GAAKK,EAAEqF,YACXyE,GAAKnK,GAAK4K,KAAKM,IAAIN,KAAKM,IAAIzC,EAA4B,IAAX1B,GAAM/G,GAAWwI,EAAYqB,GAAM7J,IAAI2J,GAAK3J,KACrF0I,EAA0B,IAAVzB,GAAKjH,GAAWwI,EAAYqB,GAAM7J,IAAI4J,GAAK5J,MAC3D2I,GAAyB,KAAX5B,GAAM/G,IAAaiH,GAAKjH,IAAM,EAAIiI,EAAY2B,GAAK5J,IAAI2J,GAAK3J,OAC9EK,EAAE+F,eACK,GAAHpG,GACHK,EAAEoG,eAKJ,IAFA+D,GAAW,KACXH,GAAM,GACDrH,GAAQ,EAAGA,GAAQqH,GAAKrH,KAE5B,IADAoH,GAAaQ,KAAKC,IAAIR,GAAI,EAAE,EAAGA,GAAIrH,IAC9BqG,GAAO,EAAGA,GAAO,EAAGA,KAMxB,GALA3C,GAAK,GAAKoD,GAAMT,IAChBE,GAAK,GAAKQ,GAAMV,IAChBG,GAAK,GAAKQ,GAAMX,IAChBI,GAAG,GAAKQ,GAAIZ,IACZK,GAAG,GAAKQ,GAAIb,IACPc,GAAKd,KAAWrG,IAChByH,GAAO1D,GAAMsC,IAASM,GAAKN,IAASpC,GAAKoC,IAASO,GAAKP,IACvDQ,GAAMR,IAASrG,GAAS,IAC5B,OAAgB,MAAZwH,GACI,UAEAA,GAKX,MAAO,UAmJAkD,CAAMD,IAKd1N,EAAOD,QAAQ6N,WA9Of,WACC,IAAI3G,EACAF,EACJ,GACCE,KAA2B,UAAhB4D,KAAKgD,UAChB9G,KAA2B,MAAhB8D,KAAKgD,gBACsC,IAA5CvL,EAAWyE,GAASvE,EAAYyE,KAC3C,IAAI3G,EAAI,IAAImD,EAEZ,OADAnD,EAAEwG,KAAKC,KAA0B,KAAhB8D,KAAKgD,UAAkB5G,KAA0B,KAAhB4D,KAAKgD,WAChDvN,I,s0QCpiCKwN,EAAc9M,OAAO,iBACrB+M,EAAiB/M,OAAO,oBACxBgN,EAAehN,OAAO,wBAE7BiN,EAAcjN,OAAO,kBAuJrBkN,EAAYvL,GACA,kBAARA,GAA4B,OAARA,GAAgC,oBAARA,EAkChDwL,EAA6D,CACjEC,UAAYzL,GACVuL,EAASvL,IAASA,EAAoBmL,GACxCO,UAAUC,GACR,MAAM,MAAEC,EAAK,MAAEC,GAAU,IAAIC,eAE7B,OADAC,EAAOJ,EAAKC,GACL,CAACC,EAAO,CAACA,KAElBG,YAAYC,GAEV,OADAA,EAAKC,QA+IAC,EA9IOF,EA8IY,GAAIG,G,IADMA,IA1FzBC,EAAmB,IAAIC,IAGlC,CACA,CAAC,QAASd,GACV,CAAC,QAtCC,CACFC,UAAYlN,GACVgN,EAAShN,IAAU+M,KAAe/M,EACpCmN,UAASa,GAAU,IACbC,GADI,MAAEjO,GAAOgO,EAcjB,OAXEC,EADEjO,aAAiBkO,MACN,CACXC,SAAS,EACTnO,MAAO,CACLoO,QAASpO,EAAMoO,QACf9O,KAAMU,EAAMV,KACZ+O,MAAOrO,EAAMqO,QAIJ,CAAEF,SAAS,EAAOnO,SAE1B,CAACiO,EAAY,KAEtBR,YAAYQ,GACV,GAAIA,EAAWE,QACb,MAAM1O,OAAO6O,OACX,IAAIJ,MAAMD,EAAWjO,MAAMoO,SAC3BH,EAAWjO,OAGf,MAAMiO,EAAWjO,W,SAeLwN,EAAOJ,GAAoC,IAA1BzK,EAAA4L,UAAAvN,OAAA,QAAAwN,IAAAD,UAAA,GAAAA,UAAA,GAAeE,KAC9C9L,EAAG+L,iBAAiB,WAAW,SAASC,EAASC,GAC/C,IAAKA,IAAOA,EAAGC,KACb,OAEF,MAAM,GAAEC,EAAE,KAAEC,EAAI,KAAEC,GAAMvP,OAAA6O,OAAA,CACtBU,KAAM,IACFJ,EAAGC,MAEHI,GAAgBL,EAAGC,KAAKI,cAAgB,IAAIC,IAAIC,GACtD,IAAIC,EACJ,IACE,MAAMC,EAASL,EAAKpG,MAAM,GAAI,GAAG0G,QAAO,CAAClC,EAAKmC,IAASnC,EAAImC,IAAOnC,GAC5DoC,EAAWR,EAAKM,QAAO,CAAClC,EAAKmC,IAASnC,EAAImC,IAAOnC,GACvD,OAAQ2B,GACN,IAAK,MAEDK,EAAcI,EAEhB,MACF,IAAK,MAEDH,EAAOL,EAAKpG,OAAO,GAAG,IAAMuG,EAAcP,EAAGC,KAAK7O,OAClDoP,GAAc,EAEhB,MACF,IAAK,QAEDA,EAAcI,EAASC,MAAMJ,EAAQJ,GAEvC,MACF,IAAK,YAGDG,EAAcM,EADA,IAAIF,KAAYP,IAGhC,MACF,IAAK,WACH,CACE,MAAM,MAAE5B,EAAK,MAAEC,GAAU,IAAIC,eAC7BC,EAAOJ,EAAKE,GACZ8B,EAAcO,EAAStC,EAAO,CAACA,IAEjC,MACF,IAAK,UAED+B,OAAcZ,EAEhB,MACF,QACE,QAEJ,MAAOxO,GACPoP,EAAc,CAAEpP,QAAO,CAAC+M,GAAc,GAExC6C,QAAQC,QAAQT,GACbU,OAAO9P,IACC,CAAEA,QAAO,CAAC+M,GAAc,MAEhCgD,MAAMX,IACL,MAAOY,EAAWC,GAAiBC,EAAYd,GAC/CzM,EAAGwN,YAAW1Q,OAAA6O,OAAA7O,OAAA6O,OAAC,GAAK0B,GAAS,CAAElB,OAAMmB,GACxB,YAATlB,IAEFpM,EAAGyN,oBAAoB,UAAWzB,GAClC0B,EAAc1N,UAIlBA,EAAGgL,OACLhL,EAAGgL,QAQP,SAAS0C,EAAcC,IAJvB,SAAuBA,GACrB,MAAqC,gBAA9BA,EAASC,YAAYjR,MAIxBkR,CAAcF,IAAWA,EAASG,QAOxC,SAASC,EAAqBC,GAC5B,GAAIA,EACF,MAAM,IAAIzC,MAAM,8CAIpB,SAASN,EACPjL,GAE+B,IAD/BqM,EAAAT,UAAAvN,OAAA,QAAAwN,IAAAD,UAAA,GAAAA,UAAA,GAAqC,GACrCV,EAAAU,UAAAvN,OAAA,QAAAwN,IAAAD,UAAA,GAAAA,UAAA,GAAiB,aAEbqC,GAAkB,EACtB,MAAMlB,EAAQ,IAAImB,MAAMhD,EAAQ,CAC9BjO,IAAIkR,EAASvB,GAEX,GADAmB,EAAqBE,GACjBrB,IAASzC,EACX,MAAO,IACEiE,EAAuBpO,EAAI,CAChCoM,KAAM,UACNC,KAAMA,EAAKE,KAAKrO,GAAMA,EAAEmQ,eACvBjB,MAAK,KACNM,EAAc1N,GACdiO,GAAkB,KAIxB,GAAa,SAATrB,EAAiB,CACnB,GAAoB,IAAhBP,EAAKhO,OACP,MAAO,CAAE+O,KAAMA,IAAML,GAEvB,MAAM7P,EAAIkR,EAAuBpO,EAAI,CACnCoM,KAAM,MACNC,KAAMA,EAAKE,KAAKrO,GAAMA,EAAEmQ,eACvBjB,KAAKZ,GACR,OAAOtP,EAAEkQ,KAAKxP,KAAKV,GAErB,OAAO+N,EAAYjL,EAAI,IAAIqM,EAAMO,KAEnC0B,IAAIH,EAASvB,EAAMC,GACjBkB,EAAqBE,GAGrB,MAAO5Q,EAAOiQ,GAAiBC,EAAYV,GAC3C,OAAOuB,EACLpO,EACA,CACEoM,KAAM,MACNC,KAAM,IAAIA,EAAMO,GAAML,KAAKrO,GAAMA,EAAEmQ,aACnChR,SAEFiQ,GACAF,KAAKZ,IAETM,MAAMqB,EAASI,EAAUC,GACvBT,EAAqBE,GACrB,MAAMQ,EAAOpC,EAAKA,EAAKhO,OAAS,GAChC,GAAKoQ,IAAiBvE,EACpB,OAAOkE,EAAuBpO,EAAI,CAChCoM,KAAM,aACLgB,KAAKZ,GAGV,GAAa,SAATiC,EACF,OAAOxD,EAAYjL,EAAIqM,EAAKpG,MAAM,GAAI,IAExC,MAAOqG,EAAcgB,GAAiBoB,EAAiBF,GACvD,OAAOJ,EACLpO,EACA,CACEoM,KAAM,QACNC,KAAMA,EAAKE,KAAKrO,GAAMA,EAAEmQ,aACxB/B,gBAEFgB,GACAF,KAAKZ,IAETmC,UAAUR,EAASK,GACjBT,EAAqBE,GACrB,MAAO3B,EAAcgB,GAAiBoB,EAAiBF,GACvD,OAAOJ,EACLpO,EACA,CACEoM,KAAM,YACNC,KAAMA,EAAKE,KAAKrO,GAAMA,EAAEmQ,aACxB/B,gBAEFgB,GACAF,KAAKZ,MAGX,OAAOO,EAOT,SAAS2B,EAAiBpC,GACxB,MAAMsC,EAAYtC,EAAaC,IAAIgB,GACnC,MAAO,CAACqB,EAAUrC,KAAK/I,GAAMA,EAAE,MANdlF,EAM0BsQ,EAAUrC,KAAK/I,GAAMA,EAAE,KAL3DjF,MAAMP,UAAU6Q,OAAO/B,MAAM,GAAIxO,KAD1C,IAAmBA,EASnB,MAAMwQ,EAAgB,IAAIC,Q,SACV/B,EAAYvC,EAAQuE,GAElC,OADAF,EAAcR,IAAI7D,EAAKuE,GAChBvE,E,SAGOsC,EAAStC,GACvB,OAAO3N,OAAO6O,OAAOlB,EAAK,CAAE,CAACR,IAAc,IAgB7C,SAASsD,EAAYlQ,GACnB,IAAK,MAAOV,EAAMsS,KAAY9D,EAC5B,GAAI8D,EAAQ1E,UAAUlN,GAAQ,CAC5B,MAAO6R,EAAiB5B,GAAiB2B,EAAQzE,UAAUnN,GAC3D,MAAO,CACL,CACE+O,KAAM,UACNzP,OACAU,MAAO6R,GAET5B,GAIN,MAAO,CACL,CACElB,KAAM,MACN/O,SAEFyR,EAAc7R,IAAII,IAAU,IAIhC,SAASmP,EAAcnP,GACrB,OAAQA,EAAM+O,MACZ,IAAK,UACH,OAAOjB,EAAiBlO,IAAII,EAAMV,MAAOmO,YAAYzN,EAAMA,OAC7D,IAAK,MACH,OAAOA,EAAMA,OAInB,SAAS+Q,EACPpO,EACAmP,EACAH,GAEA,OAAO,IAAI/B,SAASC,IAClB,MAAMf,EAgBD,IAAI5N,MAAM,GACd6Q,KAAK,GACL7C,KAAI,IAAMvF,KAAKqI,MAAMrI,KAAKgD,SAAWsF,OAAOC,kBAAkBlB,SAAS,MACvEmB,KAAK,KAlBNxP,EAAG+L,iBAAiB,WAAW,SAAS1P,EAAE4P,GACnCA,EAAGC,MAASD,EAAGC,KAAKC,IAAMF,EAAGC,KAAKC,KAAOA,IAG9CnM,EAAGyN,oBAAoB,UAAWpR,GAClC6Q,EAAQjB,EAAGC,UAETlM,EAAGgL,OACLhL,EAAGgL,QAELhL,EAAGwN,YAAW1Q,OAAA6O,OAAC,CAAEQ,MAAOgD,GAAOH,MC/hB5B,IAAKS,GAEX,SAFWA,OAAI,SAAJA,IAAI,SAAJA,IAAI,SAAJA,IAAI,SAAJA,IAAI,SAAJA,IAAI,SAAJA,IAAI,SAEf,CAFWA,MAAI,KAIhB,MAAMC,EAAID,EAAKC,EACTC,EAAIF,EAAKE,EACTC,EAAIH,EAAKG,EACTC,EAAIJ,EAAKI,EACTC,EAAIL,EAAKK,EACTC,EAAIN,EAAKM,EAGR,IAAKC,GAEX,SAFWA,OAAG,SAAHA,IAAG,SAAHA,IAAG,SAEd,CAFWA,MAAG,KAGf,MAAMC,EAAID,EAAIC,EACRC,EAAIF,EAAIE,EACRC,EAAIH,EAAIG,EAcd,IAAIC,EAAqC,CACrC,CAACV,EAAEE,EAAEE,GAAI,CAACJ,EAAEI,EAAED,GAAI,CAACH,EAAEG,EAAEE,GAAI,CAACL,EAAEK,EAAEH,GAChC,CAACD,EAAEG,EAAEF,GAAI,CAACD,EAAEE,EAAEC,GAAI,CAACH,EAAEI,EAAEF,GAAI,CAACF,EAAEC,EAAEG,IAIhCM,EAAiC,CACjC,CAACX,EAAEE,GAAI,CAACF,EAAEI,GAAI,CAACJ,EAAEG,GAAI,CAACH,EAAEK,GACxB,CAACJ,EAAEC,GAAI,CAACD,EAAEG,GAAI,CAACH,EAAEE,GAAI,CAACF,EAAEI,GACxB,CAACH,EAAEE,GAAI,CAACD,EAAEC,GAAI,CAACD,EAAEE,GAAI,CAACH,EAAEG,IAGxBO,EAAqC,CACrC,CAACZ,GAAI,CAACC,GAAI,CAACC,GAAI,CAACC,GAAI,CAACC,GAAI,CAACC,IAG1BQ,EAA6C,CAC7C,CAACb,EAAEK,EAAEH,GAAG,CAACF,EAAEE,EAAEE,GAAI,CAACJ,EAAEI,EAAED,GAAI,CAACH,EAAEG,EAAEE,GAC/B,CAACJ,EAAEC,EAAEG,GAAG,CAACJ,EAAEG,EAAEF,GAAI,CAACD,EAAEE,EAAEC,GAAI,CAACH,EAAEI,EAAEF,IAG/BW,EAAyC,CACzC,CAACd,EAAGK,GAAI,CAACL,EAAEE,GAAI,CAACF,EAAEI,GAAI,CAACJ,EAAEG,GACzB,CAACF,EAAGI,GAAI,CAACJ,EAAEC,GAAI,CAACD,EAAEG,GAAI,CAACH,EAAEE,GACzB,CAACD,EAAGG,GAAI,CAACH,EAAEE,GAAI,CAACD,EAAEC,GAAI,CAACD,EAAEE,IAmBzBU,EAAY,CACZC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,GACLnU,KAAM,KAGNoU,EAAY,CACZL,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,IAAK,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IACpCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,GACLnU,KAAM,KAGNO,EAAY,CACZwT,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,IAAK,CAAC,GAAI,GAAI,CAAC,EAAG,IAAK,CAAC,GAAI,IACtCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,GACLnU,KAAM,KAGNN,EAAY,CACZqU,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,GACLnU,KAAM,KAGND,EAAY,CACZgU,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,GACLnU,KAAM,KAGN+G,EAAY,CACZgN,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAAK,CAAC,GAAI,IACpCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,GACLnU,KAAM,KAGNH,EAAY,CACZkU,IAAK,GACLC,IAAK,GACLC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCnU,KAAM,KAGNqU,EAAY,CACZN,IAAK,GACLC,IAAK,GACLC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,IAAK,CAAC,GAAI,IAAK,CAAC,GAAI,IACtCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCnU,KAAM,KAGNwB,EAAY,CACZuS,IAAK,GACLC,IAAK,GACLC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCC,IAAK,CAAC,EAAG,EAAG,EAAG,GACfC,IAAK,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAClCnU,KAAM,KASNsU,EAAoB,CACpB,CAAC,EAAG,EAAGhB,GAAI,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGD,GAC7B,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGD,GAC7B,CAAC,EAAG,EAAGD,GAAI,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGD,IAG7BiB,EAAoB,CACpB,CAAC,EAAG,EAAGjB,GAAI,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGD,GAC7B,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGC,GAAI,CAAC,GAAG,EAAGD,GAC7B,CAAC,EAAG,EAAGD,GAAI,CAAC,EAAG,EAAGC,GAAI,CAAC,EAAG,EAAGD,IAuCjC,IAAIkB,EAAW,2FCjNXC,EAAYlU,GACL8J,KAAKqI,MAAMrI,KAAKgD,SAAW9M,GAGlCmU,EAAYA,CAAChV,EAAWa,IACjBkU,EAASlU,EAAIb,EAAI,GAAKA,EAE7BiV,EAAc,SAAYhT,GAC1B,OAAOA,EAAI8S,EAAS9S,EAAID,UAa5B,SAASkT,IAAkD,IAAD,IAAAC,EAAA5F,UAAAvN,OAA1BoT,EAAU,IAAAlT,MAAAiT,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAVD,EAAUC,GAAA9F,UAAA8F,GACtC,OAAOD,EAAW9E,QAChB,CAACgF,EAASC,IACRD,EACGpF,KAAIsF,GAAUD,EAAQrF,KAAIuF,GAASD,EAAOhD,OAAO,CAACiD,QAClDnF,QAAO,CAACoF,EAAYF,IAAWE,EAAWlD,OAAOgD,IAAS,KAC/D,CAAC,KAIP,IAAIG,EAAaC,IACb,IAAIC,EAAU3T,MAAM0T,EAAK5T,QAAQ+Q,MAAK,GAClC+C,EAASA,CAAC/V,EAAWgW,IACjBF,EAAQ9V,GACD,GAEP8V,EAAQ9V,GAAK,EACT8V,EAAQD,EAAK7V,IACNgW,EAEAD,EAAOF,EAAK7V,GAAIgW,EAAM,IAGrCC,EAAM,EACV,IAAK,IAAIC,KAAKL,EACVI,GAAOF,EAAOG,EAAG,GAErB,OAAOD,GAGPE,GAAa,SAAYC,EAAWC,GACpC,GAAID,EAAKnU,SAAWoU,EAAKpU,OAAQ,OAAO,EACxC,IAAK,IAAIjC,EAAI,EAAGA,EAAIoW,EAAKnU,OAAQjC,IAC7B,GAAIoW,EAAKpW,KAAOqW,EAAKrW,GAAI,OAAO,EAEpC,OAAO,GC9CJ,MAAMwD,GAOTkL,YAAY3M,GACR,IAAIsM,EAAMiI,KAAKC,MAAMxU,GAErB,OADA0B,KAAKyO,IAAI7D,GACF5K,KAEX2K,YACI,IAAI,GAAC1K,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAE2S,GAAM/S,KAC3B,OAAO6S,KAAKG,UAAU,CAAC/S,KAAIC,KAAIC,KAAIC,KAAI2S,OAG3CE,KAQI,OAPAjT,KAAKyO,IAAI,CACLxO,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1BC,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1BC,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IACvCC,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtC2S,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,KAEjB/S,KAEXkT,QACI,OAAO,IAAInT,GAAU,CACjBE,GAAI,IAAID,KAAKC,IACbC,GAAI,IAAIF,KAAKE,IACbC,GAAI,IAAIH,KAAKG,IACbC,GAAI,IAAIJ,KAAKI,IACb2S,GAAI,IAAI/S,KAAK+S,MAGrBhF,YAAYvQ,GAA8F,KAnC1GyC,GAAe,GAAG,KAClBC,GAAe,GAAG,KAClBC,GAAe,GAAG,KAClBC,GAAe,GAAG,KAClB2S,GAAe,GAgCPvV,aAAiBuC,GACjBC,KAAKyO,IAAI,CACLxO,GAAIzC,EAAMyC,GAAIC,GAAI1C,EAAM0C,GAAIC,GAAI3C,EAAM2C,GAAIC,GAAI5C,EAAM4C,GAAI2S,GAAIvV,EAAMuV,KAGjEvV,GACLwC,KAAKC,GAAKzC,EAAMyC,GAChBD,KAAKE,GAAK1C,EAAM0C,GAChBF,KAAKG,GAAK3C,EAAM2C,GAChBH,KAAKI,GAAK5C,EAAM4C,GAChBJ,KAAK+S,GAAKvV,EAAMuV,IAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IAEtC/S,KAAKiT,KAGbxE,IAAIjR,GACAwC,KAAKC,GAAKzC,EAAMyC,IAAMD,KAAKC,GAC3BD,KAAKE,GAAK1C,EAAM0C,IAAMF,KAAKE,GAC3BF,KAAKG,GAAK3C,EAAM2C,IAAMH,KAAKG,GAC3BH,KAAKI,GAAK5C,EAAM4C,IAAMJ,KAAKI,GAC3BJ,KAAK+S,GAAKvV,EAAMuV,IAAM/S,KAAK+S,GAE/BI,eAAenW,EAAkBqB,EAAkB+U,EAAmBC,EAAoBC,GACtF,IAAIC,EAAQ,IAAIvW,GACZwW,EAAQ,IAAInV,GAEhB,IAAK,IAAI9B,EAAI,EAAGA,EAAI6W,EAAG5U,OAAQjC,IAAK,CAEhC,IAAIkX,EAAMJ,EAAG9W,GAAG,GAAImX,EAAML,EAAG9W,GAAG,GAChCiX,EAAME,GAAOrV,EAAEoV,GACfF,EAAMG,IAAQ1W,EAAEyW,GAAOL,EAAG7W,IAAM+W,EAEpC,MAAO,CAACC,EAAOC,GAEnBG,oBAAoBtV,EAAkBgV,EAAoBC,GACtD,IAAIE,EAAQ,IAAInV,GAEhB,IAAK,IAAI9B,EAAI,EAAGA,EAAI8W,EAAG7U,OAAQjC,IAAK,CAEhC,IAAIkX,EAAMJ,EAAG9W,GAAG,GAChBiX,EAD0BH,EAAG9W,GAAG,IACnB8B,EAAEoV,GAEnB,OAAOD,EAIXI,UAAU/N,GACN,IAAK3F,EAAID,GAAMD,KAAKmT,eAAenT,KAAKE,GAAIF,KAAKC,GAAI4F,EAAKiL,IAAKjL,EAAKgL,IAxF9D,IAyFDzQ,EAAID,GAAMH,KAAKmT,eAAenT,KAAKI,GAAIJ,KAAKG,GAAI0F,EAAKmL,IAAKnL,EAAKkL,IAxF9D,GAyFFgC,EAAK/S,KAAK2T,oBAAoB3T,KAAK+S,GAAIlN,EAAKoL,IAxF1C,GAyFN,OAAO,IAAIlR,GAAU,CAAEG,KAAID,KAAIG,KAAID,KAAI4S,OAG3Cc,wCAAwCR,EAAoBC,EAAajV,GACrE,MAAO,iBACDA,eAAeA,2CAEnBK,MAAM2U,EAAG7U,QAAQ+Q,KAAK,GAAG7C,KAAK,CAACoH,EAAGvX,KAChC,IAAIkX,EAAMJ,EAAG9W,GAAG,GAAImX,EAAML,EAAG9W,GAAG,GAChC,MAAO,qBACD8B,SAASqV,SAAWrV,KAAKoV,uBAEhC9D,KAAK,8BACMtR,mBAGlBwV,mCAAmCT,EAAmBC,EAAoBC,EAAatW,EAAWqB,GAC9F,MAAO,iBACDrB,eAAeA,oBACfqB,eAAeA,2CAEnBK,MAAM0U,EAAG5U,QAAQ+Q,KAAK,GAAG7C,KAAK,CAACoH,EAAGvX,KAChC,IAAIkX,EAAMJ,EAAG9W,GAAG,GAAImX,EAAML,EAAG9W,GAAG,GAAI2G,EAAMkQ,EAAG7W,GAC7C,MAAO,qBACD8B,SAASqV,SAAWrV,KAAKoV,wBACzBzW,SAAS0W,SAAW1W,KAAKyW,QAAUvQ,QAAUoQ,sBAEpD3D,KAAK,6BACK3S,UAAUqB,mBAG3BwV,2BAA2BhO,GAEvB,OAAO,IAAIkO,SAAS,OAAQ,uDAE1BhU,GAAUiU,4BAA4BnO,EAAKiL,IAAKjL,EAAKgL,IA9HjD,EA8H6D,KAAM,kBACvE9Q,GAAUiU,4BAA4BnO,EAAKmL,IAAKnL,EAAKkL,IA9HjD,EA8H6D,KAAM,kBACvEhR,GAAUkU,iCAAiCpO,EAAKoL,IA9H5C,EA8HwD,iHAMlEhE,MAAMpH,GACF,GAAInH,MAAMwV,QAAQrO,IAASA,aAAgBsO,GAAS,CAChD,IAAIC,EAAQ1V,MAAMwV,QAAQrO,GAAQA,EAAOA,EAAKuO,MAC1CC,EAAOrU,KAAKkT,QAChB,IAAK,IAAI3W,EAAI,EAAGA,EAAI6X,EAAM5V,OAAQjC,IAC9B8X,EAAOA,EAAKT,UAAUQ,EAAM7X,IAEhC,OAAO8X,EACJ,MAAoB,kBAATxO,EACP7F,KAAKiN,MAAM,IAAIkH,GAAQtO,IAGvB7F,KAAK4T,UAAU/N,GAI9BgO,qBAAqBS,GACjB,IAAIC,EAAQ,IAAID,GACZE,EAAYD,EAAMA,EAAM/V,OAAS,GACrC,IAAK,IAAIjC,EAAIgY,EAAM/V,OAAS,EAAGjC,EAAI,EAAGA,IAClCgY,EAAMhY,GAAKgY,EAAMhY,EAAI,GAGzB,OADAgY,EAAM,GAAKC,EACJD,EAEXV,8BAA8BS,GAC1B,IAAIC,EAAQ,IAAID,GACZG,EAAaF,EAAM,GACvB,IAAK,IAAIhY,EAAI,EAAGA,EAAIgY,EAAM/V,OAAS,EAAGjC,IAClCgY,EAAMhY,GAAKgY,EAAMhY,EAAI,GAGzB,OADAgY,EAAMA,EAAM/V,OAAS,GAAKiW,EACnBF,EAIXG,oBAAoBnE,EAA8BC,EAA0BC,GACxE,IAAIkE,EAAsC,GAE1C,IAAK,IAAIpY,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAIqY,EAAMrE,EAAchU,GACpBsY,EAAQtE,EAAcvQ,KAAKC,GAAG1D,IAElC,IAAK,IAAIkD,EAAI,EAAGA,EAAIO,KAAKE,GAAG3D,GAAGkD,IAC3BoV,EAAQ9U,GAAU+U,cAAcD,GAEpCF,EAAgBI,KAAK,CAACH,EAAKC,IAE/B,IAAK,IAAItY,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAIqY,EAAMpE,EAAYjU,GAClBsY,EAAQrE,EAAYxQ,KAAKG,GAAG5D,IAChC,IAAK,IAAIkD,EAAI,EAAGA,EAAIO,KAAKI,GAAG7D,GAAGkD,IAC3BoV,EAAQ9U,GAAU+U,cAAcD,GAEpCF,EAAgBI,KAAK,CAACH,EAAKC,IAE/B,IAAK,IAAItY,EAAI,EAAGA,EAAE,EAAEA,IAAK,CACrB,IAAIqY,EAAMnE,EAAclU,GACpBsY,EAAQpE,EAAczQ,KAAK+S,GAAGxW,IAClCoY,EAAgBI,KAAK,CAAEH,EAAKC,IAEhC,OAAOF,EAGXK,sBAAuBC,EAAwBC,EAAqCC,EAAiCC,GACjH,IAAIf,EAAO,IAAItU,GAEXsV,EAAkBA,CAACT,EAAaC,EAAeS,EAAiBC,KAChE,IAAIC,EAAW,IAAIjK,IAAI+J,EAAM5I,KAAK,CAAC+F,EAAGlW,IAAM,CAACkW,EAAEjE,WAAYjS,MACvD2G,EAAM,EACV,MAAQsS,EAASC,IAAIb,EAAIpG,cACrBoG,EAAM7U,GAAU2V,uBAAuBd,GACvC1R,MACIA,IAAQqS,MAEhB,MAAQC,EAASC,IAAIZ,EAAMrG,aAIvB,GAHAqG,EAAQ9U,GAAU2V,uBAAuBb,GAEzC3R,IACIA,GAAO,GAAI,CACXyS,QAAQC,KAAK,oBAAqBf,EAAOW,GACzC,MAKR,OADAtS,GAAOA,EAAMqS,GAAUA,EAChB,CAACrS,EAAKsS,EAASpY,IAAIwX,EAAIpG,YAAcgH,EAASpY,IAAIyX,EAAMrG,cAGnE,IAAK,IAAIqH,KAAcZ,EAAI,CACvB,IAAIL,EAAMiB,EAAW,GAAIhB,EAAQgB,EAAW,GACxCP,EAAmC,IAAfV,EAAIpW,OAAgB2W,EAChB,IAAfP,EAAIpW,OAAgB0W,EACpBE,GACRU,EAAOC,EAAOC,GAAWX,EAAgBT,EAAKC,EAAOS,EAAOV,EAAIpW,QAGlD,IAAfoW,EAAIpW,QACJ6V,EAAKjU,GAAG2V,GAAUD,EAClBzB,EAAKlU,GAAG4V,GAAUC,GACI,IAAfpB,EAAIpW,QACX6V,EAAKnU,GAAG6V,GAAUD,EAClBzB,EAAKpU,GAAG8V,GAAUC,GAElB3B,EAAKtB,GAAGgD,GAAUC,EAG1B,OAAO3B,EAGX4B,kBACI,IAAItB,EAAkB3U,KAAK0U,oBAAoBnE,EAAeC,EAAaC,GAE3E,OADWzQ,KAAKgV,sBAAsBL,EAAiBjE,EAAuBC,EAAqBF,GAIvGyF,eACuB,IAAflW,KAAK+S,GAAG,IACR/S,KAAKiN,MAAM,IAAIkH,GAAQ,OAE3B,IAAIgC,GAAgBhE,EAAUnS,KAAKC,IAAMkS,EAAUnS,KAAKG,KAAO,IAAM,EACjEiW,EAAepW,KAAKE,GAAG4M,QAAO,CAAC2F,EAAG4D,IAAM5D,EAAI4D,GAAG,GAAK,IAAM,GAAOrW,KAAKI,GAAG0M,QAAO,CAAC2F,EAAG4D,IAAM5D,EAAI4D,GAAG,GAAK,IAAM,EAChH,OAAOF,GAAgBC,EAG3BE,YAAYhY,GAER,IAAIqW,EAAkB3U,KAAK0U,oBAAoBnE,EAAeC,EAAaC,GAEvE8F,EAAsBjY,EAAE8V,MAAMtH,QAAQ,CAAC0J,EAAS3Q,KAChD,IAAI4Q,EAAexZ,OAAOyZ,YAAY7Q,EAAKoL,KAQ3C,OALauF,EAAQ9J,KAAKlB,IAAA,IAAEmL,EAAUC,GAAYpL,EAAA,MAC9C,CAACmL,EAASjK,KAAIwE,IAAC,IAAA2F,EAAA,OAAmB,QAAnBA,EAAIJ,EAAavF,UAAE,IAAA2F,IAAI3F,KACrC0F,EAAYlK,KAAIwE,IAAC,IAAA4F,EAAA,OAAmB,QAAnBA,EAAIL,EAAavF,UAAE,IAAA4F,IAAI5F,WAI7CyD,GAGJ,OADW3U,KAAKgV,sBAAsBuB,EAAqBhG,EAAeC,EAAaC,IASxF,MAAMsG,GAOThJ,YAAYiJ,EAA8Cla,GAAgB,KAN1E+T,IAAsB,GAAG,KACzBC,IAAqB,GAAG,KACxBC,IAAsB,GAAG,KACzBC,IAAqB,GAAG,KACxBC,IAAsB,GAAG,KACzBnU,KAAe,GAEP4B,MAAMwV,QAAQ8C,GACdhX,KAAKiX,WAAWD,EAAKla,GACdka,aAAeD,IACtB/W,KAAK6Q,IAAM,IAAImG,EAAInG,KACnB7Q,KAAK8Q,IAAM,IAAIkG,EAAIlG,KACnB9Q,KAAK+Q,IAAM,IAAIiG,EAAIjG,KACnB/Q,KAAKgR,IAAM,IAAIgG,EAAIhG,KACnBhR,KAAKiR,IAAM,IAAI+F,EAAI/F,KACnBjR,KAAKlD,KAAOA,GACLka,aAAejX,GACtBC,KAAKkX,UAAUF,EAAKla,GACbka,GACPhX,KAAKyO,IAAIuI,GAGjBvI,IAAI5I,GACA7F,KAAK6Q,IAAMhL,EAAKgL,IAChB7Q,KAAK8Q,IAAMjL,EAAKiL,IAChB9Q,KAAK+Q,IAAMlL,EAAKkL,IAChB/Q,KAAKgR,IAAMnL,EAAKmL,IAChBhR,KAAKiR,IAAMpL,EAAKoL,IAChBjR,KAAKlD,KAAO+I,EAAK/I,KAErBoa,UAAU7C,EAAiBvX,GACvB,IAAIqa,EAAaA,CAAC9Y,EAAkBrB,EAAkBoa,EAAuBC,KACzE,IAAK,IAAI9a,EAAI,EAAGA,EAAI8B,EAAEG,OAAQjC,IACtBA,IAAM8B,EAAE9B,IAAe,IAATS,EAAET,KAEhB6a,EAAMrC,KAAK,CAAC1W,EAAE9B,GAAIA,IAClB8a,EAAMtC,KAAK/X,EAAET,MAQzB,OAJA4a,EAAW9C,EAAKpU,GAAIoU,EAAKnU,GAAIF,KAAK6Q,IAAK7Q,KAAK8Q,KAC5CqG,EAAW9C,EAAKlU,GAAIkU,EAAKjU,GAAIJ,KAAK+Q,IAAK/Q,KAAKgR,KAC5CmG,EAAW9C,EAAKtB,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI/S,KAAKiR,IAAK,IAClDjR,KAAKlD,KAAOA,EACLkD,KAEXiX,WAAY7C,EAAetX,GAEvB,OADAkD,KAAKkX,WAAU,IAAInX,IAAYkN,MAAMmH,GAAQtX,GACtCkD,KAEXkT,QACI,OAAO,IAAI6D,GAAK/W,KAAMA,KAAKlD,MAE/B+W,oBAAoBhO,GAChB,MAAO,CAACA,GACJ,IAAIkR,IAAOE,WAAW,CAACpR,EAAMA,GAAOA,EAAK/I,KAAO,MAChD,IAAIia,IAAOE,WAAW,CAACpR,EAAMA,EAAMA,GAAOA,EAAK/I,KAAO,MA6C9DuM,MACI,IAAIvM,EACJ,OAAQkD,KAAKlD,KAAKkD,KAAKlD,KAAK0B,OAAS,IACjC,IAAK,IAAK1B,EAAOkD,KAAKlD,KAAKsJ,MAAM,EAAGpG,KAAKlD,KAAK0B,OAAS,GAAI,MAC3D,IAAK,IAAK1B,EAAOkD,KAAKlD,KAAM,MAC5B,QAASA,EAAOkD,KAAKlD,KAAO,IAEhC,OAAOia,GAAKO,IAAIxa,GAGpB0R,WACI,OAAOxO,KAAKlD,MAjHPia,GA6DFQ,oBAAsB,KACzB,IAAIC,EAAeT,GAAKS,aACpBC,EAAKD,EAAa,IAAIT,GAAKnG,IAC3B0D,EAAKkD,EAAa,IAAIT,GAAK7F,IAC3BwG,EAAKF,EAAa,IAAIT,GAAK1Z,IAC3Bsa,EAAKH,EAAa,IAAIT,GAAKva,IAC3Bob,EAAKJ,EAAa,IAAIT,GAAKla,IAC3Bgb,EAAKL,EAAa,IAAIT,GAAKlT,IAC3BiU,EAAKN,EAAa,IAAIT,GAAKpa,IAC3Bob,EAAKP,EAAa,IAAIT,GAAK5F,IAC3B6G,EAAKR,EAAa,IAAIT,GAAKzY,IAG3B2Z,EAAMT,EADD,IAAIT,GAAK,CAAC,IAAIA,GAAK1Z,GAAIya,EAAG,IAAK,MAGpCI,EAAMV,EADD,IAAIT,GAAK,CAAC,IAAIA,GAAKva,GAAI,IAAIua,GAAKpa,IAAK,MAG1Cwb,EAAMX,EADD,IAAIT,GAAK,CAAC,IAAIA,GAAKnG,GAAI,IAAImG,GAAK5F,IAAK,MAG1CiH,EAAMZ,EADD,IAAIT,GAAK,CAAC,IAAIA,GAAK7F,GAAI,IAAI6F,GAAKzY,IAAK,MAG1CmU,EAAI,IAAIsE,GAAK,CAAC,IAAIA,GAAK1Z,GAAIsa,EAAG,GAAIG,EAAG,IAAK,KAC1CO,EAAKb,EAAa/E,GAClB4D,EAAI,IAAIU,GAAK,CAAC,IAAIA,GAAKnG,GAAI,IAAImG,GAAK5F,GAAIyG,EAAG,IAAK,KAChDU,EAAKd,EAAanB,GAElBkC,EAAKf,EADD,IAAIT,GAAK,CAACtE,EAAG4D,EAAG5D,EAAGA,EAAGA,GAAI,MAI9B2B,EAAQ,CADH,IAAI2C,GAAK,IAAIhX,GAAa,MAG/B0X,EAAInD,EAAIoD,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAChCK,EAAIC,EAAIC,EACRN,EAAKC,EAAKC,EAAKC,GACjBI,OACEC,EAAsCxb,OAAOY,OAAO,IAExD,OADAuW,EAAMsE,SAAQ/b,GAAK8b,EAAW9b,EAAEG,MAAQH,IACjC8b,GAlGF1B,GAoGFO,IAA6BP,GAAKQ,sBAkBtC,MAAMpD,GAGTpG,YAAYqG,GAAyB,KAFrCA,MAAgB,GAGS,kBAAVA,EACPpU,KAAK8S,MAAMsB,GAEXpU,KAAKoU,MAAQA,EAWrBuE,YACI,IAAIC,EAAc,GAClB,IAAK,IAAIrc,EAAI,EAAIA,EAAIyD,KAAKoU,MAAM5V,OAAQjC,IAAK,CACzC,IAAII,EAAIqD,KAAKoU,MAAM7X,GACnB,GAAkB,MAAdI,EAAEG,KAAK,GAAY,CACnB,IAAI0D,EAAI2T,GAAQ0E,WAAWlc,EAAEG,OAASH,EAAEG,KAAK,GAC7C8b,EAAG7D,KAAKgC,GAAKO,IAAK9W,IAClBoY,EAAG7D,KAAKgC,GAAKO,IAAK9W,SAElBoY,EAAG7D,KAAKpY,GAGhB,OAAO,IAAIwX,GAAQyE,GAGvB/E,gBAAgBiF,EAAaC,GACzB,MAAMC,EAAUlc,GACQ,IAAhBA,EAAK0B,OAAqB,EACX,MAAZ1B,EAAK,GAAa,EAAI,EAE3Bmc,EAAU1G,GACI,IAARA,EAAa,GAAc,IAARA,EAAY,IAAM,IAEjD,GAAIuG,EAAMhc,KAAK,KAAOic,EAAMjc,KAAK,GAAI,CACjC,IAAIyV,GAAOyG,EAAOF,EAAMhc,MAAQkc,EAAOD,EAAMjc,OAAS,EACtD,OAAsB,IAAIqX,GAAd,IAAR5B,EAA8B,GACV,CAAEwE,GAAKO,IAAIwB,EAAMhc,KAAK,GAAKmc,EAAO1G,MAE1D,OAAO,IAAI4B,GAAQ,CAAC2E,EAAOC,IAInCG,eACI,IAAIC,EAAS,IAAIC,IAAI,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,OACnE,KAAOpZ,KAAKoU,MAAM5V,OAAS,GAAK2a,EAAO1D,IAAIzV,KAAKoU,MAAM,GAAGtX,OACrDkD,KAAKoU,MAAMiF,QAEf,OAAOrZ,KAGXsZ,WAAWC,GACP,IAAIC,EAAS,GACTC,EAAQ,GACRC,EAAcH,EAAII,OAAO,QACzBD,GAAe,IAAGH,EAAMA,EAAInT,MAAM,EAAGsT,IACzC,IAAK,IAAInd,EAAI,EAAGA,EAAIgd,EAAI/a,OAAQjC,IAAK,CACjC,IAAIqd,EAAKL,EAAIhd,GACb,GAAW,MAAPqd,GAAqB,MAAPA,EACO,IAAjBH,EAAMjb,SACNib,GAASF,EAAIhd,GACbid,EAAOzE,KAAK0E,GACZA,EAAQ,SAET,GAAW,MAAPG,EACHH,EAAMjb,OAAS,IACfgb,EAAOzE,KAAK0E,GAAQA,EAAQ,QAE7B,CACH,MAAMI,EAAMD,EAAGE,WAAW,IACpB,IAAMD,GAAOA,EAAM,IAAa,IAAMA,GAAOA,EAAM,OACjDJ,EAAMjb,OAAS,IACfgb,EAAOzE,KAAK0E,GACZA,EAAQ,IAEZA,GAASF,EAAIhd,KAIzB,IAAI6X,EAAQ,GACRqF,EAAMjb,OAAS,GAAGgb,EAAOzE,KAAK0E,GAClC,IAAK,IAAIA,KAASD,EAAQ,CACtB,IAAI3T,EAAOkR,GAAKO,IAAImC,GAChB5T,GACAuO,EAAMW,KAAKlP,GAGnB,OAAOuO,EAEXtB,MAAMyG,GAEF,OADAvZ,KAAKoU,MAAQmF,EAAIQ,MAAM,MAAMrN,KAAI+F,GAAKzS,KAAKsZ,WAAW7G,KAAI+F,OACnDxY,KAGXga,WACI,IAAIC,EAAoB,GACpB7F,EAAQpU,KAAKoU,MACjB,KAAOA,EAAM5V,OAAS,GAAG,CACrB,MAAM0b,EAAW9F,EAAMiF,QACvB,GAAwB,IAApBY,EAASzb,OACTyb,EAASlF,KAAKmF,OACX,CACH,MAAMrU,EAAOoU,EAASE,MAChBC,EAAWjG,GAAQkG,SAASxU,EAAMqU,GACxC,IAAK,IAAIvd,KAAKyd,EAAShG,MACnB6F,EAASlF,KAAKpY,IAG1B,OAAO,IAAIwX,GAAQ8F,GAGvB5Q,MACI,IAAI+K,EAAgBpU,KAAKoU,MAAMhO,MAAM,GAAGkU,UAAU5N,KAAI+F,GAAKA,EAAEpJ,QAAOmP,OACpE,OAAO,IAAIrE,GAAQC,GAGvBhO,MAAMpI,GACF,IAAIoW,EAAgBpU,KAAKoU,MAAMhO,MAAM,EAAGpI,GACxC,OAAO,IAAImW,GAAQC,GAGvB5V,SACI,OAAOwB,KAAKoU,MAAM5V,OAGtBqV,eAAeO,EAAoBmG,GAC/BA,EAAYA,GAAa,CAAExD,GAAKO,IAAQ,GAAGP,GAAKO,IAAO,EAAGP,GAAKO,IAAI,MAAOP,GAAKO,IAAQ,IACvF,IAAIkD,EAAW/I,EAAY8I,GACvBC,aAAoBrG,GACpBC,EAAMpF,OAAOwL,EAASpG,OAEtBA,EAAMW,KAAKyF,GAInBhM,SAASiM,GACL,OAAOza,KAAKoU,MAAM1H,KAAI/P,GAAKA,EAAE6R,aAAYmB,KAAK,KAAO,KAAO8K,EAAY,IAAMza,KAAKoU,MAAM5V,OAAS,IAAM,KA/InG2V,GAWF0E,WAAwC,CAC3C,GAAM,KACN,GAAM,KACN,GAAM,KACN,GAAM,KACN,GAAM,KAoId,IAAI6B,GAAc,WACd,IAAIC,EAAYA,CAACC,EAAgB/U,KAC7B,IAAIgV,EAAqB,IAAID,GAQzBE,EAAOA,CAACzc,EAAYrB,EAAW+d,KAC/B,IAAIzH,EARWyH,KACf,OAAQA,GACJ,KAAK3K,EAAG,OAAO,EACf,KAAKC,EAAG,OAAO,EACf,KAAKC,EAAG,OAAO,IAIT0K,CAAYD,IACjBE,EAAIC,GAAM7c,EACf,IAAK,IAAI9B,EAAI,EAAGA,EAAIqe,EAAKpc,OAAQjC,IAAK,CAClC,IAAK4e,EAAQC,EAAQC,GAAYT,EAAKre,GAClC8e,IAAaN,GAAOI,IAAWF,IAC/BJ,EAASte,GAAK,CAAC2e,GAAKE,EAASpe,GAAKsW,EAAKyH,MAInD,IAAK,IAAIxe,EAAI,EAAGA,EAAIsJ,EAAKgL,IAAIrS,OAAQjC,IACjCue,EAAKjV,EAAKgL,IAAItU,GAAIsJ,EAAKiL,IAAIvU,GAAI6T,GAEnC,IAAK,IAAI7T,EAAI,EAAGA,EAAIsJ,EAAKkL,IAAIvS,OAAQjC,IACjCue,EAAKjV,EAAKkL,IAAIxU,GAAIsJ,EAAKmL,IAAIzU,GAAI8T,GAEnC,IAAK,IAAI9T,EAAI,EAAGA,EAAIsJ,EAAKoL,IAAIzS,OAAQjC,IACjCue,EAAKjV,EAAKoL,IAAI1U,GAAI,EAAG+T,GAEzB,OAAOuK,GAEPS,EAAaA,CAACjd,EAAWkd,EAAYC,IACzCjL,EAAclS,IAAI,EAAIkd,EAAKC,GAAM,GAC7BC,EAAaA,CAACpd,EAAWkd,EAAYC,IACrChL,EAAYnS,IAAI,EAAIkd,EAAKC,GAAM,GAC/BE,EAAcrd,GAAc,CAACwR,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAAG7R,GAE/Csd,EAAmBA,CAACtH,EAAiBuH,KACrC,IAAKvd,EAAGrB,EAAG+d,GAAOa,EAClB,GAAIb,IAAQ3K,EACR,OAAOkL,EAAWjH,EAAKpU,GAAG5B,GAAIgW,EAAKnU,GAAG7B,GAAIrB,GACvC,GAAI+d,IAAQ1K,EACf,OAAOoL,EAAWpH,EAAKlU,GAAG9B,GAAIgW,EAAKjU,GAAG/B,GAAIrB,GACvC,GAAI+d,IAAQzK,EACf,OAAOoL,EAAWrH,EAAKtB,GAAG1U,IAE1B,MAAMqN,MAAM,qBAAuBqP,IA8BvC3G,EAAQ2C,GAAKO,KAUb,OAAEuE,EAAM,OAAEC,EAAM,OAAEC,EAAM,OAAEC,GAJnB,CACHH,OALSlB,EAAUtJ,EAAQ+C,EAAM,OAKzB0H,OAJCnB,EAAUtJ,EAAQ+C,EAAS,GAIpB2H,OAHPpB,EAAUtJ,EAAQ+C,EAAM,OAGT4H,OAFfrB,EAAUtJ,EAAQ+C,EAAU,KA4G7C,MAAO,CACH6H,WAtGaA,CAAC5H,EAAiBxS,KAE/B,IAAI0S,EAAQ,CAACnD,EAAQyK,EAAQxK,EAAQ2K,EAAQF,EAAQC,GACrD,OAAIla,EACO0S,EAAM7H,KAAKwP,GAvCMC,EAAC9H,EAAiB6H,EAAmBra,IAC1Dqa,EAAQxP,KAAI0P,IAAkB,IAAhB/d,EAAGrB,EAAG+d,GAAIqB,EAC3B,GAAIrB,IAAQ3K,EACR,OAA4B,IAAxBvO,EAAK5B,GAAGoU,EAAKpU,GAAG5B,IACTid,EAAWjH,EAAKpU,GAAG5B,GAAIgW,EAAKnU,GAAG7B,GAAIrB,GAEnC4S,EAAKyM,EACb,GAAItB,IAAQ1K,EACf,OAA4B,IAAxBxO,EAAK1B,GAAGkU,EAAKlU,GAAG9B,IACTod,EAAWpH,EAAKlU,GAAG9B,GAAIgW,EAAKjU,GAAG/B,GAAIrB,GAEnC4S,EAAKyM,EACb,GAAItB,IAAQzK,EACf,OAAIzO,EAAKkR,IAA8B,IAAxBlR,EAAKkR,GAAGsB,EAAKtB,GAAG1U,IACpBuR,EAAKyM,EAELX,EAAWrH,EAAKtB,GAAG1U,IAE9B,MAAMqN,MAAM,qBAAuBqP,MAqBToB,CAA0B9H,EAAM6H,EAASra,KAEhE0S,EAAM7H,KAAKwP,GA5CDI,EAACjI,EAAiB6H,IAChCA,EAAQxP,KAAIpO,GAAKqd,EAAiBtH,EAAM/V,KA2Cbge,CAAmBjI,EAAM6H,MAiG3DK,qBAzBwBC,IACxB,IAAIC,EAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC7BC,EAAwC,CACxC,EAAK7M,EAAG,EAAKC,EAAG,EAAKC,EAAG,EAAKC,EAAG,EAAKC,EAAG,EAAKC,GAG7CyM,EAAa,GACjB,IAAK,IAAIpgB,EAAI,EAAGA,EAAI+U,EAAU9S,OAAQjC,IAAK,CACvC,IAAIqgB,EAAYtL,EAAU/U,GAC1B,GAAImgB,EAAate,eAAewe,GAAY,CACxC,IAAIhC,EAAe8B,EAAaE,GAC5B3T,EAAQwT,EAAW7B,GAEvB+B,GARW,SAOCH,EAAY5B,GAAM3R,IAE9BwT,EAAW7B,IAAS,OAEpB+B,GAAcrL,EAAU/U,GAGhC,OAAOogB,GAOPhB,mBACAF,aACAoB,SAjGWA,CAACC,EAAqBvI,EAAoBwI,KAIrD,MAEMC,EAAyB,OAAVzI,EAAkB,CAAC3E,EAAKK,EAAGL,EAAKM,GAAK,CAACN,EAAKG,EAAGH,EAAKI,GAClEiN,EAAmB,CAACrN,EAAKC,KAAMmN,GACrC,OAAOF,EAAMpQ,KAAI,CAACwQ,EAAUre,IAJd,IAKNA,EACOqe,EAASxQ,KAAIpO,GAAK2e,EAAiBE,SAAS7e,GAAKA,EAAIsR,EAAKyM,IAEjExd,GAPM,EAQCqe,EAASxQ,KAAI,CAACpO,EAAG8e,KAClBL,EAAUC,EAAcC,GAAkBE,SAAS7e,IAAM8e,EAAO,EACjE9e,EACAsR,EAAKyM,IAEP,IAAIa,MAgFfG,QA5EWP,IAEXnH,QAAQ2H,IAAIR,GACZ,IAAI,EAAC/M,EAAC,EAACC,EAAC,EAACC,EAAC,EAACC,EAAC,EAACL,GAAKD,EAClB,MAAM2N,EAAa,CAEf,CAAC,CAAC1N,EAAG,GAAI,CAACA,EAAG,GAAI,CAACA,EAAG,GAAI,CAACA,EAAG,IAE7B,CAAC,CAACA,EAAG,GAAI,CAACA,EAAG,GAAI,CAACI,EAAG,GAAI,CAACC,EAAG,IAC7B,CAAC,CAACL,EAAG,GAAI,CAACA,EAAG,GAAI,CAACG,EAAG,GAAI,CAACD,EAAG,IAC7B,CAAC,CAACF,EAAG,GAAI,CAACA,EAAG,GAAI,CAACI,EAAG,GAAI,CAACC,EAAG,IAC7B,CAAC,CAACL,EAAG,GAAI,CAACA,EAAG,GAAI,CAACG,EAAG,GAAI,CAACD,EAAG,IAE7B,CAAC,CAACF,EAAG,GAAI,CAACA,EAAG,GAAI,CAACE,EAAG,GAAI,CAACC,EAAG,IAC7B,CAAC,CAACH,EAAG,GAAI,CAACA,EAAG,GAAI,CAACI,EAAG,GAAI,CAACC,EAAG,IAE7B,CAAC,CAACH,EAAG,GAAI,CAACA,EAAG,GAAI,CAACG,EAAG,GAAI,CAACA,EAAG,KAEjC,IAAInH,GAAQ,EACZ,IAAK,IAAI2D,KAAO6Q,EAAY,CACxB,IAAIC,EAAc,EAClB,IAAK,IAAKtM,EAAG3U,KAAMmQ,EACf8Q,GAAgBV,EAAM5L,GAAG3U,KAAOqT,EAAKC,EAAK,EAAI,EAElD,GAAI2N,IAAgB9Q,EAAIlO,OAAQ,CAE5B,IAAK,IAAI0S,IAAK,CAACtB,EAAKK,EAAGL,EAAKM,EAAGN,EAAKG,EAAGH,EAAKI,EAAGJ,EAAKC,GAChD,IAAK,IAAItT,EAAI,EAAGA,GAAM2U,IAAMtB,EAAKC,EAAK,EAAI,GAAItT,IAC1C,GAAIugB,EAAM5L,GAAG3U,KAAOqT,EAAKC,EAAG,CACTnR,MAAM,GAAG6Q,KAAK,GAAG7C,KAAI,CAACoH,EAAGrU,IAAOiN,EAAIjN,GAAG,KAAOyR,GAAKxE,EAAIjN,GAAG,KAAOlD,IAAI4gB,UAAS,KAEzFL,EAAM5L,GAAG3U,GAAKqT,EAAKyM,GAKnCtT,GAAQ,EACR,OAOR,OAHKA,GACD0U,MAAM,yBAEHX,GAiCPvI,MAAO,CACHnD,SAAQyK,SAAQC,SAAQC,SAAQ1K,SAAQ2K,WArMlC,GA4NlB,MAAM0B,GAAiB,CACnBzd,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1BE,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAgG3B,MAwBX,SAASwd,EAAIT,EAAsBhM,GAC/B,OAAOgM,EAASxQ,KAAI+F,IAChB,IAAK7O,EAAGC,EAAGjH,GAAK6V,EAChB,MAAO,CAAC7O,EAAEC,EAAEjH,EAAEsU,MAItB,IAAI,OAAEE,EAAM,OAAEyK,EAAM,OAAEC,EAAM,OAAEC,EAAM,OAAE1K,EAAM,OAAE2K,GAAWtB,GAAYnG,MACjE2I,EAAW,IAAKS,EAAIvM,EAAQvB,MAAO8N,EAAI9B,EAAQ/L,MAC5C6N,EAAI7B,EAAQ7L,MAAO0N,EAAI5B,EAAQ7L,MAAOyN,EAAItM,EAAOtB,MAAQ4N,EAAI3B,EAAQhM,IAExE4N,EAAa,WAEb,IAAIC,EAAgBX,EAASY,QAAOxf,GAAKA,EAAE,KAAO6R,EAAIE,IAClD0N,EAAkBb,EAASY,QAAOxf,GAAKA,EAAE,KAAO6R,EAAIC,IAEpD4N,EAAgCtf,MAAM,IAAI6Q,KAAK,GAAG7C,KAAIoH,GAAKpV,MAAM,KACrEmf,EAAcnR,KAAIpO,GAAK0f,EAAY1f,EAAE,IAAIyW,KAAKzW,KAE9C,IAAI2f,EAAgCvf,MAAM,GAAG6Q,KAAK,GAAG7C,KAAIoH,GAAKpV,MAAM,KACpEqf,EAAgBrR,KAAIpO,GAAK2f,EAAY3f,EAAE,IAAIyW,KAAKzW,KAEhD,MAAM4f,EAAkC,GACxC,IAAK,IAAI/M,EAAI,EAAGA,EAAI,GAAIA,IACpB,IAAK,IAAIvU,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAIuhB,EAAMH,EAAY7M,GAClBiN,EAAMH,EAAYrhB,GAElByhB,EAAQ,EACZF,EAAIzF,SAAUvH,IACViN,EAAI1F,SAAU9b,IAAYuU,EAAE,KAAOvU,EAAE,IAAIyhB,UAE/B,IAAVA,GACAH,EAAWnJ,KAAM,CAAC5D,EAAGvU,IAMjC,IAAI0hB,EAAYA,CAACjK,EAAiB/V,IACvBoc,GAAYiB,iBAAiBtH,EAAM,CAAC/V,EAAE,GAAIA,EAAE,GAAIA,EAAE,KAoB7D,OAlBY+V,IAER,IAAIkK,EAAsC,GAE1C,IAAK,IAAKpe,EAAIF,KAAOie,EAAY,CAC7B,IAAIC,EAAMH,EAAY7d,GAClBie,EAAMH,EAAYhe,GAClBsS,EAAM,EACV4L,EAAIzF,SAAUvH,IACV,MAAMvU,EAAIwhB,EAAIN,QAASlhB,GAAMuU,EAAE,KAAOvU,EAAE,KAAI,GACxC0hB,EAAUjK,EAAMlD,KAAOmN,EAAUjK,EAAMzX,IAAI2V,OAEvC,IAARA,GACAgM,EAAgBxJ,KAAK,CAAC5U,EAAIF,IAGlC,OAAOse,GA/CE,GA4EjB,MAAMC,EAAY,CAAC,GAAIzH,GAAKO,IAAO,EAAGP,GAAKO,IAAI,MAAOP,GAAKO,IAAQ,IAC7DmH,EAAa,CAAC,GAAI1H,GAAKO,IAAQ,IAMrC,MAAMoH,EAAO,CAAC,GAAI,IAAK,KAAM,KAAM,KAAM,MAAO,OAAQ,OACpD,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,OAAQ,OAC9C,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,OAAQ,QAClD,IAUIC,EAAuBC,IAA0C,IAAzC,GAAE1e,EAAE,GAAEE,EAAE,GAAEH,EAAE,GAAEE,GAAUye,EAChD1e,EAAKA,GAAMD,EACXG,EAAKA,GAAMD,EAEX,IAkCI0e,EAASC,EAASC,EAlClBC,EAAaA,CAACC,EAAoBlE,KAClC,IAEImE,EAFAhc,EAAMxE,MAAMugB,EAASzgB,QAAQ+Q,KAAK,GAClC+D,EAAOyH,IAAQ3K,EAAK,EAAI,EAE5B,EAAG,CACC8O,EAAM,EACN,IAAK,IAAI3iB,KAAK0iB,EACU,IAAhBA,EAAS1iB,KACT2G,EAAI3G,GAAKgV,EAAS+B,GAClB4L,GAAOhc,EAAI3G,UAGd2iB,EAAM5L,EAAM,GACrB,OAAOpQ,GAEPic,EAAeC,IACf,IAAIhN,EAAiB1T,MAAM0gB,EAAU5gB,QAAQ+Q,KAAK,GAC9C8P,EAAsB,GAC1B,IAAK,IAAI9iB,EAAI,EAAGA,EAAI6iB,EAAU5gB,OAAQjC,IACb,IAAjB6iB,EAAU7iB,GACV8iB,EAAUtK,KAAKxY,GAEf6V,EAAK7V,GAAKA,GD5/BX,SAAYkC,GAC3B,IAAK,IAAIlC,EAAI,EAAGC,EAAIiC,EAAID,OAAQjC,EAAIC,EAAI,EAAGD,IAAK,CAC5C,IAAIkD,EAAI+R,EAAUjV,EAAGC,EAAI,GACrB8iB,EAAM7gB,EAAIlC,GACdkC,EAAIlC,GAAKkC,EAAIgB,GACbhB,EAAIgB,GAAK6f,GC0/BLC,CAAaF,GACb,IAAK,IAAI9iB,EAAI,EAAGgW,EAAM,EAAGhW,EAAI6iB,EAAU5gB,OAAQjC,IACtB,IAAjB6iB,EAAU7iB,KACV6V,EAAK7V,GAAK8iB,EAAU9M,GACpBA,GAAO,GAGf,OAAOH,GAGX,IACKyM,EAASC,GAAW,CAACK,EAAYlf,GAAKkf,EAAYhf,IACnD4e,EAAO5M,EAAU0M,GAAW1M,EAAU2M,GAAY,QAC7CC,EAAM,GAEf,OAAO,IAAIhf,GAAU,CACjBG,GAAI8e,EAAW9e,EAAIkQ,GACnBnQ,GAAI4e,EACJze,GAAI4e,EAAW5e,EAAIiQ,GACnBlQ,GAAI2e,MAnLD,GAyNR,MAAMU,WAfN,MAAuBzR,cAAA,KACjBjR,UAAI,EAIb2iB,OACIC,OAAOC,aAAaC,QAAQ5f,KAAKlD,KAAMkD,KAAK2K,aAEhDkV,OACI,MAAMC,EAAOJ,OAAOC,aAAaI,QAAQ/f,KAAKlD,MAC1CgjB,EAAM9f,KAAKiL,YAAY6U,GACtB9f,KAAKggB,gBAoDdjS,YAAYkS,GACRC,QAAQ,KApCZpjB,KAAO,cAAc,KACrBqjB,OAAgC,GAoCvBF,GACDjgB,KAAK6f,OAGbO,cACI,MAAO,UAAUrG,MAAM,IAAIrN,KAAI+F,GAAKzS,KAAKmgB,OAAO1N,KAEpDhE,IAAK0R,GACD,IAAIE,EAAY,IAAIb,IAAY,GAOhC,OANI9gB,MAAMwV,QAAQiM,GACdA,EAAOzH,SAAS,CAAC4H,EAAO/jB,IAAM8jB,EAAUF,OAAO,UAAU5jB,IAAM+jB,IAE/DD,EAAUF,OAAS,IAAIngB,KAAKmgB,UAAWA,GAE3CE,EAAUZ,OACHY,EAEXE,iBACI,IAAIF,EAAY,IAAIb,IAAY,GAGhC,OAFAa,EAAUL,cACVK,EAAUZ,OACHY,EAEXL,cAAgBhgB,KAAKmgB,OAASX,GAAYgB,eAC1C7V,YACI,OAAOkI,KAAKG,UAAUhT,KAAKmgB,QAE/BlV,YAAY3M,GACR0B,KAAKmgB,OAAStN,KAAKC,MAAMxU,GAE7BmiB,gBAAgBniB,GACZ,IAAIiW,GAASiL,GAAYkB,kBAAkBtjB,IAAIkB,IAAMkhB,GAAYkB,kBAAkBtjB,IAAI,OAAS,IAC5FqB,EAAiB,GACrB,IAAK,IAAIlC,EAAI,EAAGA,EAAIgY,EAAM/V,OAAQjC,IAC9BkC,EAAIsW,KAAK/U,KAAKmgB,OAAO5L,EAAMhY,KAE/B,OAAOkC,GAtFF+gB,GAIFgB,eAAiB,CACpB,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,WAXAhB,GAiBFmB,cAAgB,CACnB,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SAEA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SAEA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,UA3CKnB,GA6CFkB,kBACI,IAAInV,IAAIiU,GAAYmB,cAAcjU,KAAI+F,GAAK,CAAEA,EAAE,GAAKA,EAAE,GAAIA,MC1mCxE,IAsBImO,QA1BoC5U,IAApC6U,WAAmBC,eAEnBD,WAAmBC,aAAe,OAClCD,WAAmBE,aAAe,IAAM,QAuB7B,SAAXH,OAAW,SAAXA,IAAW,SAAXA,IAAW,SAAXA,IAAW,UAAXA,QAAW,KAGhB,MAAQI,EAAC,GAAEC,EAAE,IAAIL,GAYjB,IAAIM,GAAU,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,KACxD,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,MAC9DC,GAAQ,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KACrC,IAAK,KAAM,KAAM,KAAM,IAAK,MAC5BC,GAAgB,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,KAAM,IAAK,KAClE,IAAK,KAAM,MACPC,GAAU,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KACvC,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,MAC7CC,GAAU,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KACvC,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,MAC7CC,GAAa,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,KAC3D,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,MAC9DC,GAAc,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,KAC5D,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,KAC7C,IAAK,KAAM,KAAM,KAAM,IAAK,MAE5BC,GAAM,CAAC,IAAK,KAAM,KAAM,IAAK,KAAM,KAAM,IAAK,KAAM,MA8DxD,IA4FIC,GAAuBC,IAgChB,CACHC,KAhCUza,KAAK0a,IAAI,GAAI,GACb1a,KAAK0a,IAAI,GAAI,GAgCvBC,OA7BJ,SAAgBzN,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACF,IAAf8X,EAAKpU,GAAG1D,GACVwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GACG,IAAf8X,EAAKpU,GAAG1D,KACjBylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,IAGzB,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EAAGic,EAAK,EAAGC,EAAK,EACjC,IAAK,IAAI5lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI4lB,EAAS,EAAJ5lB,EAAQ8X,EAAKjU,GAAG7D,GAItC,OAAO0lB,EAAQ,KADC,MAAFjc,EAAwB,IAAFC,EAAsB,GAALic,EAAUC,IAW7DC,cAPU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAOtE8b,YACAU,QAPYnB,GAQZpkB,KAAM,SAIVwlB,GAAmBZ,GAAoB,GAqJvCa,GAzIyBZ,KACzB,MAAMa,EAAQrb,KAAK0a,IAAI,GAAI,GACrBY,EAAQtb,KAAK0a,IAAI,GAAI,GAmC3B,MAAO,CACHD,KAlCSY,EAAQC,EADP,EAoCVX,OAjCJ,SAAgBzN,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAI1J,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAGtC,MAAMmmB,EAAc,GAAN1c,EAAYC,EAC1B,IAAI0c,EAAK,EACT,IAAK,IAAIpmB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKtB,GAAGxW,KAAOqT,EAAKK,IACrB0S,EAAKpmB,GAIX,OAAOmmB,GA3BK,EA2BID,GA3BJ,EA2BqBR,EADnBU,GAWZP,cAPU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAOtE8b,YACAU,QANYb,GAQZ1kB,KAAM,OA6FW8lB,CAAsB,GAC3CC,GA1FyBlB,KACzB,MAAMa,EAAQrb,KAAK0a,IAAI,GAAI,GACrBY,EAAQtb,KAAK0a,IAAI,GAAI,GAmC3B,MAAO,CACHD,KAlCSY,EAAQC,EADP,EAoCVX,OAjCJ,SAAgBzN,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAI1J,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAGtC,MAAMmmB,EAAc,GAAN1c,EAAYC,EAC1B,IAAI0c,EAAK,EACT,IAAK,IAAIpmB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKtB,GAAGxW,KAAOqT,EAAKK,IACrB0S,EAAKpmB,GAIX,OAAOmmB,GA3BK,EA2BID,GA3BJ,EA2BqBR,EADnBU,GAWZP,cAPU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAOtE8b,YACAU,QANYd,GAQZzkB,KAAM,OA8CWgmB,CAAsB,GAC3CC,IA3CqBpB,GA2Cc,EAb5B,CACHC,KA9BUza,KAAK0a,IAAI,GAAI,GACb1a,KAAK0a,IAAI,GAAI,GA8BvBC,OA3BJ,SAAgBzN,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAItC,OAAY,KADI,IAAFyJ,EAAuB,GAANC,EAAYic,GAChBD,GAUzBG,cAPU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAOtE8b,aACAU,QANYnB,GAQZpkB,KAAM,OArCW6kB,OA4CzB,IA8DIqB,GA8BO,CACHpB,KA9BUza,KAAK0a,IAAI,GAAI,GACb1a,KAAK0a,IAAI,GAAI,GA8BvBC,OA3BJ,SAAgBzN,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAKyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MACnC,KAAK,GAAK0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MACnC,KAAK,GAAK2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAIvC,OAAY,KADI,IAAFyJ,EAAuB,GAANC,EAAYic,GAChBD,GAUzBG,cAPU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAOtE8b,UAAW,EACXU,QANYlB,GAQZrkB,KAAM,WAyBVmmB,GAAwBA,CAACC,EAAmBvB,KA8BrC,CACHC,KA9BUza,KAAK0a,IAAI,GAAI,GACb1a,KAAK0a,IAAI,GAAI,GA8BvBC,OA5BJ,SAAgBzN,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,GAAK0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MACnC,KAAK,GAAK2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAIvC,OAAY,KADI,IAAFyJ,EAAuB,GAANC,EAAYic,GAChBD,GAWzBG,cARU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAQtE8b,YACAU,QAPaa,EAAW7B,GAAUC,GAQlCxkB,KAAM,WAAaomB,EAAW,YAAc,cAIhDC,GAA0BA,CAACD,EAAmBvB,KAkDvC,CACHC,KAlDUza,KAAK0a,IAAI,GAAI,GACb1a,KAAK0a,IAAI,GAAI,GAkDvBC,OAAQoB,EAhDZ,SAAkB7O,GAChB,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,GAAK2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAIvC,OAAY,KADI,IAAFyJ,EAAuB,GAANC,EAAYic,GAChBD,GAE7B,SAAkB5N,GACd,IAAI0N,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIzlB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAGwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MACjC,KAAK,EAAGylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAGnC,MAAM0lB,EAAa,GAALF,EAAUC,EACxB,IAAIhc,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,GAAK2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAIvC,OAAY,KADI,IAAFyJ,EAAuB,GAANC,EAAYic,GAChBD,GAW3BG,cARU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAQtE8b,YACAU,QAPaa,EAAW7B,GAAUC,GAQlCxkB,KAAM,YAAcomB,EAAW,YAAc,cAqPjDE,GA7F0BC,CAACC,EAAmB3B,KAE9CA,EAAYA,GAAa,EACzB,MAAMa,EAAQrb,KAAK0a,IAAI,GAAI,GACrBY,EAAQtb,KAAK0a,IAAI,GAAI,GACrBD,EAAOY,EAAQC,EA8CrB,MACML,EADQ,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAKpEwc,EAAUnB,GAEhB,MAAO,CACHQ,GAAoBC,GACpB,CACIC,OACAE,OAASwB,EAxDjB,SAAsBjP,GACpB,IAAI0N,EAAK,EAAGC,EAAK,EAAGuB,EAAK,EACzB,IAAK,IAAIhnB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAIwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MAClC,KAAK,EAAIylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MAClC,KAAK,EAAIgnB,EAAS,EAAJhnB,EAAQ8X,EAAKnU,GAAG3D,GAGpC,MAAM0lB,EAAU,IAAFF,EAAsB,GAALC,EAAUuB,EACzC,IAAIvd,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,GAAK2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAIvC,OAAO0lB,EAAQQ,GADC,IAAFzc,EAAsB,GAALC,EAAUic,IAI3C,SAAqB7N,GACjB,IAAI0N,EAAK,EAAGC,EAAK,EAAGuB,EAAK,EACzB,IAAK,IAAIhnB,EAAI,EAAGA,EAAI,EAAGA,IACrB,OAAQ8X,EAAKpU,GAAG1D,IACZ,KAAK,EAAIwlB,EAAS,EAAJxlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MAClC,KAAK,EAAIylB,EAAS,EAAJzlB,EAAQ8X,EAAKnU,GAAG3D,GAAI,MAClC,KAAK,EAAIgnB,EAAS,EAAJhnB,EAAQ8X,EAAKnU,GAAG3D,GAGpC,MAAM0lB,EAAU,IAAFF,EAAsB,GAALC,EAAUuB,EACzC,IAAIvd,EAAK,EAAGC,EAAK,EAAGic,EAAK,EACzB,IAAK,IAAI3lB,EAAI,EAAGA,EAAI,GAAIA,IACpB,OAAQ8X,EAAKlU,GAAG5D,IACZ,KAAK,EAAIyJ,EAAS,EAAJzJ,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,EAAI0J,EAAS,EAAJ1J,EAAQ8X,EAAKjU,GAAG7D,GAAI,MAClC,KAAK,GAAK2lB,EAAS,EAAJ3lB,EAAQ8X,EAAKjU,GAAG7D,GAIvC,OAAO0lB,EAAQQ,GADC,IAAFzc,EAAsB,GAALC,EAAUic,IAiBrCE,gBACAT,YACAU,UACAvlB,KAAM,WAAawmB,EAAW,QAAU,WA4BhDE,GAAiC,WACjC,MAAM5B,EAAyB,EAAlBza,KAAK0a,IAAI,GAAI,GAAS,EAAI,EACjC4B,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAsB5D,MAAO,CACH7B,OACAE,OAvBJ,SAAgBzN,GACd,IAAIqP,EAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1B,IAAK,IAAInnB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAC3B,IAAIsC,EAAM4kB,EAAYpP,EAAKlU,GAAG5D,IAC1BsC,EAAM,IACN6kB,EAAI7kB,GAAwB,EAAjB4kB,EAAYlnB,GAAS8X,EAAKjU,GAAG7D,IAG9C,IAAIonB,EAAW,EACf,IAAK,IAAIpnB,EAAI,EAAGA,EAAI,EAAGA,IACrBonB,EAAsB,GAAXA,EAAgBD,EAAInnB,GAEjC,OAAkB,EAAXonB,EAAe,EAAiB,EAAbtP,EAAKtB,GAAG,GAASsB,EAAKpU,GAAG,IAYjDmiB,cATU,CAACrL,GAAKO,IAAQ,IACA5K,KAAK/P,IAAK,IAAIoD,IAAYkN,MAAMtQ,KASxDglB,UAPc,EAQdU,QAPY,CAAC,IAAK,KAAM,KAAM,KAAM,IAAK,MAQzCvlB,KAAM,OA9BuB,GAoFrC,IAAI8mB,GAAmC,WACnC,MAAMhC,EAAO,GAAQza,KAAK0a,IAAI,EAAG,GAAK,EAEhC4B,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GACtDI,EAAW,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAoBzD,MAAO,CACHjC,OACAE,OArBJ,SAAgBzN,GACd,IAAIjU,EAAK,EAAGD,EAAK,EACjB,IAAK,IAAI5D,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAC3B,IAAIsC,EAAM4kB,EAAYpP,EAAKlU,GAAG5D,IAC1BsC,GAAO,IACPuB,EAAU,EAALA,EAASiU,EAAKjU,GAAG7D,IAEtBsC,EAAM,IACNsB,GAAMgH,KAAK0a,IAAI,EAAGhjB,EAAM,GAAKglB,EAAStnB,IAI5C,OAAwB,GAAX,GAAL6D,EAAUD,GAAUkU,EAAKtB,GAAG,IAUlCqP,cAPkB,CAAC,IAAIriB,IAQvB4hB,UAPc,GAQdU,QAPY,CAAC,IAAK,KAAM,KAAM,KAAM,IAAK,MAQzCvlB,KAAM,QA9ByB,GAkCnCgnB,GAQO,CACHlC,KARS,GASTE,OALJ,SAAgBzN,GACZ,OAAoB,EAAbA,EAAKtB,GAAG,GAASsB,EAAKtB,GAAG,IAKhCqP,cATkB,CAAC,IAAIriB,IAUvB4hB,UATc,EAUdU,QATYZ,GAUZ3kB,KAAM,U,YCl9Bd,SAASinB,GAAOC,GACZ,MAAMC,EAAkB,IACxB,IAEIC,EACAvC,EACAwC,EAECC,GAND,QAAE/B,EAAO,UAAEgC,EAAS,QAAEC,GAAYN,EAClCO,EAAc,EAAGC,EAAc,EAUnC,SAASC,EAAYpQ,EAAiBqQ,EAAoBC,EAAoBC,GAO1E,OANAV,EAAQU,EACRjD,EAAYgD,EACZR,EAAYO,EACZH,EAAc,EACdC,EAAc,EACd7K,EAAOtF,EAAM,EAAG,IACT6P,GAZA,SAANE,OAAM,uBAANA,IAAM,gBAANA,MAAM,KAeX,IAAIS,EAAwC5nB,OAAOY,OAAO,IA6F1D,SAAS8b,EAAOtF,EAAiBlM,EAAepB,GAE5C,GADAwd,IACIA,EAAcN,EACd,OAAOG,EAAOU,KAElB,GAAIT,EAAUhQ,GACV,OA5BR,SAAkBtN,EAAkBoB,GAChC,GAAIA,EAAQgc,EAAW,OAAOC,EAAOW,SACrC,GAAIb,EAAMc,UAAUxmB,OAAS0lB,EAAMe,SAAU,CACzC,IAAIC,GAAO,EACX,IAAK,IAAIte,KAAOsd,EAAMc,UAClB,GAAItS,GAAW9L,EAAIwN,MAAOrN,GAAW,CACjCme,GAAO,EACP,MAGJA,GACAhB,EAAMc,UAAUjQ,KAAK,IAAIZ,GAAQ,IAAIpN,KAI7C,OAAImd,EAAMc,UAAUxmB,SAAW0lB,EAAMe,SAC1Bb,EAAOU,KAEPV,EAAOW,SAUPI,CAASpe,EAAUoB,GAE1B,GAAIA,GAASwZ,EAAW,OAAOyC,EAAOW,SAEtC,OADQ5d,KAAKM,OAAO6c,EAAQ5X,KAAIrO,GAAKA,EAAE+mB,MAAM/Q,MACrClM,EAAQwZ,GACZ6C,IACOJ,EAAOW,UAjE1B,SAAgB1Q,EAAiBlM,EAAepB,GAC5C,MAAMse,EAA0Bte,EAASvI,OAAS,EAAIqmB,EAAU9d,EAASA,EAASvI,OAAS,GAAG1B,MAAQulB,EACtG,IAAIiD,EAA6C,KAEjD,GADYtB,EAAOuB,mBAGf,GADAD,EAAiB,IAAIlM,IACE,IAAnBkL,EAAQ9lB,OACR8mB,EAAeE,IAAIlB,EAAQ,GAAGxC,OAAOzN,QACnC,CACF,IAAIrW,EAAIynB,OAAOnB,EAAQ,GAAGxC,OAAOzN,IAASoR,OAAOnB,EAAQ,GAAG1C,MAAQ6D,OAAOnB,EAAQ,GAAGxC,OAAOzN,IAC7FiR,EAAeE,IAAIxnB,GAG3B,IAAK,IAAI6H,KAAQwf,EAAgB,CAC7B,IAAIK,EAAWrR,EAAKT,UAAU/N,GAC1B6d,EAA0B,IAAnBY,EAAQ9lB,OAAgB8lB,EAAQ,GAAGxC,OAAO4D,GACjDD,OAAOnB,EAAQ,GAAGxC,OAAO4D,IAAaD,OAAOnB,EAAQ,GAAG1C,MAAQ6D,OAAOnB,EAAQ,GAAGxC,OAAO4D,IAE7F,GAAsB,MAAlBJ,IAA2BA,EAAe7P,IAAIiO,GAAM,CAAC,IAADiC,EACtC,QAAdA,EAAAL,SAAc,IAAAK,GAAdA,EAAgBH,IAAI9B,GACpB3c,EAASgO,KAAKlP,GACd,IAAI+f,EAAcjM,EAAO+L,EAAUvd,EAAQ,EAAGpB,GAE9C,GADAA,EAASoT,MACLyL,IAAOxB,EAAOU,KACd,OAAOV,EAAOU,MAI1B,OAAOV,EAAOW,SAuCCc,CAAOxR,EAAMlM,EAAOpB,GAuBvC,OAjIA,WACI,SAAS+e,EAAiBhpB,GACtB,OAAQA,EAAK,IACT,IAAK,IAAK,OAAOulB,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KACjE,IAAK,IAAK,OAAOulB,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,KAC5C,IAAK,IAAK,OAAOulB,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KACjE,IAAK,IAAK,CACN,IAAIipB,EAAO1D,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KAE3D,MAAa,MAATA,EAAqBipB,EAAKjI,QAAOtd,GAAgB,OAAXA,EAAE1D,OAC/B,OAATA,EAAsBipB,EAAKjI,QAAOtd,GAAgB,MAAXA,EAAE1D,OAChC,OAATA,EAAsBipB,EAAKjI,QAAOtd,GAAgB,OAAXA,EAAE1D,OACtCipB,EAEX,IAAK,IACL,IAAK,IACL,IAAK,IAAK,OAAO1D,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KAE3G,IAAK,IAAK,OAAOulB,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KACtF,IAAK,IAAK,CACN,MAAMipB,EAAO1D,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KAC7D,MAAa,OAATA,EAAsBipB,EAAKjI,QAAOtd,GAAgB,MAAXA,EAAE1D,OAC3B,MAATA,EAAqBipB,EAAKjI,QAAOtd,GAAgB,OAAXA,EAAE1D,OAC/B,OAATA,EAAsBipB,EAAKjI,QAAOtd,GAAgB,OAAXA,EAAE1D,OACtCipB,EAEhB,IAAK,IAAK,OAAO1D,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KAC3G,IAAK,IAAK,OAAOulB,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KAEjE,IAAK,IAAK,OAAOulB,EAAQvE,QAAOtd,GAAmB,MAAdA,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,IAA4B,MAAd0D,EAAE1D,KAAK,KACtF,QAAS,OAAOulB,GAGxB,IAAK,IAAIxc,KAAQwc,EACbwC,EAAUhf,EAAK/I,MAAQgpB,EAAiBjgB,EAAK/I,MAGrDkpB,GA4FO,CAAEjc,MAlBT,SAAesK,EAAiB4R,EAAiBC,EAAiBjB,GAC9D,IAAIf,EAAsB,CACtBc,UAAW,GACXC,YAEJ,IAAK,IAAI1oB,EAAI0pB,EAAS1pB,GAAK2pB,IACvBhC,EAAQO,EAAYpQ,EAAM4R,EAAS1pB,EAAG2nB,KAClCA,EAAMc,UAAUxmB,SAAW0lB,EAAMe,UAAYV,GAAeN,IAFhC1nB,KAOpC,OAAO2nB,EAAMc,WAMDX,YAAW8B,WAH3B,WACI,OAAO7B,IAKf,SAAS8B,GAAcC,GACnB,IAAIC,EAASC,GAAanpB,IAAIipB,GAC9BC,EAAOljB,OAYP,OADa2gB,GAPA,CACTM,UAHahQ,GAA2C,IAAvBiS,EAAOlB,MAAM/Q,GAI9CgO,QAASgE,EAAahE,QAAQ3V,KAAIpO,GAAKyY,GAAKO,IAAIhZ,KAChDgmB,QAAS,CAACgC,GACVf,oBAAoB,IAOrB,SAASiB,GAAeC,GAC3B,IAAInC,EAAUmC,EAAc/Z,KAAI2G,GACrBkT,GAAanpB,IAAIiW,KAE5BiR,EAAQ5L,SAAQra,GAAKA,EAAE+E,SAWvB,OADa2gB,GANe,CACxBM,UAHahQ,GAAoBiQ,EAAQoC,OAAMroB,GAAuB,IAAlBA,EAAE+mB,MAAM/Q,KAI5DgO,QAASoE,EAAc,GAAGpE,QAAQ3V,KAAIpO,GAAKyY,GAAKO,IAAIhZ,KACpDgmB,UACAiB,oBAAoB,IAO5B,IAQIoB,GAAYrD,GAAsB8C,GDmLhB9C,KAClB,MAAM1B,EAAOza,KAAK0a,IAAI,GAAI,GACpBE,EAAKuB,EAAW,EAAI,EACpBtd,EAAKsd,EAAW,GAAK,GAmB3B,MAAO,CACH1B,OACAE,OAnBJ,SAAgBzN,GACd,IAAI1Q,EAAI,CAAC,EAAG,EAAG,GACf,IAAK,IAAIpH,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKpU,GAAG1D,KAAOwlB,IAAIpe,EAAE,GAAS,EAAJpH,EAAQ8X,EAAKnU,GAAG3D,IAEjD,IAAK,IAAIA,EAAI,EAAGA,EAAI,GAAIA,IAChB8X,EAAKlU,GAAG5D,KAAOyJ,EAAIrC,EAAE,GAAS,EAAJpH,EAAQ8X,EAAKjU,GAAG7D,GAPzC,IAQI8X,EAAKlU,GAAG5D,KAAWoH,EAAE,GAAS,EAAJpH,EAAQ8X,EAAKjU,GAAG7D,IAEvD,OAAOoH,EAAE,GAAY,GAAPA,EAAE,GAAiB,GAAPA,EAAE,GAAU,IAWpCye,cARU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAQtE8b,UAPc,EAQdU,QAPYlB,GAQZrkB,KAAM,MAAQwmB,EAAW,SAAW,WC/MQsD,CAAetD,IAE/DuD,GAAcvD,GAAsB8C,GDiNhB9C,KACpB,MAAM1B,EAAOza,KAAK0a,IAAI,GAAI,GACpBE,EAAKuB,EAAW,EAAI,EAkB1B,MAAO,CACH1B,OACAE,OAlBJ,SAAgBzN,GACd,IAAIyS,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIxqB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKpU,GAAG1D,KAAOwlB,IAAI+E,EAAS,EAAJvqB,EAAQ8X,EAAKnU,GAAG3D,IAE/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,GAAIA,IANf,IAOD8X,EAAKlU,GAAG5D,KAAWwqB,EAAS,EAAJxqB,EAAQ8X,EAAKjU,GAAG7D,IAEhD,OAAOuqB,EAAU,GAALC,GAWV3E,cARU,CAAC,GAAI,IAAK,KAAM,MACF1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAQtE8b,UAPc,EAQdU,QAPYjB,GAQZtkB,KAAM,QAAUwmB,EAAW,SAAW,WC3OQ0D,CAAiB1D,IAGnE2D,GAAe3D,GAAsBkD,GAAepD,GAAkBE,IAEtE4D,GAAc5D,IAAsBkD,UD4YO,CAC3CvD,GADqBC,EC5YgDI,ED6YrC,GAChCH,GAAwBD,EAAU,KAFbA,OCzYrBiE,GAAY7D,GAAsB8C,GD8YhB9C,KAClB,MAAM1B,EAAOza,KAAK0a,IAAI,GAAI,GACpBE,EAAKuB,EAAW,EAAI,EACpBtd,EAAKsd,EAAW,EAAI,EAoB1B,MAAO,CACH1B,OACAE,OApBJ,SAAgBzN,GACd,IAAIyS,EAAK,EAAGC,EAAK,EAAGK,EAAK,EACzB,IAAK,IAAI7qB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKpU,GAAG1D,KAAOwlB,IAAI+E,EAAS,EAAJvqB,EAAQ8X,EAAKnU,GAAG3D,IAE/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,GAAIA,IAChB8X,EAAKlU,GAAG5D,KAAOyJ,EAAI+gB,EAAS,EAAJxqB,EAAQ8X,EAAKjU,GAAG7D,GAPvC,IAQI8X,EAAKlU,GAAG5D,KAAW6qB,EAAS,EAAJ7qB,EAAQ8X,EAAKjU,GAAG7D,IAErD,OAAOuqB,EAAU,GAALC,EAAe,GAALK,EAAU,IAY9BhF,cATU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAStE8b,UAPc,EAQdU,QAPYnB,GAQZpkB,KAAM,MAAQwmB,EAAW,SAAW,WC3aQ+D,CAAe/D,IAC/DgE,GAAkBhE,GAAsB8C,GD8ahB9C,KACxB,MAAM1B,EAAOza,KAAK0a,IAAI,GAAI,GACpBE,EAAKuB,EAAW,EAAI,EACpBtd,EAAKsd,EAAW,EAAI,EAmB1B,MAAO,CACH1B,OACAE,OAnBJ,SAAgBzN,GACZ,IAAIyS,EAAK,EAAGC,EAAK,EAAGK,EAAK,EACzB,IAAK,IAAI7qB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKpU,GAAG1D,KAAOwlB,IAAI+E,EAAS,EAAJvqB,EAAQ8X,EAAKnU,GAAG3D,IAE/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,GAAIA,IAChB8X,EAAKlU,GAAG5D,KAAOyJ,EAAI+gB,EAAS,EAAJxqB,EAAQ8X,EAAKjU,GAAG7D,GAPzC,IAQM8X,EAAKlU,GAAG5D,KAAW6qB,EAAS,EAAJ7qB,EAAQ8X,EAAKjU,GAAG7D,IAErD,OAAOuqB,EAAU,GAALC,EAAe,GAALK,EAAU,IAWhChF,eATckB,EAAW,CAAC,KAAO,CAAC,OACN5W,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAS1E8b,UAPc,EAQdU,QAPYnB,GAQZpkB,KAAM,aAAewmB,EAAW,SAAW,WC1cOiE,CAAqBjE,IAC3EkE,GAAkBlE,GAAsB8C,GD6chB9C,KACxB,MAAM1B,EAAOza,KAAK0a,IAAI,GAAI,GACpBE,EAAKuB,EAAW,EAAI,EAoB1B,MAAO,CACH1B,OACAE,OAnBJ,SAAgBzN,GACZ,IAAIyS,EAAK,EAAGC,EAAK,EAAGK,EAAK,EACzB,IAAK,IAAI7qB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKpU,GAAG1D,KAAOwlB,IAAI+E,EAAS,EAAJvqB,EAAQ8X,EAAKnU,GAAG3D,IAE/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,GAAIA,IAPjB,IAQC8X,EAAKlU,GAAG5D,GAAWwqB,EAAS,EAAJxqB,EAAQ8X,EAAKjU,GAAG7D,GAPzC,IAQM8X,EAAKlU,GAAG5D,KAAW6qB,EAAS,EAAJ7qB,EAAQ8X,EAAKjU,GAAG7D,IAErD,OAAOuqB,EAAU,GAALC,EAAe,GAALK,EAAU,IAWhChF,eATckB,EAAW,CAAC,KAAO,CAAC,OACN5W,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAS1E8b,UAPc,EAQdU,QAPYnB,GAQZpkB,KAAM,UAAYwmB,EAAW,SAAW,WCzeUmE,CAAqBnE,IAC3EoE,GAAcpE,GAAsB8C,GD4ehB9C,KACpB,MAAM1B,EAAOza,KAAK0a,IAAI,GAAI,GACpBE,EAAKuB,EAAW,EAAI,EACpBtd,EAAKsd,EAAW,EAAI,EAwB1B,MAAO,CACH1B,OACAE,OAvBJ,SAAgBzN,GACd,IAAIyS,EAAK,EAAGC,EAAK,EAAGK,EAAK,EAAGO,EAAK,EACjC,IAAK,IAAIprB,EAAI,EAAGA,EAAI,EAAGA,IAChB8X,EAAKpU,GAAG1D,KAAOwlB,IAAI+E,EAAS,EAAJvqB,EAAQ8X,EAAKnU,GAAG3D,IAE/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAC3B,MAAM4D,EAAKkU,EAAKlU,GAAG5D,GACb6D,EAAKiU,EAAKjU,GAAG7D,GACf4D,IAAO6F,EAAI+gB,EAAS,EAAJxqB,EAAQ6D,EAVrB,IAWED,EAAWinB,EAAS,EAAJ7qB,EAAQ6D,EAV1B,IAWED,IAAWwnB,EAAS,EAAJprB,EAAQ6D,GAEnC,OAAO0mB,EAAU,GAALC,EAAY,IAAFK,EAAmB,MAAFO,GAYrCvF,cATU,CAAC,IACa1V,KAAM7G,IAAkB,IAAI9F,IAAYkN,MAAMpH,KAStE8b,UAPc,EAQdU,QAPYnB,GAQZpkB,KAAM,MAAQwmB,EAAW,SAAW,WC7gBUsE,CAAiBtE,IAInEuE,GAAaA,CAACC,EAAqBC,IACnC3B,GDspBJ,SAA0B0B,EAAqBC,GAC3C,MAAMnG,EAAO,GAAQza,KAAK0a,IAAI,EAAG,GAAK,EAAI,EAEpC4B,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GACtDI,EAAW,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAgBnDmE,EAAWtW,EAAkB,CAAC,KAAM,KAAM,CAAC,MAAO,CAAC,GAAI,IAAK,KAAM,OAAQhF,KAAI+F,GAAKA,EAAE9C,KAAK,OAC1FsY,EAAWvW,EAAkB,CAAC,MAAO,CAAC,IAAK,MAAO,CAAC,MAAO,CAAC,GAAI,IAAK,KAAM,OAAOhF,KAAI+F,GAAKA,EAAE9C,KAAK,OACvG,IAAIyE,EAAkB,GACJ,EAAd0T,IAAoB1T,EAAQA,EAAMpF,OAAOgZ,IAC3B,GAAdF,IAAoB1T,EAAQA,EAAMpF,OAAOiZ,IAI7C,IAAIC,EAAuB,GAY3B,OAXkB,EAAdJ,IAAoBI,EAAaA,EAAWlZ,OAH1B,CAAC,IAAK,QAIV,GAAd8Y,IAAoBI,EAAaA,EAAWlZ,OAH1B,CAAC,MAAO,UAavB,CACH4S,OACAE,OArCJ,SAAgBzN,GACd,IAAIjU,EAAK,EAAGD,EAAK,EACjB,IAAK,IAAI5D,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAC3B,IAAIsC,EAAM4kB,EAAYpP,EAAKlU,GAAG5D,IAC1BsC,GAAO,IACPuB,EAAU,EAALA,EAASiU,EAAKjU,GAAG7D,IAEtBsC,EAAM,IACNsB,GAAMgH,KAAK0a,IAAI,EAAGhjB,EAAM,GAAKglB,EAAStnB,IAI5C,OAAwB,GAAX,GAAL6D,EAAUD,GAAU,EAAyB,KAAlBkU,EAAKtB,GAAG,GAAK,GAASsB,EAAKpU,GAAG,IA0B/DmiB,eAX8B,WAAhB2F,EAA2BG,EACxB,SAAhBH,EAAyB,CAAC,MAAQ3T,GAEP1H,KAAK/P,IAAK,IAAIoD,IAAYkN,MAAMtQ,KAS5DglB,UAPc,GAQdU,QAPY,CAAC,IAAK,KAAM,KAAM,KAAM,IAAK,MAQzCvlB,KAAM,QAAUgrB,EAAc,IAAMC,GCpsB1BI,CAAiBL,EAAaC,IAM5CK,GAAkC,WAiBlC,OAdAC,wBAcO,CACHte,MAdJ,SAAesK,EAAkB7X,EAAYa,EAAYT,GACrD+Y,QAAQ2S,OAAO5V,GAAW2B,EAAKtB,IAAI,IAAIhT,IAAYgT,IAAK,8BAAgCsB,EAAKtB,IAC7F,MAAMwV,EAAmBlU,EAAK4B,kBAC9BN,QAAQ2S,OAAQC,EAAiBrS,eAAgB,0BACjD,IAAInP,GC5OUyhB,ED4OiBD,EC3O9BE,iBArBT,SAAqBD,GAYnB,MAAO,CACLvoB,GAAIuoB,EAAMvoB,GACVC,GAAIsoB,EAAMtoB,GACVC,GAAIqoB,EAAMroB,GACVC,GAAIooB,EAAMpoB,IAKUsoB,CAAYF,KAD7B,IAAeA,ED6Od,MAAO,CAAE,IAAIrU,GAAQpN,GAAUsC,QAU/Bgb,UARJ,SAAmBhQ,GACf,OAAO,GAQP8R,WANJ,WACI,MAAO,MEpQXI,GAAe,WACf,IAAIoC,EAA+B,IAAIpd,IAWvC,MAAO,CAAEnO,IAVT,SAAaiW,GACT,IAAIuV,EAAM/V,KAAKG,UAAUK,GACzB,GAAKsV,EAAMlT,IAAImT,GAKX,OAAOD,EAAMvrB,IAAIwrB,GALA,CACjB,IAAItC,EHiDT,SAAgBtC,GACnB,IAAI6E,GACA,KAAEjH,EAAI,OAAEE,EAAM,cAAEM,EAAa,UAAET,EAAWU,QAASyG,EAAW,KAAEhsB,GAAQknB,EACxE3B,EAAUyG,EAAYpc,KAAI+F,GAAKsE,GAAKO,IAAI7E,KACxCjK,GAAc,EACdugB,EAAe,CAAC,IAAI3G,IA0CxB,MAAQ,CACJhf,KA1CJ,WACI,GAAIoF,EAAa,OACjBA,GAAc,EACdqgB,EAAO,IAAIG,WAAWpH,GAAMrS,KAAK,KACjC,IAAK,IAAIiZ,KAASpG,EACdyG,EAAK/G,EAAO0G,IAAU,EAE1B,IAAIS,EAAW,IAAI7G,GACf8G,EAAiBD,EAASzqB,OAC9B,IAAK,IAAIjC,EAAI,EAAGA,EAAIolB,EAAWplB,IAAK,CAEhC,IAAI4sB,EAAe,GACnB,IAAK,IAAIX,KAASS,EACd,IAAK,IAAIpjB,KAAQwc,EAAS,CACtB,IAAI+G,EAAWZ,EAAMvb,MAAMpH,GACvBhH,EAAMijB,EAAOsH,GACC,MAAdP,EAAKhqB,KACLgqB,EAAKhqB,GAAOtC,EAAI,EAChB4sB,EAAapU,KAAKqU,IAI9BH,EAAWE,EACPnF,EAAOqF,kBAAoB9sB,EAAI,GAAKynB,EAAOqF,kBAC3CN,EAAahU,KAAK,IAAIkU,IAE1BC,GAAkBD,EAASzqB,OAG3BwlB,EAAOqF,kBAcXjE,MAVJ,SAAe/Q,GACX,IAAIxX,EAAIgsB,EAAK/G,EAAOzN,IACpB,OAAU,MAANxX,EAAkB8kB,EAAY,EAC3B9kB,GAQPysB,MANJ,SAAeC,EAAkBC,GAC7B,OAAO1H,EAAOyH,KAAWzH,EAAO0H,IAMhC1H,SACAO,UACAV,YACAC,QGvGiB6H,CAAOpW,GAEpB,OADAsV,EAAMla,IAAIma,EAAKtC,GACRA,KAPA,GAefoD,GAAe,WACf,IAAIf,EAA+B,IAAIpd,IA0CvC,MAAO,CAACnO,IAzCR,SAAakB,GACT,IAAKqqB,EAAMlT,IAAInX,GACX,OAAQA,GACJ,IAAK,OAAQqqB,EAAMla,IAAInQ,EFuMhB8nB,GAAc9D,KEvMoB,MACzC,IAAK,KAAMqG,EAAMla,IAAInQ,EFgMhB8nB,GAAcrD,KEhMkB,MACrC,IAAK,QAAS4F,EAAMla,IAAInQ,EFiMf8nB,GAAcvD,KEjMqB,MAC5C,IAAK,QAAS8F,EAAMla,IAAInQ,EFkMf8nB,GAAc7D,KElMqB,MAC5C,IAAK,WAAYoG,EAAMla,IAAInQ,EAAG6oB,IAAS,IAAQ,MAC/C,IAAK,UAAWwB,EAAMla,IAAInQ,EAAG6oB,IAAS,IAAS,MAC/C,IAAK,kBAAmBwB,EAAMla,IAAInQ,EAAGgpB,IAAe,IAAQ,MAC5D,IAAK,iBAAkBqB,EAAMla,IAAInQ,EAAGgpB,IAAe,IAAS,MAC5D,IAAK,iBAAkBqB,EAAMla,IAAInQ,EAAGkpB,IAAe,IAAQ,MAC3D,IAAK,gBAAiBmB,EAAMla,IAAInQ,EAAGkpB,IAAe,IAAS,MAC3D,IAAK,aAAcmB,EAAMla,IAAInQ,EAAGopB,IAAW,IAAQ,MACnD,IAAK,YAAaiB,EAAMla,IAAInQ,EAAGopB,IAAW,IAAS,MACnD,IAAK,WAAYiB,EAAMla,IAAInQ,EAAGqoB,IAAS,IAAQ,MAC/C,IAAK,UAAWgC,EAAMla,IAAInQ,EAAGqoB,IAAS,IAAS,MAC/C,IAAK,aAAcgC,EAAMla,IAAInQ,EAAGuoB,IAAW,IAAQ,MACnD,IAAK,YAAa8B,EAAMla,IAAInQ,EAAGuoB,IAAW,IAAS,MACnD,IAAK,aAAc8B,EAAMla,IAAInQ,EAAG2oB,IAAW,IAAQ,MACnD,IAAK,YAAa0B,EAAMla,IAAInQ,EAAE2oB,IAAW,IAAS,MAClD,IAAK,aAAc0B,EAAMla,IAAInQ,EAAE4oB,IAAW,IAAQ,MAClD,IAAK,YAAayB,EAAMla,IAAInQ,EAAE4oB,IAAW,IAAS,MAClD,IAAK,KAAMyB,EAAMla,IAAInQ,EF6LhB8nB,GAAcpD,KE7LkB,MAErC,IAAK,YAAa2F,EAAMla,IAAInQ,EAAG8pB,MAAoB,MACnD,IAAK,MAAOO,EAAMla,IAAInQ,EFiMhB8nB,GAAc5C,KEjMmB,MACvC,IAAK,WAAYmF,EAAMla,IAAInQ,EAAGupB,GAAW,EAAM,SAAU,MACzD,IAAK,SAAUc,EAAMla,IAAInQ,EAAGupB,GAAW,IAAQ,MAC/C,IAAK,SAAUc,EAAMla,IAAInQ,EAAGupB,GAAW,KAAQ,MAC/C,IAAK,OAAQc,EAAMla,IAAInQ,EAAGupB,GAAW,KAAQ,MAC7C,IAAK,WAAYc,EAAMla,IAAInQ,EAAGupB,GAAW,EAAM,WAAY,MAC3D,IAAK,WAAYc,EAAMla,IAAInQ,EAAGupB,GAAW,GAAM,WAAY,MAC3D,IAAK,SAAUc,EAAMla,IAAInQ,EAAGupB,GAAW,GAAM,WAAY,MACzD,IAAK,OAASc,EAAMla,IAAInQ,EF8LjB8nB,GAAcxC,KE9LqB,MAE1C,IAAK,SAAU+E,EAAMla,IAAInQ,EF8LhB8nB,GAActC,KE3L/B,OAAO6E,EAAMvrB,IAAIkB,KAzCN,G,ICsDdqrB,G,QA3EE,MAAeC,GAAU7b,cAAA,KAEnBjR,UAAI,GAEV,MAAM+sB,WAAqBD,GAAU7b,cAAA,SAAAhC,WAAA,KACxCjP,KAAO,aACP+W,sBAeI,OADc,IAAItI,IAbc,CAC5B,CAAC,IAAK,IAAM,CAAC,KAAM,IAAM,CAAC,KAAM,GAChC,CAAC,IAAK,IAAM,CAAC,KAAM,IAAM,CAAC,KAAM,KAChC,CAAC,IAAK,GAAI,CAAC,KAAM,GAAI,CAAC,KAAM,KAC5B,CAAC,IAAK,GAAI,CAAC,KAAM,GAAI,CAAC,KAAM,KAC5B,CAAC,IAAK,KAAM,CAAC,KAAM,KAAM,CAAC,KAAM,KAChC,CAAC,IAAK,KAAM,CAAC,KAAM,KAAM,CAAC,KAAM,KAChC,CAAC,IAAK,KAAM,CAAC,KAAM,KAAM,CAAC,KAAM,GAChC,CAAC,IAAK,KAAM,CAAC,KAAM,KAAM,CAAC,KAAM,KAChC,CAAC,IAAK,KAAM,CAAC,KAAM,KAAM,CAAC,KAAM,KAChC,CAAC,IAAK,GAAM,CAAC,KAAM,KAAM,CAAC,KAAM,GAChC,CAAC,IAAK,KAAM,CAAC,KAAM,KAAM,CAAC,KAAM,OAOxCue,SAAS1V,GACL,IAAI8K,EAAM,EACV,IAAK,IAAIviB,KAAKyX,EAAMA,MAAO,CAEvB8K,GADe2K,GAAaE,SAAS3sB,IAAIT,EAAEG,OAAU,IAIzD,OAA4B,IAArBsX,EAAMA,MAAM5V,OAAe0gB,GA5B7B2K,GAmBFE,SAAWF,GAAaG,eAc5B,MAAMC,WAAqBL,GAAU7b,cAAA,SAAAhC,WAAA,KACxCjP,KAAO,MACPgtB,SAAS1V,GACL,IAAI8K,EAAM,EACV,IAAK,IAAIviB,KAAKyX,EAAMA,MAChB8K,GAAqB,MAAdviB,EAAEG,KAAK,GAAa,EAAI,EAEnC,OAAa,IAANoiB,EAAY9K,EAAMA,MAAM5V,QAIhC,MAAM0rB,WAAqBN,GAAU7b,cAAA,SAAAhC,WAAA,KACxCjP,KAAO,MACPgtB,SAAS1V,GACL,OAAOA,EAAMA,MAAM5V,QAKpB,MAAM2rB,WAAyBP,GAAU7b,cAAA,SAAAhC,WAAA,KAC5CjP,KAAO,WAEPgtB,SAASM,GACL,IAAIC,EAAQ,EACRjW,EAAQ,CAAC,MAAOgW,EAAYhW,MAAM1H,KAAI+F,GAAKA,EAAE3V,OAAO,IACxD,IAAK,IAAIP,EAAG,EAAGA,EAAI6X,EAAM5V,OAAS,EAAGjC,IAAK,CACtC,IAAI+tB,EAAWlW,EAAM7X,GAAK6X,EAAM7X,EAAI,GAChCguB,EAAa9a,OAAO+a,WAAWL,GAAiBM,MAAMH,IACtD7a,OAAOib,MAAMH,KACbA,EAAa,IAEjBF,GAASE,EAEb,OAAOF,GAdFF,GAEFM,MAAQE,GAiBR,SAANhB,OAAM,eAANA,IAAM,mBAANA,IAAM,qBAANA,IAAM,qBAANA,IAAM,wBAANA,QAAM,KAOJ,MAAMiB,WAAoBhB,GAAU7b,cAAA,SAAAhC,WAAA,KACvCjP,KAAO,KAEP+W,sBACI,MAAMgX,EAAK,GAmCX,MAjCwC,CAWpC,EAAM,CAAC,EAAG,EAAGA,EAAIA,GACjB,KAAM,CAAC,EAAG,EAAG,EAAG,GAChB,GAAM,CAAC,IAAK,IAAK,IAAK,KACtB,EAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,KAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,GAAM,CAAC,IAAK,IAAK,IAAK,KACtB,EAAM,CAAC,IAAKA,EAAI,EAAGA,GACnB,KAAM,CAAC,EAAG,IAAK,EAAGA,GAClB,GAAM,CAACA,EAAI,EAAG,EAAGA,GACjB,EAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,KAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,GAAM,CAAC,IAAK,IAAK,IAAKA,GACtB,EAAM,CAACA,EAAI,EAAG,EAAGA,GACjB,KAAM,CAAC,EAAG,IAAK,EAAGA,GAClB,GAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,EAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,KAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,GAAM,CAAC,IAAKA,EAAI,IAAKA,GACrB,EAAM,CAAC,EAAG,EAAG,EAAGA,GAChB,KAAM,CAAC,EAAG,IAAK,IAAK,GACpB,GAAM,CAAC,IAAK,EAAG,EAAG,IAK1BhX,4BACI,IAAI,OAACiX,EAAM,QAAEC,EAAO,KAAEC,EAAI,QAAEC,EAAO,SAAEC,GAAYvB,GACjD,MAAO,CAEH,EAAM,CAACmB,EAASC,EAASC,EAAUE,GACnC,KAAM,CAACD,EAASD,EAASE,EAAWJ,GACpC,GAAM,CAACC,EAASE,EAAQH,EAASE,GAEjC,EAAM,CAACF,EAASC,EAASC,EAAUE,GACnC,KAAM,CAACD,EAASD,EAASE,EAAWJ,GACpC,GAAM,CAACC,EAASE,EAAQH,EAASE,IAKzCnX,wBAYI,MAVwB,CAEpB,CAAC,EAAG,EAAG,EAAG,GAEV,CAAC,IAAK,EAAG,EAAG,GAEZ,CAAC,IAAK,EAAG,EAPF,IASP,CAAC,EAAG,EATG,GASI,IAMnBiW,SAASM,GACL,OAAOpqB,KAAKmrB,mBAAmBf,GAAagB,KAEhDD,mBAAmBf,GAEf,MAAMS,EAAK,IAELQ,EAAMjB,EAAYhW,MAAM5V,OACxB8sB,EAAK5sB,MAAM2sB,EAAM,GAAG9b,KAAK,MAAM7C,KAAI,IAAM,CAACme,EAAIA,EAAIA,EAAIA,KACtDU,EAAU7sB,MAAM2sB,EAAM,GAAG9b,KAAK,MAAM7C,KAAI,IAAMhO,MAAM,GAAG6Q,KAAK,MAAM7C,KAAI,IAAM,EAAE,GAAI,OAElF8e,EAAaZ,GAAYY,WACzBzB,EAAWa,GAAYb,SACvB0B,EAAiBb,GAAYa,eAE/BH,EAAG,GAAK,CAAC,EAAG,EAAG,EAAGT,GAItB,IAAK,IAAItuB,EAAI,EAAGA,EAAI8uB,EAAK9uB,IAAK,CAC1B,MAAMsJ,EAAOukB,EAAYhW,MAAM7X,GAAGO,KAClC,IAAK,IAAI4uB,EAAY,EAAGA,EAAY,EAAGA,IACnC,IAAK,IAAIC,EAAe,EAAGA,EAAe,EAAGA,IAAgB,CACzD,MAAMC,EAAaN,EAAG/uB,GAAGmvB,GAAaF,EAAWE,GAAWC,GAAgB5B,EAASlkB,GAAM8lB,GACrFE,EAAWJ,EAAe5lB,GAAQ4lB,EAAe5lB,GAAM8lB,GAAgBA,EACzEE,IAAalC,GAAOuB,WACpBU,EAAaN,EAAG/uB,EAAE,GAAGsvB,KACrBP,EAAG/uB,EAAE,GAAGsvB,GAAYD,EACpBL,EAAQhvB,EAAE,GAAGsvB,GAAY,CAACH,EAAWC,MAOrD,IAAIG,EAAejB,EACfkB,GAAuB,EAC3B,IAAK,IAAIC,EAAO,EAAGA,EAAO,EAAGA,IACrBV,EAAGD,GAAKW,GAAQF,IAChBA,EAAeR,EAAGD,GAAKW,GACvBD,EAAsBC,GAG9B,IAAIC,EAAeF,EACfG,EAAmC,CAAC,CAACD,EAAcA,IACvD,IAAK,IAAI1vB,EAAI8uB,EAAK9uB,GAAK,EAAGA,IAAK,CAC3B,MAAO4vB,EAAeC,GAAyBb,EAAQhvB,GAAG0vB,GAC1DC,EAAanX,KAAK,CAACoX,EAAeC,IAClCH,EAAeE,EAEnBD,EAAa5R,UAEb,IAAI+R,EAAW,CACX,OAAQ,SAAU,UAAW,WAE7BC,EAAO,cAAcD,EAASH,EAAa,GAAG,MAC9CK,EAA6B,GACjC,IAAK,IAAIhwB,EAAI,EAAGA,EAAI8uB,EAAK9uB,IAAK,CAC1B,IAAKiwB,EAAIC,GAAMP,EAAa3vB,GACxBsJ,EAAOukB,EAAYhW,MAAM7X,GAAGO,KAC5B0vB,IAAOC,EAAIF,EAAgBxX,KAAKlP,IAEhCymB,GAAQ,QAAQC,EAAgB5c,KAAK,mBAAmB0c,EAASI,KACjEF,EAAkB,CAAC1mB,IAK3B,OAFI0mB,EAAgB/tB,SAAQ8tB,GAAQ,QAAQC,EAAgB5c,KAAK,QACjE2c,GAAQ,YAAYD,EAASH,EAAab,GAAK,MACxC,CACHqB,IAAKtC,EAAY5b,WACjB4c,KAAMU,EAENQ,KAAMA,IAjJL1B,GAyCFb,SAAWa,GAAYZ,eAzCrBY,GAuDFa,eAAiBb,GAAY+B,qBAvD3B/B,GAuEFY,WAAaZ,GAAYgC,iBAiF7B,MAAMC,WAA0BjD,GAAU7b,cAAA,SAAAhC,WAAA,KAC7CjP,KAAO,WACPgtB,SAASM,GACL,IAAI/V,EAAO,IAAItU,GACXqU,EAAQgW,EAAY/gB,MAAM+K,MAG1B0Y,EAAW,EACf,IAAK,IAAIvwB,EAAI,EAAGA,EAAI6X,EAAM5V,OAAS,EAAGjC,IAAK,CACvC,IAAIgtB,EAAQlV,EAAKT,UAAUQ,EAAM7X,IAC7BwwB,EAAa,EACjB,IAAK,IAAIttB,EAAI,EAAGA,EAAI,EAAGA,IACC,IAAf4U,EAAKpU,GAAGR,IAA2B,IAAf4U,EAAKpU,GAAGR,IAAc4U,EAAKpU,GAAGR,KAAO8pB,EAAMtpB,GAAGR,IACnEstB,IAGR,IAAK,IAAIttB,EAAI,EAAGA,EAAI,GAAIA,IACA,IAAf4U,EAAKlU,GAAGV,IAA2B,IAAf4U,EAAKlU,GAAGV,IAA2B,IAAf4U,EAAKlU,GAAGV,IAAc4U,EAAKlU,GAAGV,KAAO8pB,EAAMppB,GAAGV,IACvFstB,IAGiB,MAArB3Y,EAAM7X,GAAGO,KAAK,GACdgwB,GAAY,GAAK,EAAIC,GAErBD,GAAY,EAAIC,EAEpB1Y,EAAOkV,EAEX,OAAOuD,GCrIf,SAAS/iB,GAAMijB,EAAoB3Y,EAAiB2P,GAChD,MAAMiJ,EAASvD,GAAatsB,IAAI4vB,GAChC,IAAI,SAAEE,EAAQ,aAAEC,EAAY,YAAEC,GAAgBpJ,EAC1C5X,EDsID,SAAsB9N,GACzB,OAAQA,GAOJ,QACI,OAAO,IAAIurB,GANf,IAAK,WAAY,OAAO,IAAIM,GAC5B,IAAK,MAAO,OAAO,IAAIF,GACvB,IAAK,KAAM,OAAO,IAAIW,GACtB,IAAK,WAAY,OAAO,IAAIiC,GAC5B,IAAK,MAAO,OAAO,IAAI3C,IC7IlBmD,CAAarJ,EAAOsJ,WAAa,cACtCC,EAAuBJ,EAAe,GAAM,GAAKA,EAKrD,OAJiBD,GAAY,CAAC,KAAKxgB,KAAI8gB,GACnCP,EAAOljB,MAAMsK,EAAKpH,MAAMugB,GAAK,EAAGJ,EAAaG,GACxC7gB,KAAI+F,IAAC,CAAMgb,QAASD,EAAIzmB,SAAU0L,EAAG4X,MAAOje,EAAG0d,SAASrX,SAC/D+F,OACekV,MAAM,CAACjb,EAAG4D,IAAM5D,EAAE4X,MAAQhU,EAAEgU,QAAOjkB,MAAM,EAAG+mB,GAIjE,MAAMQ,GAAWA,CAACzqB,EAAa0qB,KAC3B,IAAIlP,EAAkB,GAWtB,MAVY,QAARxb,EACAwb,EAAmB,KAAXkP,EAAiB,CAAC,GAAI,IAAK,KAAM,KAAM,KAAM,MAAO,OAAQ,QACxD,MAAXA,EAAkB,CAAC,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,OAAQ,QAClE,CAAC,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,OAAQ,QAEhC,OAAR1qB,IACPwb,EAAO,CAAC,GAAI,IAAK,KAAM,KAAM,KAAM,MAAO,OAAQ,OAC1C,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,OAAQ,OAC9C,IAAK,KAAM,MAAO,MAAO,KAAM,MAAO,OAAQ,SAEnDA,GA2FJ,SAASmP,GAAQrF,GACpB,IAAInU,GAAO,IAAItU,IAAYkN,MAAMub,EAAMsF,UAAU7gB,MAAMub,EAAMuF,eAC7D,GAAoB,OAAhBvF,EAAMwF,MAAgB,OA3F9B,SAAoBxF,EAAsBnU,GACtC,IAAI2P,EAAwB,CACxBkJ,SAAU,CAAC,GAAI,IAAK,KAAM,MAC1BC,aAAc3E,EAAM2E,aACpBC,YAAa,GAEb1O,EAAOiP,GAASnF,EAAMyF,YAAazF,EAAM0F,iBAEzClJ,EAA6B,GACjC,GAAuB,OAAnBwD,EAAM2F,SACNnJ,EAAYtG,EAAKhS,KAAIxJ,GAAO6G,GAAM,KAAMsK,EAAKiC,YAAY,IAAInC,GAAQjR,IAAO8gB,GAAQtX,KAAI9F,IAAG,IACxFA,EAAKqnB,YAAa/qB,EAAK8qB,MAAO,SAC7BN,MAAM,CAACjb,EAAG4D,IAAM5D,EAAE4X,MAAQhU,EAAEgU,UAAQ7R,WACrC,CACH,MAAM4V,EAA+C,CACjD,GAAM,CAAC,MACP,GAAM,CAAC,WAAY,WACnB,YAAa,CAAC,kBAAmB,kBACjC,SAAY,CAAC,iBAAkB,iBAC/B,WAAY,CAAC,WAAY,UAAW,kBAAmB,iBAAkB,iBAAkB,kBAIzFC,GAFe7F,EAAM2F,SAEa,CACpC,kBAAmB,KACnB,iBAAkB,KAClB,iBAAkB,OAClB,gBAAiB,OACjB,WAAY,KACZ,UAAW,KACX,GAAM,OAEJG,EAAUF,EAAiB5F,EAAM2F,UAEvCnJ,EAAYtG,EACPhS,KAAIxJ,GACDorB,EACK5hB,KAAIpO,GAAKyL,GAAMzL,EAAG+V,EAAKiC,YAAY,IAAInC,GAAQjR,IAAO8gB,GAClDtX,KAAI9F,IAAG,IACDA,EACHqnB,YAAa/qB,EACbmrB,OAAQA,EAAO/vB,GACf0vB,MAAO,WAEdxV,OACAkV,MAAK,CAACjb,EAAG4D,IAAM5D,EAAE4X,MAAQhU,EAAEgU,UAEnC7R,OAGT,OAAOwM,EAyC0BuJ,CAAW/F,EAAOnU,GAC9C,CAAC,IAADma,EACD,IAAItrB,EAAM,IAAIiR,IAA+B,QAAvBqa,EAAChG,EAAMiG,cAAc,UAAE,IAAAD,OAAA,EAAtBA,EAAwBP,cAAgB,IAE/D,GADA5Z,EAAOA,EAAKiC,YAAYpT,GAAK+J,MAAM/J,EAAImG,OACnB,OAAhBmf,EAAMwF,MAAgB,OA1ClC,SAAoBxF,EAAsBnU,GACtC,IAAI2P,EAAwB,CACxBmJ,aAAc3E,EAAM2E,aACpBC,YAAa,IAKjB,MAHgB,CAAC,WAAY,WAAW1gB,KAAI5P,GAAQiN,GAAMjN,EAAMuX,EAAM2P,GAAQtX,KAAI9F,IAAG,IAC9EA,EAAKonB,MAAOlxB,MACf4wB,MAAM,CAACjb,EAAG4D,IAAM5D,EAAE4X,MAAQhU,EAAEgU,UAAQ7R,OAmCHkW,CAAWlG,EAAOnU,GAC9C,GAAoB,OAAhBmU,EAAMwF,MAAgB,OAhCvC,SAAoBxF,EAAsBnU,GAStC,OAJgBtK,GAAM,KAAMsK,EAJA,CACxB8Y,aAAc3E,EAAM2E,aACpBC,YAAa,KAEyB1gB,KAAI9F,IAAG,IAC1CA,EAAKonB,MAAO,SACfN,MAAM,CAACjb,EAAG4D,IAAM5D,EAAE4X,MAAQhU,EAAEgU,QAyBUsE,CAAWnG,EAAOnU,GACnD,GAAoB,QAAhBmU,EAAMwF,MAAiB,OArBxC,SAAqBxF,EAAsBnU,GASvC,OAJgBtK,GAAM,MAAOsK,EAJD,CACxB8Y,aAAc3E,EAAM2E,aACpBC,YAAa,KAE0B1gB,KAAI9F,IAAG,IAC3CA,EAAKonB,MAAO,UACfN,MAAM,CAACjb,EAAG4D,IAAM5D,EAAE4X,MAAQhU,EAAEgU,QAcWuE,CAAYpG,EAAOnU,GAE9D,MAAO,GC7PJ,MAAMzJ,GAAM,CACfijB,QAAUrF,IAEN7S,QAAQ2H,IAAI,kBAAmBkL,GACxBqF,GAAQrF,KAKvBxd,EAAOJ","file":"static/js/analyzer-worker.ca439f15.chunk.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/roux-trainers/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/* eslint-disable */\nfunction createArray(length) {\n\tconst arr = Array(length);\n\tfor (var i=0; i<length; i++) {\n\t\tarr[i] = 0;\n\t}\n\treturn arr;\n}\n\nfunction createArrays(length1, length2) {\n\tconst arr = Array(length1);\n\tfor (var i=0; i<length1; i++) {\n\t\tarr[i] = Array(length2);\n\t\tfor (var j=0; j<length2; j++) {\n\t\t\tarr[i][j] = 0;\n\t\t}\n\t}\n\treturn arr;\n}\n\nfunction bitOdd(i) {\n\ti ^= i >>> 1;\n\ti ^= i >>> 2;\n\ti ^= i >>> 4;\n\ti ^= i >>> 8;\n\treturn i & 1;\n}\n\nfunction bitCount(i) {\n\ti = i - ((i >>> 1) & 0x55555555);\n\ti = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n\treturn (i + (i >>> 8) + (i >>> 4)) & 0x0f;\n}\n\nfunction get4Parity(idx) {\n\tvar p = 0;\n\tfor (var i=2; i>=0; i--) {\n\t\tp += idx % (4-i);\n\t\tidx = ~~(idx / (4-i));\n\t}\n\tp &= 1;\n\treturn p;\n}\n\nfunction get8Parity(idx) {\n\tvar p = 0;\n\tfor (var i=6; i>=0; i--) {\n\t\tp += idx % (8-i);\n\t\tidx = ~~(idx / (8-i));\n\t}\n\tp &= 1;\n\treturn p;\n}\n\nfunction get12Parity(idx) {\n\tvar p = 0;\n\tfor (var i=10; i>=0; i--) {\n\t\tp += idx % (12-i);\n\t\tidx = ~~(idx / (12-i));\n\t}\n\tp &= 1;\n\treturn p;\n}\n\n\nfunction binarySearch(arr, key) {\n\tvar length = arr.length;\n\tif (key <= arr[length-1]) {\n\t\tvar l = 0;\n\t\tvar r = length-1;\n\t\twhile (l <= r) {\n\t\t\tvar mid = (l+r)>>>1;\n\t\t\tvar val = arr[mid];\n\t\t\tif (key > val) {\n\t\t\t\tl = mid + 1;\n\t\t\t} else if (key < val) {\n\t\t\t\tr = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn (mid);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0xffff;\n}\n\nvar fact = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600];\nvar perm3 = [[11, 10, 9], [10, 11, 9], [11, 9, 10], [9, 11, 10], [10, 9, 11], [9, 10, 11]];\nvar ud2std = [0, 1, 2, 4, 7, 9, 10, 11, 13, 16];\nvar std2ud = createArray(18);\nvar Cnk = createArrays(12, 13);\nvar move2str = [\"U \", \"U2\", \"U'\", \"R \", \"R2\", \"R'\", \"F \", \"F2\", \"F'\", \"D \", \"D2\", \"D'\", \"L \", \"L2\", \"L'\", \"B \", \"B2\", \"B'\"];\nvar urfMove = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17], \n\t\t\t\t\t\t\t\t\t\t\t[6, 7, 8, 0, 1, 2, 3, 4, 5,15,16,17, 9,10,11,12,13,14],\n\t\t\t\t\t\t\t\t\t\t\t[3, 4, 5, 6, 7, 8, 0, 1, 2,12,13,14,15,16,17, 9,10,11],\n\t\t\t\t\t\t\t\t\t\t\t[2, 1, 0, 5, 4, 3, 8, 7, 6,11,10, 9,14,13,12,17,16,15], \n\t\t\t\t\t\t\t\t\t\t\t[8, 7, 6, 2, 1, 0, 5, 4, 3,17,16,15,11,10, 9,14,13,12],\n\t\t\t\t\t\t\t\t\t\t\t[5, 4, 3, 8, 7, 6, 2, 1, 0,14,13,12,17,16,15,11,10, 9]];\nfor (var i=0; i<12; i++) {\n\tCnk[i][0] = 1;\n\tCnk[i][i] = 1;\n\tCnk[i][i+1] = 0;\n\tfor (var j=1; j<i; j++) {\n\t\tCnk[i][j] = (Cnk[i-1][j-1] + Cnk[i-1][j]);\n\t}\n}\nfor (var i=0; i<10; i++) {\n\tstd2ud[ud2std[i]] = i;\n}\n\nvar ckmv = Array(19);//new boolean[19][18];\nvar ckmv2 = Array(11);//new boolean[11][10];\nckmv[18] = Array(18);\nckmv2[10] = Array(10);\nfor (var i=0; i<18; i++) {\n\tckmv[i] = Array(18);\n\tfor (var j=0; j<18; j++) {\n\t\tckmv[i][j] = (~~(i/3) == ~~(j/3)) || ((~~(i/3)%3 == ~~(j/3)%3) && (i>=j));\n\t}\n\tckmv[18][i] = false;\n}\nfor (var i=0; i<10; i++) {\n\tckmv2[i] = Array(10);\n\tfor (var j=0; j<10; j++) {\n\t\tckmv2[i][j] = ckmv[ud2std[i]][ud2std[j]];\n\t}\n\tckmv2[10][i] = false;\n}\n\n\n//********************************************************************************//\n\nfunction CubieCube() {\n\tthis.cp = [0, 1, 2, 3, 4, 5, 6, 7];\n\tthis.co = [0, 0, 0, 0, 0, 0, 0, 0];\n\tthis.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\tthis.eo = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\tthis.getFlip = function getFlip() {\n\t\tvar idx = 0;\n\t\tfor (var i=0; i<11; i++) {\n\t\t\tidx |= this.eo[i] << i;\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tthis.getFlipSym = function getFlipSym() {\n\t\tif (FlipR2S != 0) {\n\t\t\treturn FlipR2S[this.getFlip()];\n\t\t}\n\t\tfor (var k=0; k<16; k+=2) {\n\t\t\tEdgeConjugate(this, SymInv[k], temps);\n\t\t\tvar idx = binarySearch(FlipS2R, temps.getFlip());\n\t\t\tif (idx != 0xffff) {\n\t\t\t\treturn ((idx << 3) | (k >>> 1));\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tthis.setFlip = function setFlip(idx) {\n\t\tthis.eo[11] = bitOdd(idx);\n\t\tfor (var i=0; i<11; i++) {\n\t\t\tthis.eo[i] = idx & 1;\n\t\t\tidx >>>= 1;\n\t\t}\n\t}\n\t\n\tthis.getTwist = function getTwist() {\n\t\tvar idx = 0;\n\t\tfor (var i=0; i<7; i++) {\n\t\t\tidx *= 3;\n\t\t\tidx += this.co[i];\n\t\t}\n\t\treturn idx;\n\t}\n\t\n\tthis.getTwistSym = function getTwistSym() {\n\t\tif (TwistR2S != null) {\n\t\t\treturn TwistR2S[this.getTwist()];\n\t\t}\n\t\tfor (var k=0; k<16; k+=2) {\n\t\t\tCornConjugate(this, SymInv[k], temps);\n\t\t\tlet idx = binarySearch(TwistS2R, temps.getTwist());\n\t\t\tif (idx != 0xffff) {\n\t\t\t\treturn ((idx << 3) | (k >>> 1));\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tthis.setTwist = function setTwist(idx) {\n\t\tvar twst = 0;\n\t\tfor (var i=6; i>=0; i--) {\n\t\t\ttwst += this.co[i] = idx % 3;\n\t\t\tidx = ~~(idx/3);\n\t\t}\n\t\tthis.co[7] = (15 - twst) % 3;\n\t}\n\t\n\tthis.getUDSlice = function getUDSlice() {\n\t\tvar idx = 0;\n\t\tvar r = 4;\n\t\tfor (var i=0; i<12; i++) {\n\t\t\tif (this.ep[i] >= 8) {\n\t\t\t\tidx += Cnk[11-i][r];\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\n\tthis.setUDSlice = function setUDSlice(idx) {\n\t\tvar r = 4;\n\t\tfor (var i=0; i<12; i++) {\n\t\t\tif (idx >= Cnk[11-i][r]) {\n\t\t\t\tidx -= Cnk[11-i][r];\n\t\t\t\tr--;\n\t\t\t\tthis.ep[i] = (11-r);\n\t\t\t} else {\n\t\t\t\tthis.ep[i] = (i+r-4);\n\t\t\t}\n\t\t}\n\t}\n\tthis.getMPerm = function getMPerm() {\n\t\tvar m = (1 << this.ep[11]);\t\t\n\t\tvar idx = 0;\n\t\tfor (var i=10; i>=8; --i) {\n\t\t\tvar t = 1 << this.ep[i];\n\t\t\tidx += bitCount(m & (t - 1)) * fact[11-i];\n\t\t\tm |= t;\n\t\t}\n\t\treturn idx;\n\t}\t\n\tthis.setMPerm = function setMPerm(idx) {\n\t\tthis.ep[11] = 8;\n\t\tfor (var i=10; i>=8; i--) {\n\t\t\tthis.ep[i] = (idx % (12-i) + 8);\n\t\t\tidx = ~~(idx / (12-i));\n\t\t\tfor (var j=i+1; j<12; j++) {\n\t\t\t\tif (this.ep[j] >= this.ep[i])\n\t\t\t\t\tthis.ep[j]++;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tthis.getMid3 = function getMid3() {\n\t\tvar idxA = 0;\n\t\tvar idxB = 0;\n\t\tvar mask = 0;\n\t\tvar r = 3;\n\t\tfor (var i=11; i>=0; i--) {\n\t\t\tif (this.ep[i] >= 9) {\n\t\t\t\tidxA += Cnk[i][r--];\n\t\t\t\tvar t = 1 << this.ep[i];\n\t\t\t\tidxB += bitCount(mask & (t - 1)) * fact[2-r];\n\t\t\t\tmask |= t;\n\t\t\t}\n\t\t}\n\t\treturn (idxA * 6 + idxB);\n\t}\n\t\n\tthis.setMid3 = function setMid3(idxA) {\n\t\tvar edge = perm3[idxA % 6];\n\t\tidxA = ~~(idxA / 6);\n\t\tvar r = 3;\n\t\tfor (var i=11; i>=0; i--) {\n\t\t\tif (idxA >= Cnk[i][r]) {\n\t\t\t\tidxA -= Cnk[i][r--];\n\t\t\t\tthis.ep[i] = edge[2-r];\n\t\t\t} else {\n\t\t\t\tthis.ep[i] = (8-i+r);\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tthis.getURtoUL = function getURtoUL() {\n\t\tvar idxA = 0;\n\t\tvar idxB = 0;\n\t\tvar mask = 0;\n\t\tvar r = 3;\n\t\tfor (var i=11; i>=0; i--) {\n\t\t\tif (this.ep[i] <= 2) {\n\t\t\t\tidxA += Cnk[i][r--];\n\t\t\t\tvar t = 1 << this.ep[i];\n\t\t\t\tidxB += bitCount(mask & (t - 1)) * fact[2-r];\n\t\t\t\tmask |= t;\n\t\t\t}\n\t\t}\n\t\treturn (idxA * 6 + idxB);\t\n\t}\n\n\tthis.getDRtoDL = function getDRtoDL() {\n\t\tvar idxA = 0;\n\t\tvar idxB = 0;\n\t\tvar mask = 0;\n\t\tvar r = 3;\n\t\tfor (var i=11; i>=0; i--) {\n\t\t\tif (4 <= this.ep[i] && this.ep[i] <= 6) {\n\t\t\t\tidxA += Cnk[i][r--];\n\t\t\t\tvar t = 1 << this.ep[i];\n\t\t\t\tidxB += bitCount(mask & (t - 1)) * fact[2-r];\n\t\t\t\tmask |= t;\n\t\t\t}\n\t\t}\n\t\treturn (idxA * 6 + idxB);\t\n\t}\t\n\n\tthis.setEdgePerm = function setEdgePerm(idx) {\n\t\tthis.ep[11] = 0;\n\t\tfor (var i=10; i>=0; i--) {\n\t\t\tthis.ep[i] = (idx % (12-i));\n\t\t\tidx = ~~(idx/(12-i));\n\t\t\tfor (var j=i+1; j<12; j++) {\n\t\t\t\tif (this.ep[j] >= this.ep[i])\n\t\t\t\t\tthis.ep[j]++;\n\t\t\t}\n\t\t}\t\t\t\n\t}\n\t\n\tthis.getEdgePerm = function getEdgePerm() {\n\t\tvar m = (1 << this.ep[11]);\t\t\n\t\tvar idx = 0;\n\t\tfor (var i=10; i>=0; --i) {\n\t\t\tvar t = 1 << this.ep[i];\n\t\t\tidx += bitCount(m & (t - 1)) * fact[11-i];\n\t\t\tm |= t;\n\t\t}\n\t\treturn idx;\t\t\n\t}\n\n\tthis.getCPermSym = function getCPermSym() {\n\t\tif (EPermR2S != null) {\n\t\t\tvar idx = EPermR2S[get8Perm(this.cp)];\n\t\t\tidx ^= e2c[idx&0x0f];\n\t\t\treturn idx;\n\t\t}\n\t\tfor (var k=0; k<16; k++) {\n\t\t\tCornConjugate(this, SymInv[k], temps);\n\t\t\tvar idx = binarySearch(CPermS2R, get8Perm(temps.cp));\n\t\t\tif (idx != 0xffff) {\n\t\t\t\treturn ((idx << 4) | k);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tthis.getEPermSym = function getEPermSym() {\t\n\t\tif (EPermR2S != null) {\n\t\t\treturn EPermR2S[get8Perm(this.ep)];\n\t\t}\n\t\tfor (var k=0; k<16; k++) {\n\t\t\tEdgeConjugate(this, SymInv[k], temps);\n\t\t\tvar idx = binarySearch(EPermS2R, get8Perm(temps.ep));\n\t\t\tif (idx != 0xffff) {\n\t\t\t\treturn ((idx << 4) | k);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\t\n\n\tthis.URFConjugate = function URFConjugate() {\n\t\tCornMult(urf2, this, temps);\n\t\tCornMult(temps, urf1, this);\t\t\n\t\tEdgeMult(urf2, this, temps);\n\t\tEdgeMult(temps, urf1, this);\t\t    \t\t\n\t}\n\t\n\tthis.invCubieCube = function invCubieCube() {\n\t\tfor (var edge=0; edge<12; edge++)\n\t\t\ttemps.ep[this.ep[edge]] = edge;\n\t\tfor (var edge=0; edge<12; edge++)\n\t\t\ttemps.eo[edge] = this.eo[temps.ep[edge]];\n\t\tfor (var corn=0; corn<8; corn++)\n\t\t\ttemps.cp[this.cp[corn]] = corn;\n\t\tfor (var corn=0; corn<8; corn++) {\n\t\t\tvar ori = this.co[temps.cp[corn]];\n\t\t\ttemps.co[corn] = -ori;\n\t\t\tif (temps.co[corn] < 0)\n\t\t\t\ttemps.co[corn] += 3;\n\t\t}\n\t\tthis.copy(temps);\n\t}\n\n\n\tthis.init = function init(cperm, twist, eperm, flip) {\n\t\tset8Perm(this.cp, cperm);\n\t\tthis.setTwist(twist);\n\t\tthis.setEdgePerm(eperm);\n\t\tthis.setFlip(flip);\n\t}\n\t\n\tthis.copy = function copy(c) {\n\t\tfor (var i=0; i<8; i++) {\n\t\t\tthis.cp[i] = c.cp[i];\n\t\t\tthis.co[i] = c.co[i];\n\t\t}\n\t\tfor (var i = 0; i < 12; i++) {\n\t\t\tthis.ep[i] = c.ep[i];\n\t\t\tthis.eo[i] = c.eo[i];\n\t\t}\n\t}\n}\n\nconst cctemp = new CubieCube();\nconst temps = new CubieCube();\n\nfunction set8Perm(arr, idx) {\n\tvar val = 0x76543210;\n\tfor (var i=0; i<7; i++) {\n\t\tvar p = fact[7-i];\n\t\tvar v = ~~(idx / p);\n\t\tidx %= p;\n\t\tv <<= 2;\n\t\tarr[i] = ((val >> v) & 7);\n\t\tvar m = (1 << v) - 1;\n\t\tval = (val & m) + ((val >> 4) & ~m);\n\t}\n\tarr[7] = val;\n}\n\nfunction get8Perm(arr) {\n\tvar idx = 0;\n\tvar val = 0x76543210;\n\tfor (var i=0; i<7; i++) {\n\t\tvar v = arr[i] << 2;\n\t\tidx = (8 - i) * idx + ((val >> v) & 7);\n\t\tval -= 0x11111110 << v;\n\t}\n\treturn idx;\t\n}\n\nfunction CornMult(a, b, prod) {\n\tfor (var corn=0; corn<8; corn++) {\n\t\tprod.cp[corn] = a.cp[b.cp[corn]];\n\t\tvar oriA = a.co[b.cp[corn]];\n\t\tvar oriB = b.co[corn];\n\t\tvar ori = oriA;\n\t\tori += (oriA<3) ? oriB : 3-oriB;\n\t\tori %= 3;\n\t\tif (oriA < 3 ^ oriB < 3) {\n\t\t\tori += 3;\n\t\t}\n\t\tprod.co[corn] = ori;\n\t}\n}\t\n\nfunction EdgeMult(a, b, prod) {\n\tfor (var ed=0; ed<12; ed++) {\n\t\tprod.ep[ed] = a.ep[b.ep[ed]];\n\t\tprod.eo[ed] = (b.eo[ed] ^ a.eo[b.ep[ed]]);\n\t}\n}\n\nfunction CornConjugate(a, idx, b) {\n\tCornMult(CubeSym[SymInv[idx]], a, cctemp);\n\tCornMult(cctemp, CubeSym[idx], b);\t\t\n}\n\nfunction EdgeConjugate(a, idx, b) {\n\tEdgeMult(CubeSym[SymInv[idx]], a, cctemp);\n\tEdgeMult(cctemp, CubeSym[idx], b);\t\t\n}\n\nvar CubeSym = Array(16);\nvar moveCube = Array(18);\nvar SymInv = Array(16);\nvar SymMult = Array(16);\nvar SymMove = Array(16);\nvar Sym8Mult = Array(8);\nvar Sym8Move = Array(8);\nvar Sym8MultInv = Array(8);\nvar SymMoveUD = Array(16);\nvar FlipS2R = Array(336);\nvar TwistS2R = Array(324);\nvar CPermS2R = Array(2768);\nvar EPermS2R = CPermS2R;\nvar FlipR2S = Array(2048);\nvar TwistR2S = Array(2187);\nvar EPermR2S = createArray(40320);\nfor (var i=0; i<40320; i++) {\n\tEPermR2S[i] = 0;\n}\nvar MtoEPerm = Array(40320);\nvar merge = Array(56);\nvar e2c = [0, 0, 0, 0, 1, 3, 1, 3, 1, 3, 1, 3, 0, 0, 0, 0];\nconst urf1 = new CubieCube();\nurf1.init(2531, 1373, 67026819, 1877);\nconst urf2 = new CubieCube();\nurf2.init(2089, 1906, 322752913, 255);\n\n\nfunction CubieInit() {\n\tvar mc = Array(6);\n\tmc[0] = new CubieCube();\n\tmc[0].init(15120, 0, 119750400, 0);\n\tmc[1] = new CubieCube();\n\tmc[1].init(21021, 1494, 323403417, 0);\n\tmc[2] = new CubieCube();\n\tmc[2].init(8064, 1236, 29441808, 802);\n\tmc[3] = new CubieCube();\n\tmc[3].init(9, 0, 5880, 0);\n\tmc[4] = new CubieCube();\n\tmc[4].init(1230, 412, 2949660, 0);\n\tmc[5] = new CubieCube();\n\tmc[5].init(224, 137, 328552, 1160);\n\tfor (var m=0; m<6; m++) {\n\t\tmoveCube[m*3] = mc[m];\n\t\tfor (var p=0; p<2; p++) {\n\t\t\tmoveCube[m*3+p+1] = new CubieCube();\n\t\t\tEdgeMult(moveCube[m*3+p], mc[m], moveCube[m*3+p+1]);\n\t\t\tCornMult(moveCube[m*3+p], mc[m], moveCube[m*3+p+1]);\n\t\t}\n\t}\n\tvar c = new CubieCube();\n\tvar d = new CubieCube();\n\tvar temp;\n\tvar f2 = new CubieCube();\n\tf2.init(28783, 0, 259268407, 0);\n\tvar u4 = new CubieCube();\n\tu4.init(15138, 0, 119765538, 1792);\n\tvar lr2 = new CubieCube();\n\tlr2.init(5167, 0, 83473207, 0);\n\tlr2.co = [ 3, 3, 3, 3, 3, 3, 3, 3 ];\n\tfor (var i=0; i<16; i++) {\n\t\tSymMult[i] = Array(16);\n\t\tSymMove[i] = Array(18);\n\t\tSymMoveUD[i] = Array(10);\n\t\tCubeSym[i] = new CubieCube();\n\t\tCubeSym[i].copy(c);\n\t\tCornMult(c, u4, d);\n\t\tEdgeMult(c, u4, d);\n\t\ttemp = d;\td = c;\tc = temp;\n\t\tif (i % 4 == 3) {\n\t\t\tCornMult(c, lr2, d);\n\t\t\tEdgeMult(c, lr2, d);\n\t\t\ttemp = d;\td = c;\tc = temp;\t\t\t\t\n\t\t}\n\t\tif (i % 8 == 7) {\n\t\t\tCornMult(c, f2, d);\n\t\t\tEdgeMult(c, f2, d);\n\t\t\ttemp = d;\td = c;\tc = temp;\n\t\t}\n\t}\n\n\tfor (var j=0; j<16; j++) {\n\t\tfor (var k=0; k<16; k++) {\n\t\t\tCornMult(CubeSym[j], CubeSym[k], c);\n\t\t\tif (c.cp[0] == 0 && c.cp[1] == 1 && c.cp[2] == 2) {\n\t\t\t\tSymInv[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (var i=0; i<16; i++) {\n\t\tfor (var j=0; j<16; j++) {\n\t\t\tCornMult(CubeSym[i], CubeSym[j], c);\n\t\t\tfor (var k=0; k<16; k++) {\n\t\t\t\tif (CubeSym[k].cp[0] == c.cp[0] && CubeSym[k].cp[1] == c.cp[1] && CubeSym[k].cp[2] == c.cp[2]) {\n\t\t\t\t\tSymMult[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (var j=0; j<18; j++) {\n\t\tfor (var s=0; s<16; s++) {\n\t\t\tCornConjugate(moveCube[j], SymInv[s], c);\n\t\t\tfor (var m=0; m<18; m++) {\n\t\t\t\tvar found = 1;\n\t\t\t\tfor (var i=0; i<8; i++) {\n\t\t\t\t\tif (c.cp[i] != moveCube[m].cp[i] || c.co[i] != moveCube[m].co[i]) {\n\t\t\t\t\t\tfound = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) {\n\t\t\t\t\tSymMove[s][j] = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (var j=0; j<10; j++) {\n\t\tfor (var s=0; s<16; s++) {\n\t\t\tSymMoveUD[s][j] = std2ud[SymMove[s][ud2std[j]]];\n\t\t}\n\t}\n\tfor (var j=0; j<8; j++) {\n\t\tSym8Mult[j] = Array(8);\n\t\tSym8Move[j] = Array(18);\n\t\tSym8MultInv[j] = Array(8);\n\t\tfor (var s=0; s<8; s++) {\n\t\t\tSym8Mult[j][s] = (SymMult[j<<1][s<<1]>>>1);\n\t\t}\n\t}\n\tfor (var j=0; j<18; j++) {\n\t\tfor (var s=0; s<8; s++) {\n\t\t\tSym8Move[s][j] = SymMove[s<<1][j];\n\t\t}\n\t}\n\tfor (var j=0; j<8; j++) {\n\t\tfor (var s=0; s<8; s++) {\n\t\t\tSym8MultInv[j][s] = Sym8Mult[j][SymInv[s<<1]>>1];\n\t\t}\n\t}\n\n\tconst occ = new Array(1260);\n\n\tvar count = 0;\n\tfor (var i=0; i<64; occ[i++] = 0);\n\n\tfor (var i=0; i<2048; i++) {\n\t\tif ((occ[i>>>5]&(1<<(i&0x1f))) == 0) {\n\t\t\tc.setFlip(i);\n\t\t\tfor (var s=0; s<16; s+=2) {\n\t\t\t\tEdgeConjugate(c, s, d);\n\t\t\t\tvar idx = d.getFlip();\n\t\t\t\tocc[idx>>>5] |= 1<<(idx&0x1f);\n\t\t\t\tFlipR2S[idx] = ((count << 3) | (s >>> 1));\n\t\t\t}\n\t\t\tFlipS2R[count++] = i;\n\t\t}\n\t}\n//\talert(count);\n\tcount = 0;\n\tfor (var i=0; i<69; occ[i++] = 0);\n\tfor (var i=0; i<2187; i++) {\n\t\tif ((occ[i>>>5]&(1<<(i&0x1f))) == 0) {\n\t\t\tc.setTwist(i);\n\t\t\tfor (var s=0; s<16; s+=2) {\n\t\t\t\tCornConjugate(c, s, d);\n\t\t\t\tvar idx = d.getTwist();\n\t\t\t\tocc[idx>>>5] |= 1<<(idx&0x1f);\n\t\t\t\tTwistR2S[idx] =  ((count << 3) | (s >>> 1));\n\t\t\t}\n\t\t\tTwistS2R[count++] = i;\n\t\t}\n\t}\n//\talert(count);\n\n\tvar mask = Array(56);\n\tfor (var i=0; i<56; i++) {\n\t\tmask[i] = Array(2);\n\t\tmerge[i] = Array(56);\n\t}\n\tfor (var i=0; i<40320; i++) {\n\t\tset8Perm(c.ep, i);\n\t\tvar a = ~~(c.getURtoUL() / 6);\n\t\tvar b = ~~(c.getDRtoDL() / 6);\n\t\tmask[a][b>>>5] |= 1 << (b&0x1f);\n\t}\n\t\n\tfor (var i=0; i<56; i++) {\n\t\tcount = 0;\n\t\tfor (var j=0; j<56; j++) {\n\t\t\tif ((mask[i][j>>>5]&(1<<(j&0x1f))) != 0) {\n\t\t\t\tmerge[i][j] = count++;\n\t\t\t}\n\t\t}\n\t}\n\tcount = 0;\n\tfor (var i=0; i<1260; occ[i++] = 0);\n\tfor (var i=0; i<40320; i++) {\n\t\tif ((occ[i>>>5]&(1<<(i&0x1f))) == 0) {\n\t\t\tset8Perm(c.ep, i);\n\t\t\tfor (var s=0; s<16; s++) {\n\t\t\t\tEdgeConjugate(c, s, d);\n\t\t\t\tvar idx = get8Perm(d.ep);\n\t\t\t\tocc[idx>>>5] |= 1<<(idx&0x1f);\n\t\t\t\tvar a = d.getURtoUL();\n\t\t\t\tvar b = d.getDRtoDL();\n\t\t\t\tvar m = (merge[~~(a/6)][~~(b/6)] * 4032 + a * 12 + b % 6 * 2 + get8Parity(idx));\n\t\t\t\tMtoEPerm[m] = (count << 4 | s);\n\t\t\t\tEPermR2S[idx] = (count << 4 | s);\n\t\t\t}\n\t\t\tEPermS2R[count++] = i;\n\t\t}\n\t}\n}\n\nvar UDSliceMove = Array(495);//new char[495][18];\nvar TwistMove = Array(324);//new char[324][18];\nvar FlipMove = Array(336);//new char[336][18];\nvar UDSliceConj = Array(495);//new char[495][8];\nvar UDSliceTwistPrun = Array(495*324);//new byte[495 * 324];\nvar UDSliceFlipPrun = Array(495*336);//new byte[495 * 336];\n\t\nvar TwistFlipPrun = Array(336*324*8);//new byte[336 * 324 * 8];\n\t\n\t//phase1to2\nvar Mid3Move = Array(1320);//new char[1320][18];\nvar Mid32MPerm = Array(24);//new byte[24];\nvar CParity = Array(87);//new byte[2768/8];\n\n\t//phase2\nvar CPermMove = Array(2768);//new char[2768][18];\nvar EPermMove = Array(2768);//new char[2768][10];\nvar MPermMove = Array(24);//new byte[24][10];\nvar MPermConj = Array(24);//new byte[24][16];\nvar MCPermPrun = Array(24*2768);//new byte[24*2768];\nvar MEPermPrun = Array(24*2768);//new byte[24*2768];\n\n\nfunction CoordInit() {\n\tvar c = new CubieCube();\n\tvar d = new CubieCube();\n\tvar i, j;\n\tfor (i=0; i<2768; i++) {\n\t\tCPermMove[i] = Array(18);\n\t\tset8Perm(c.cp, CPermS2R[i]);\n\t\tfor (j=0; j<18; j++) {\n\t\t\tCornMult(c, moveCube[j], d);\n\t\t\tCPermMove[i][j] = d.getCPermSym();\n\t\t}\n\t}\t\t\n\tfor (i=0; i<2768; i++) {\n\t\tEPermMove[i] = Array(10);\n\t\tset8Perm(c.ep, EPermS2R[i]);\n\t\tfor (j=0; j<10; j++) {\n\t\t\tEdgeMult(c, moveCube[ud2std[j]], d);\n\t\t\tEPermMove[i][j] = d.getEPermSym();\n\t\t}\n\t}\n\tfor (i=0; i<336; i++) {\n\t\tFlipMove[i] = Array(18);\n\t\tc.setFlip(FlipS2R[i]);\n\t\tfor (j=0; j<18; j++) {\n\t\t\tEdgeMult(c, moveCube[j], d);\n\t\t\tFlipMove[i][j] = d.getFlipSym();\n\t\t}\n\t}\n\tfor (i=0; i<324; i++) {\n\t\tTwistMove[i] = Array(18);\n\t\tc.setTwist(TwistS2R[i]);\n\t\tfor (j=0; j<18; j++) {\n\t\t\tCornMult(c, moveCube[j], d);\n\t\t\tTwistMove[i][j] = d.getTwistSym();\n\t\t}\n\t}\n\tfor (i=0; i<495; i++) {\n\t\tUDSliceMove[i] = Array(18);\n\t\tc.setUDSlice(i);\n\t\tfor (j=0; j<18; j++) {\n\t\t\tEdgeMult(c, moveCube[j], d);\n\t\t\tUDSliceMove[i][j] = d.getUDSlice();\n\t\t}\n\t}\n\tfor (i=0; i<495; i++) {\n\t\tUDSliceConj[i] = Array(8);\n\t\tc.setUDSlice(i);\n\t\tfor (j=0; j<16; j+=2) {\n\t\t\tEdgeConjugate(c, SymInv[j], d);\n\t\t\tUDSliceConj[i][j>>>1] = d.getUDSlice();\n\t\t}\n\t}\n\tfor (i=0; i<1320; i++) {\n\t\tMid3Move[i] = Array(18);\n\t\tc.setMid3(i);\n\t\tfor (j=0; j<18; j++) {\n\t\t\tEdgeMult(c, moveCube[j], d);\n\t\t\tMid3Move[i][j] = d.getMid3();\n\t\t}\n\t}\t\n\tfor (i=0; i<24; i++) {\n\t\tc.setMPerm(i);\n\t\tMid32MPerm[c.getMid3() % 24] = i;\n\t}\n\tfor (i=0; i<2768; i++) {\n\t\tCParity[i>>>3] |= (get8Parity(CPermS2R[i])) << (i & 7);\n\t}\n\tfor (i=0; i<24; i++) {\n\t\tMPermMove[i] = Array(10);\n\t\tc.setMPerm(i);\n\t\tfor (j=0; j<10; j++) {\n\t\t\tEdgeMult(c, moveCube[ud2std[j]], d);\n\t\t\tMPermMove[i][j] = d.getMPerm();\n\t\t}\n\t}\t\t\n\tfor (i=0; i<24; i++) {\n\t\tMPermConj[i] = Array(16);\n\t\tc.setMPerm(i);\n\t\tfor (j=0; j<16; j++) {\n\t\t\tEdgeConjugate(c, SymInv[j], d);\n\t\t\tMPermConj[i][j] = d.getMPerm();\n\t\t}\n\t}\n\t\n\tvar SymState = Array(324);\n\tfor (i=0; i<324; i++) {\n\t\tc.setTwist(TwistS2R[i]);\n\t\tfor (var j=0; j<8; j++) {\n\t\t\tCornConjugate(c, j<<1, d);\n\t\t\tif (binarySearch(TwistS2R, d.getTwist()) != 0xffff) {\n\t\t\t\tSymState[i] |= (1 << j);\n\t\t\t}\n\t\t}\n\t}\n\tvar SymStateF = Array(324);\n\tfor (i=0; i<336; i++) {\n\t\tc.setFlip(FlipS2R[i]);\n\t\tfor (var j=0; j<8; j++) {\n\t\t\tEdgeConjugate(c, j<<1, d);\n\t\t\tif (binarySearch(FlipS2R, d.getFlip()) != 0xffff) {\n\t\t\t\tSymStateF[i] |= (1 << j);\n\t\t\t}\n\t\t}\n\t}\t\t\n\tfor (i=0; i<336*324*8; i++) {\n\t\tTwistFlipPrun[i] = -1;\n\t}\n\tfor (i=0; i<8; i++) {\n\t\tTwistFlipPrun[i] = 0;\n\t}\n\tvar depth = 0;\n\tvar done = 8;\n\tvar inv;\n\tvar select;\n\tvar check;\n\t\n\twhile (done < 336*324*8) {\n\t\tinv = depth > 6;\n\t\tselect = inv ? -1 : depth;\n\t\tcheck = inv ? depth : -1;\n\t\tdepth++;\n\t\tfor (i=0; i<336*324*8; i++) {\n\t\t\tif (TwistFlipPrun[i] != select)\n\t\t\t\tcontinue;\n\t\t\tvar twist = ~~(i / 2688);\n\t\t\tvar flip = i % 2688;\n\t\t\tvar fsym = i & 7;\n\t\t\tflip >>>= 3;\n\t\t\tfor (var m=0; m<18; m++) {\n\t\t\t\tvar twistx = TwistMove[twist][m];\n\t\t\t\tvar tsymx = twistx & 7;\n\t\t\t\ttwistx >>>= 3;\n\t\t\t\tvar flipx = FlipMove[flip][Sym8Move[fsym][m]];\n\t\t\t\tvar fsymx = Sym8MultInv[Sym8Mult[flipx & 7][fsym]][tsymx];\n\t\t\t\tflipx >>>= 3;\n\t\t\t\tvar idx = twistx * 2688 + (flipx << 3 | fsymx);\n\t\t\t\tif (TwistFlipPrun[idx] == check) {\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (inv) {\n\t\t\t\t\t\tTwistFlipPrun[i] = depth;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTwistFlipPrun[idx] = depth;\n\t\t\t\t\t\tvar sym = SymState[twistx];\n\t\t\t\t\t\tvar symF = SymStateF[flipx];\n\t\t\t\t\t\tif (sym != 1 || symF != 1) {\n\t\t\t\t\t\t\tfor (var j=0; j<8; j++, symF >>= 1) {\n\t\t\t\t\t\t\t\tif ((symF & 1) == 1) {\n\t\t\t\t\t\t\t\t\tvar fsymxx = Sym8MultInv[fsymx][j];\n\t\t\t\t\t\t\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\t\t\t\t\t\t\tif ((sym & (1 << k)) != 0) {\n\t\t\t\t\t\t\t\t\t\t\tvar idxx = twistx * 2688 + (flipx << 3 | Sym8MultInv[fsymxx][k]);\n\t\t\t\t\t\t\t\t\t\t\tif (TwistFlipPrun[idxx] == -1) {\n\t\t\t\t\t\t\t\t\t\t\t\tTwistFlipPrun[idxx] = depth;\n\t\t\t\t\t\t\t\t\t\t\t\tdone++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\tSystem.out.println(String.format(\"%2d%10d\", depth, done));\n\t}\n\tfor (i=0; i<495*324; i++) {\n\t\tUDSliceTwistPrun[i] = -1;\n\t}\n\tUDSliceTwistPrun[0] = 0;\n\tdepth = 0;\n\tdone = 1;\n\twhile (done < 495 * 324) {\n\t\tinv = depth > 6;\n\t\tselect = inv ? -1 : depth;\n\t\tcheck = inv ? depth : -1;\n\t\tdepth++;\n\t\tfor (i=0; i<495*324; i++) {\n\t\t\tif (UDSliceTwistPrun[i] == select) {\n\t\t\t\tvar slice = i % 495;\n\t\t\t\tvar twist = ~~(i / 495);\n\t\t\t\tfor (var m=0; m<18; m++) {\n\t\t\t\t\tvar twistx = TwistMove[twist][m];\n\t\t\t\t\tvar symx = twistx & 7;\n\t\t\t\t\tvar slicex = UDSliceConj[UDSliceMove[slice][m]][symx];\n\t\t\t\t\ttwistx >>>= 3;\n\t\t\t\t\tvar idx = twistx * 495 + slicex;\n\t\t\t\t\tif (UDSliceTwistPrun[idx] == check) {\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tif (inv) {\n\t\t\t\t\t\t\tUDSliceTwistPrun[i] = depth;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUDSliceTwistPrun[idx] = depth;\n\t\t\t\t\t\t\tvar sym = SymState[twistx];\n\t\t\t\t\t\t\tif (sym != 1) {\n\t\t\t\t\t\t\t\tfor (var j=1; j<8; j++) {\n\t\t\t\t\t\t\t\t\tsym >>= 1;\n\t\t\t\t\t\t\t\t\tif ((sym & 1) == 1) {\n\t\t\t\t\t\t\t\t\t\tvar idxx = twistx * 495 + UDSliceConj[slicex][j];\n\t\t\t\t\t\t\t\t\t\tif (UDSliceTwistPrun[idxx] == -1) {\n\t\t\t\t\t\t\t\t\t\t\tUDSliceTwistPrun[idxx] = depth;\n\t\t\t\t\t\t\t\t\t\t\tdone++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\tSystem.out.println(String.format(\"%2d%10d\", depth, done));\n\t}\t\t\n\n\tfor (i=0; i<495*336; i++) {\n\t\tUDSliceFlipPrun[i] = -1;\n\t}\n\tUDSliceFlipPrun[0] = 0;\n\tdepth = 0;\n\tdone = 1;\n\twhile (done < 495 * 336) {\n\t\tinv = depth > 6;\n\t\tselect = inv ? -1 : depth;\n\t\tcheck = inv ? depth : -1;\n\t\tdepth++;\n\t\tfor (i=0; i<495*336; i++) {\n\t\t\tif (UDSliceFlipPrun[i] == select) {\n\t\t\t\tvar slice = i % 495;\n\t\t\t\tvar flip = ~~(i / 495);\n\t\t\t\tfor (var m=0; m<18; m++) {\n\t\t\t\t\tvar flipx = FlipMove[flip][m];\n\t\t\t\t\tvar symx = flipx & 7;\n\t\t\t\t\tvar slicex = UDSliceConj[UDSliceMove[slice][m]][symx];\n\t\t\t\t\tflipx >>>= 3;\n\t\t\t\t\tvar idx = flipx * 495 + slicex;\n\t\t\t\t\tif (UDSliceFlipPrun[idx] == check) {\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tif (inv) {\n\t\t\t\t\t\t\tUDSliceFlipPrun[i] = depth;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUDSliceFlipPrun[idx] = depth;\n\t\t\t\t\t\t\tvar sym = SymStateF[flipx];\n\t\t\t\t\t\t\tif (sym != 1) {\n\t\t\t\t\t\t\t\tfor (var j=1; j<8; j++) {\n\t\t\t\t\t\t\t\t\tsym >>= 1;\n\t\t\t\t\t\t\t\t\tif ((sym & 1) == 1) {\n\t\t\t\t\t\t\t\t\t\tvar idxx = flipx * 495 + UDSliceConj[slicex][j];\n\t\t\t\t\t\t\t\t\t\tif (UDSliceFlipPrun[idxx] == -1) {\n\t\t\t\t\t\t\t\t\t\t\tUDSliceFlipPrun[idxx] = depth;\n\t\t\t\t\t\t\t\t\t\t\tdone++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\tdepth++;\n//\t\t\tSystem.out.println(String.format(\"%2d%10d\", depth, done));\n\t}\t\n\t\n\tSymState = Array(2768);\n\tfor (i=0; i<2768; i++) {\n\t\tset8Perm(c.ep, EPermS2R[i]);\n\t\tfor (j=1; j<16; j++) {\n\t\t\tEdgeConjugate(c, j, d);\n\t\t\tif (binarySearch(EPermS2R, get8Perm(d.ep)) != 0xffff) {\n\t\t\t\tSymState[i] |= (1 << j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i<24*2768; i++) {\n\t\tMEPermPrun[i] = -1;\n\t}\n\tMEPermPrun[0] = 0;\n\twhile (done < 24*2768) {\n\t\tinv = depth > 7;\n\t\tselect = inv ? -1 : depth;\n\t\tcheck = inv ? depth : -1;\n\t\tdepth++;\n\t\tfor (i=0; i<24*2768; i++) {\n\t\t\tif (MEPermPrun[i] == select) {\n\t\t\t\tvar mid = i % 24;\n\t\t\t\tvar edge = ~~(i / 24);\n\t\t\t\tfor (var m=0; m<10; m++) {\n\t\t\t\t\tvar edgex = EPermMove[edge][m];\n\t\t\t\t\tvar symx = edgex & 15;\n\t\t\t\t\tvar midx = MPermConj[MPermMove[mid][m]][symx];\n\t\t\t\t\tedgex >>>= 4;\n\t\t\t\t\tvar idx = edgex * 24 + midx;\n\t\t\t\t\tif (MEPermPrun[idx] == check) {\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tif (inv) {\n\t\t\t\t\t\t\tMEPermPrun[i] = depth;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tMEPermPrun[idx] = depth;\n\t\t\t\t\t\t\tvar sym = SymState[edgex];\n\t\t\t\t\t\t\tif (sym != 0) {\n\t\t\t\t\t\t\t\tfor (j=1; j<16; j++) {\n\t\t\t\t\t\t\t\t\tsym >>= 1;\n\t\t\t\t\t\t\t\t\tif ((sym & 1) == 1) {\n\t\t\t\t\t\t\t\t\t\tvar idxx = edgex * 24 + MPermConj[midx][j];\n\t\t\t\t\t\t\t\t\t\tif (MEPermPrun[idxx] == -1) {\n\t\t\t\t\t\t\t\t\t\t\tMEPermPrun[idxx] = depth;\n\t\t\t\t\t\t\t\t\t\t\tdone++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\tSystem.out.println(String.format(\"%2d%10d\", depth, done));\n\t}\t\t\n\t\t\n\tfor (i=0; i<24*2768; i++) {\n\t\tMCPermPrun[i] = -1;\n\t}\n\tMCPermPrun[0] = 0;\n\tdepth = 0;\n\tdone = 1;\n\twhile (done < 24*2768) {\n\t\tinv = depth > 7;\n\t\tselect = inv ? -1 : depth;\n\t\tcheck = inv ? depth : -1;\n\t\tdepth++;\n\t\tfor (i=0; i<24*2768; i++) {\n\t\t\tif (MCPermPrun[i] == select) {\n\t\t\t\tvar mid = i % 24;\n\t\t\t\tvar corn = ~~(i / 24);\n\t\t\t\tfor (var m=0; m<10; m++) {\n\t\t\t\t\tvar cornx = CPermMove[corn][ud2std[m]];\n\t\t\t\t\tvar symx = (cornx & 15);\n\t\t\t\t\tvar midx = MPermConj[MPermMove[mid][m]][symx];\n\t\t\t\t\tcornx >>>= 4;\n\t\t\t\t\tvar idx = cornx * 24 + midx;\n\t\t\t\t\tif (MCPermPrun[idx] == check) {\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tif (inv) {\n\t\t\t\t\t\t\tMCPermPrun[i] = depth;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tMCPermPrun[idx] = depth;\n\t\t\t\t\t\t\tvar sym = SymState[cornx];\n\t\t\t\t\t\t\tif (sym != 0) {\n\t\t\t\t\t\t\t\tfor (j=1; j<16; j++) {\n\t\t\t\t\t\t\t\t\tsym >>= 1;\n\t\t\t\t\t\t\t\t\tif ((sym & 1) == 1) {\n\t\t\t\t\t\t\t\t\t\tvar idxx = cornx * 24 + MPermConj[midx][j ^ e2c[j]];\n\t\t\t\t\t\t\t\t\t\tif (MCPermPrun[idxx] == -1) {\n\t\t\t\t\t\t\t\t\t\t\tMCPermPrun[idxx] = depth;\n\t\t\t\t\t\t\t\t\t\t\tdone++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\tSystem.out.println(String.format(\"%2d%10d\", depth, done));\n\t}\n}\t\t\t\t\t\n\nfunction randomCube() {\n\tvar eperm;\n\tvar cperm;\n\tdo {\n\t\teperm = ~~(Math.random() * 479001600);\n\t\tcperm = ~~(Math.random() * 40320);\n\t} while (((get8Parity(cperm) ^ get12Parity(eperm))) != 0);\n\tvar c = new CubieCube();\n\tc.init(cperm, ~~(Math.random() * 2187), eperm, ~~(Math.random() * 2048));\n\treturn c;\n}\n\nvar move = Array(31);\n\nvar corn = Array(20);\nvar csym = Array(20);\nvar mid3 = Array(20);\nvar e1 = Array(20);\nvar e2 = Array(20);\nvar urfidx;\n\nvar twist = Array(6);\nvar tsym = Array(6);\nvar flip = Array(6);\nvar fsym = Array(6);\nvar slice = Array(6);\nvar corn0 = Array(6);\nvar csym0 = Array(6);\nvar mid30 = Array(6);\nvar e10 = Array(6);\nvar e20 = Array(6);\nvar prun = Array(6);\n\nvar length1 = 0;\nvar maxlength2 = 0;\nvar sol = 999;\nvar valid1 = 0;\nvar valid2 = 0;\nvar solution = \"\";\nvar useSeparator = false;\n\nfunction Solve(c) {\n\tc.temps = new CubieCube();\n\tfor (var i=0; i<6; i++) {\n\t\ttwist[i] = c.getTwistSym();\n\t\ttsym[i] = twist[i] & 7;\n\t\ttwist[i] >>>= 3;\n\t\tflip[i] = c.getFlipSym();\n\t\tfsym[i] = flip[i] & 7;\n\t\tflip[i] >>>= 3;\n\t\tslice[i] = c.getUDSlice();\n\t\tcorn0[i] = c.getCPermSym();\n\t\tcsym0[i] = corn0[i] & 15;\n\t\tcorn0[i] >>>= 4;\n\t\tmid30[i] = c.getMid3();\n\t\te10[i] = c.getURtoUL();\n\t\te20[i] = c.getDRtoDL();\n\t\tprun[i] = Math.max(Math.max(UDSliceTwistPrun[twist[i] * 495 + UDSliceConj[slice[i]][tsym[i]]],\n\t\t\t\t\t\tUDSliceFlipPrun[flip[i] * 495 + UDSliceConj[slice[i]][fsym[i]]]),\n\t\t\t\t\t\tTwistFlipPrun[twist[i] * 2688 + (flip[i] << 3 | Sym8MultInv[fsym[i]][tsym[i]])]);\n\t\tc.URFConjugate();\n\t\tif (i==2) {\n\t\t\tc.invCubieCube();\n\t\t}\n\t}\n\tsolution = null;\n\tsol = 22;\n\tfor (length1=0; length1<sol; length1++) {\n\t\tmaxlength2 = Math.min(sol/2+1, sol-length1);\n\t\tfor (urfidx=0; urfidx<6; urfidx++) {\n\t\t\tcorn[0] = corn0[urfidx];\n\t\t\tcsym[0] = csym0[urfidx];\n\t\t\tmid3[0] = mid30[urfidx];\n\t\t\te1[0] = e10[urfidx];\n\t\t\te2[0] = e20[urfidx];\n\t\t\tif ((prun[urfidx] <= length1)\n\t\t\t\t\t&& phase1(twist[urfidx], tsym[urfidx], flip[urfidx], fsym[urfidx],\n\t\t\t\t\t\t\t\tslice[urfidx], length1, 18)) {\n\t\t\t\tif (solution == null) {\n\t\t\t\t\treturn \"Error 8\";\n\t\t\t\t} else {\n\t\t\t\t\treturn solution;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"Error 7\";\n}\n\nfunction phase1(twist, tsym, flip, fsym, slice, maxl, lm) {\n\tif (twist==0 && flip==0 && slice==0 && maxl < 5) {\n\t\treturn maxl == 0 && init2();\n\t}\n\tfor (var m=0; m<18; m++) {\n\t\tif (ckmv[lm][m]) {\n\t\t\tm+=2;\n\t\t\tcontinue;\n\t\t}\n\t\tvar slicex = UDSliceMove[slice][m];\n\t\tvar twistx = TwistMove[twist][Sym8Move[tsym][m]];\n\t\tvar tsymx = Sym8Mult[twistx & 7][tsym];\n\t\ttwistx >>>= 3;\n\t\tif (UDSliceTwistPrun[twistx * 495 + UDSliceConj[slicex][tsymx]] >= maxl) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar flipx = FlipMove[flip][Sym8Move[fsym][m]];\n\t\tvar fsymx = Sym8Mult[flipx & 7][fsym];\n\t\tflipx >>>= 3;\n\t\tif (TwistFlipPrun[twistx * 2688 + (flipx << 3 | Sym8MultInv[fsymx][tsymx])] >= maxl\n\t\t\t\t||UDSliceFlipPrun[flipx * 495 + UDSliceConj[slicex][fsymx]] >= maxl) {\n\t\t\tcontinue;\n\t\t}\n\t\tmove[length1-maxl] = m;\n\t\tvalid1 = Math.min(valid1, length1-maxl);\n\t\tif (phase1(twistx, tsymx, flipx, fsymx, slicex, maxl-1, m)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction init2() {\n//\tif (System.currentTimeMillis() > timeOut) {\n//\t\treturn true;\n//\t}\n\tvalid2 = Math.min(valid2, valid1);\n\tfor (var i=valid1; i<length1; i++) {\n\t\tvar m = move[i];\n\t\tcorn[i+1] = CPermMove[corn[i]][SymMove[csym[i]][m]];\n\t\tcsym[i+1] = SymMult[corn[i+1] & 15][csym[i]];\n\t\tcorn[i+1] >>>= 4;\n\t\tmid3[i+1] = Mid3Move[mid3[i]][m];\n\t}\n\tvalid1 = length1;\n\tvar mid = Mid32MPerm[mid3[length1] % 24];\n\tvar prun = MCPermPrun[corn[length1] * 24 + MPermConj[mid][csym[length1]]];\n\tif (prun >= maxlength2) {\n\t\treturn false;\n\t}\n\tfor (var i=valid2; i<length1; i++) {\n\t\te1[i+1] = Mid3Move[e1[i]][move[i]];\n\t\te2[i+1] = Mid3Move[e2[i]][move[i]];\n\t}\n\tvalid2 = length1;\n\tvar cornx = corn[length1];\n\tvar ex = merge[~~(e1[length1]/6)][~~(e2[length1]/6)] * 4032\n\t\t\t\t + e1[length1] * 12 + e2[length1] % 6 * 2 + (((CParity[cornx>>>3]>>>(cornx&7))&1) ^ get4Parity(mid));\n\tvar edge = MtoEPerm[ex];\n\tvar esym = edge & 15;\n\tedge >>>= 4;\n\t\tprun = Math.max(MEPermPrun[edge * 24 + MPermConj[mid][esym]], prun);\n\tif (prun >= maxlength2) {\n\t\treturn false;\n\t}\n\t\tvar lm = length1==0 ? 10 : std2ud[~~(move[length1-1]/3)*3+1];\n\tfor (var i=prun; i<maxlength2; i++) {\n\t\tif (phase2(edge, esym, corn[length1], csym[length1], mid, i, length1, lm)) {\n\t\t\tsol = length1 + i;\n\t\t\tvar sb = \"\";\n\t\t\tvar urf = urfidx;\n//\t\t\tif (inverse) {\n\t\t\t\turf = (urf + 3) % 6;\n//\t\t\t}\n\t\t\tif (urf < 3) {\n\t\t\t\tfor (var s=0; s<length1; s++) {\n\t\t\t\t\tsb += move2str[urfMove[urf][move[s]]] + ' ';\n\t\t\t\t}\n\t\t\t\tfor (var s=length1; s<sol; s++) {\n\t\t\t\t\tsb += move2str[urfMove[urf][move[s]]] + ' ';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var s=sol-1; s>=length1; s--) {\n\t\t\t\t\tsb += move2str[urfMove[urf][move[s]]] + ' ';\n\t\t\t\t}\n\t\t\t\tfor (var s=length1-1; s>=0; s--) {\n\t\t\t\t\tsb += move2str[urfMove[urf][move[s]]] + ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// sb += \"(\" + sol + \"f)\";\n\t\t\tsolution = sb;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction phase2(edge, esym, corn, csym, mid, maxl, depth, lm) {\n\tif (edge==0 && corn==0 && mid==0) {\n\t\treturn true;\n\t}\n\tfor (var m=0; m<10; m++) {\n\t\tif (ckmv2[lm][m]) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar midx = MPermMove[mid][m];\n\t\tvar edgex = EPermMove[edge][SymMoveUD[esym][m]];\n\t\tvar esymx = SymMult[edgex & 15][esym];\n\t\tedgex >>>= 4;\n\t\tif (MEPermPrun[edgex * 24 + MPermConj[midx][esymx]] >= maxl) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar cornx = CPermMove[corn][SymMove[csym][ud2std[m]]];\n\t\tvar csymx = SymMult[cornx & 15][csym];\n\t\tcornx >>>= 4;\n\t\tif (MCPermPrun[cornx * 24 + MPermConj[midx][csymx]] >= maxl) {\n\t\t\tcontinue;\n\t\t}\n\t\tmove[depth] = ud2std[m];\n\t\tif (phase2(edgex, esymx, cornx, csymx, midx, maxl-1, depth+1, m)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvar initialized = false;\n\nfunction initialize() {\n\tif (initialized) {\n\t\treturn;\n\t}\n\tCubieInit();\n\tCoordInit();\n\tinitialized = true;\n}\n\nfunction solve(c) {\n\tinitialize();\n\tconst cc = new CubieCube();\n\tcc.cp = c.cp;\n\tcc.co = c.co;\n\tcc.ep = c.ep;\n\tcc.eo = c.eo;\n\treturn Solve(cc);\n};\n\nmodule.exports.initialize = initialize;\nmodule.exports.solve = solve;\nmodule.exports.randomCube = randomCube;\n","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \\_()_/\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didnt happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","export enum Face {\n    U = 0, D, F, B, L, R, X\n}\n\nconst U = Face.U;\nconst D = Face.D;\nconst F = Face.F;\nconst B = Face.B;\nconst L = Face.L;\nconst R = Face.R;\nexport {U, D, F, B, L, R};\n\nexport enum Typ {\n    C = 0, E, T\n}\nconst C = Typ.C;\nconst E = Typ.E;\nconst T = Typ.T;\nexport {C, E, T}\n\nexport type CubieT = {\n    co: Array<number>,\n    cp: Array<number>,\n    eo: Array<number>,\n    ep: Array<number>,\n    tp: Array<number>\n}\n\nexport type FaceletCube = Array<string>\n\nexport type CornerCoord = [Face, Face, Face]\nlet corners_coord : Array<CornerCoord> = [\n    [U,F,L], [U,L,B], [U,B,R], [U,R,F],\n    [D,L,F], [D,B,L], [D,R,B], [D,F,R]\n]\n\nexport type EdgeCoord = [Face, Face]\nlet edges_coord : Array<EdgeCoord> = [\n    [U,F], [U,L], [U,B], [U,R],\n    [D,F], [D,L], [D,B], [D,R],\n    [F,L], [B,L], [B,R], [F,R],\n]\nexport type CenterCoord = [Face]\nlet centers_coord : Array<CenterCoord> = [\n    [U], [D], [F], [B], [L], [R]\n]\n\nlet cstimer_corners_coord : Array<CornerCoord> = [\n    [U,R,F],[U,F,L], [U,L,B], [U,B,R],\n    [D,F,R],[D,L,F], [D,B,L], [D,R,B]\n]\n\nlet cstimer_edges_coord : Array<EdgeCoord> = [\n    [U, R], [U,F], [U,L], [U,B],\n    [D, R], [D,F], [D,L], [D,B],\n    [F, R], [F,L], [B,L], [B,R]\n]\n\nexport {corners_coord, edges_coord, centers_coord, cstimer_corners_coord, cstimer_edges_coord }\n\nexport type FaceletMapping = [Face[], Face[]][]\n\nexport type PermChg = [number, number]\nexport type OriChg = number\n\nexport type MoveT = {\n    cpc: Array<PermChg>,\n    coc: Array<OriChg>,\n    epc: Array<PermChg>,\n    eoc: Array<OriChg>,\n    tpc: Array<PermChg>,\n    name: string\n}\n\nlet u : MoveT = {\n    cpc: [[0, 1], [1, 2], [2, 3], [3, 0]],\n    coc: [0, 0, 0, 0],\n    epc: [[0, 1], [1, 2], [2, 3], [3, 0]],\n    eoc: [0, 0, 0, 0],\n    tpc: [],\n    name: \"U\"\n}\n\nlet f : MoveT = {\n    cpc: [[0, 3], [3, 7], [7, 4], [4, 0]],\n    coc: [1, 2, 1, 2],\n    epc: [[0, 11], [11, 4], [4, 8], [8, 0]],\n    eoc: [1, 1, 1, 1],\n    tpc: [],\n    name: \"F\",\n}\n\nlet r : MoveT = {\n    cpc: [[3, 2], [2, 6], [6, 7], [7, 3]],\n    coc: [1, 2, 1, 2],\n    epc: [[3, 10], [10, 7], [7, 11], [11, 3]],\n    eoc: [0, 0, 0, 0],\n    tpc: [],\n    name: \"R\",\n}\n\nlet l : MoveT = {\n    cpc: [[0, 4], [4, 5], [5, 1], [1, 0]],\n    coc: [2, 1, 2, 1],\n    epc: [[1, 8], [8, 5], [5, 9], [9, 1]],\n    eoc: [0, 0, 0, 0],\n    tpc: [],\n    name: \"L\",\n}\n\nlet d : MoveT = {\n    cpc: [[4, 7], [7, 6], [6, 5], [5, 4]],\n    coc: [0, 0, 0, 0],\n    epc: [[4, 7], [7, 6], [6, 5], [5, 4]],\n    eoc: [0, 0, 0, 0],\n    tpc: [],\n    name: \"D\",\n}\n\nlet b : MoveT = {\n    cpc: [[1, 5], [5, 6], [6, 2], [2, 1]],\n    coc: [2, 1, 2, 1],\n    epc: [[2, 9], [9, 6], [6, 10], [10, 2]],\n    eoc: [1, 1, 1, 1],\n    tpc: [],\n    name: \"B\",\n}\n\nlet m : MoveT = {\n    cpc: [],\n    coc: [],\n    epc: [[0, 4], [4, 6], [6, 2], [2, 0]],\n    eoc: [1, 1, 1, 1],\n    tpc: [[0, 2], [2, 1], [1, 3], [3, 0]],\n    name: \"M\",\n}\n\nlet e : MoveT = {\n    cpc: [],\n    coc: [],\n    epc: [[8, 9], [9, 10], [10, 11], [11, 8]],\n    eoc: [1, 1, 1, 1],\n    tpc: [[2, 4], [4, 3], [3, 5], [5, 2]],\n    name: \"E\",\n}\n\nlet s : MoveT = {\n    cpc: [],\n    coc: [],\n    epc: [[1, 3], [3, 7], [7, 5], [5, 1]],\n    eoc: [1, 1, 1, 1],\n    tpc: [[0, 5], [5, 1], [1, 4], [4, 0] ],\n    name: \"S\",\n}\n\nexport {u, d, f, b, l, r, m, e, s}\n\nexport type StickerT = [number, number, Typ]\nexport type StickerExtT = [number, number, Typ, Face]\nexport type FaceletT = Array<StickerT>\n\nlet u_face : FaceletT = [\n    [1, 0, C], [2, 0, E], [2, 0, C],\n    [1, 0, E], [0, 0, T], [3, 0, E],\n    [0, 0, C], [0, 0, E], [3, 0, C]\n  ]\n\nlet f_face : FaceletT = [\n    [0, 1, C], [0, 1, E], [3, 2, C],\n    [8, 0, E], [2, 0, T], [11,0, E],\n    [4, 2, C], [4, 1, E], [7, 1, C]\n]\n\nexport {u_face, f_face}\n\n// for solved back-FS, ignore CP=5 and C=(1,0)\n// for solved front-FS, ignore CP=4 and C=(0,0)\nconst FBpairPosBackFS : [number, number, number, number][] = [\n    [0, 0, 8, 1], [0, 1, 1, 0], [ 0, 2 , 0, 1],\n    // [1, 0, 9, 1],\n    [1, 1, 2, 0], [1, 2, 1, 1],\n    [2, 0, 10, 1], [2, 1, 3, 0], [2, 2, 2, 1],\n    [3, 0, 11, 0], [3, 1, 0, 0], [3, 2, 3, 1],\n    //[4, 0, 8, 0], \n    [4, 1, 4, 0],\n    // [5, 0, 9, 0], [5, 2, 6, 0],\n    [6, 0, 10, 0], [6, 1, 6, 0], [6, 2, 7, 1],\n    [7, 0, 11, 1], [7, 1, 7, 0], [7, 2, 4, 1]\n]\n// Reason for failing: sampling the solved state would crash our solver, which refuses to expand solution on solved state\nconst FBpairPosFrontFS : [number, number, number, number][] = [\n    //[0, 0, 8, 0], \n    [0, 1, 1, 1], [0, 2, 0, 0],\n    [1, 0, 9, 1], [1, 1, 2, 1], [1, 2, 1, 0],\n    [2, 0, 10, 0], [2, 1, 3, 1], [2, 2, 2, 0],\n    [3, 0, 11, 1], [3, 1, 0, 1], [3, 2, 3, 0],\n    //[4, 0, 8, 1], [4, 1, 4, 1],\n    //[5, 0, 9, 0], \n    [5, 2, 6, 0],\n    [6, 0, 10, 1], [6, 1, 6, 1], [6, 2, 7, 0],\n    [7, 0, 11, 0], [7, 1, 7, 1], [7, 2, 4, 0]\n]\n\nexport {FBpairPosBackFS, FBpairPosFrontFS}\n\nexport type FaceletCubeT = Array<Array<Face>>\n\n// A Cube can be in two representations: cubieCube or faceletCube\n\nlet color_map =`\\\n   UUU\n   UUU\n   UUU\nLLLFFFRRRBBB\nLLLFFFRRRBBB\nLLLFFFRRRBBB\n   DDD\n   DDD\n   DDD`\n\nexport {color_map}\n","let rand_int = (r: number) => {\n    return Math.floor(Math.random() * r)\n}\n\nlet rand_incl = (l: number, r: number) => {\n    return rand_int(r - l + 1) + l;\n}\nlet rand_choice = function<T>(arr: T[]) {\n    return arr[rand_int(arr.length)]\n}\n\nlet rand_shuffle = function<T>(arr: T[]) {\n    for (let i = 0, l = arr.length; i < l - 1; i++) {\n        let j = rand_incl(i, l - 1)\n        let tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp\n    }\n    return arr\n}\n\nfunction cartesianProduct<T>(...allEntries: T[][]): T[][] {\n    return allEntries.reduce<T[][]>(\n      (results, entries) =>\n        results\n          .map(result => entries.map(entry => result.concat([entry])))\n          .reduce((subResults, result) => subResults.concat(result), []),\n      [[]]\n    )\n  }\n\nlet getParity = (perm: number[]) => {\n    let visited = Array(perm.length).fill(false)\n    let follow = (i: number, cnt: number) : number => {\n        if (visited[i]) {\n            return 0\n        } else {\n            visited[i] = 1\n            if (visited[perm[i]]) {\n                return cnt;\n            } else\n                return follow(perm[i], cnt + 1)\n        }\n    }\n    let res = 0\n    for (let x of perm) {\n        res += follow(x, 0)\n    }\n    return res\n}\n\nlet arrayEqual = function<T>(arr1: T[], arr2: T[]) {\n    if (arr1.length !== arr2.length) return false;\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) return false;\n    }\n    return true;\n}\n\nlet encodeArr = function(base: number, rarr: number[]) {\n    let int = 0\n    for (let i = rarr.length - 1; i >= 0; i--)\n        int = rarr[i] + int * base\n    return int\n}\n\nexport {rand_int, rand_choice, rand_shuffle, getParity, arrayEqual, encodeArr, cartesianProduct}","import { MoveT, OriChg, PermChg, StickerT, StickerExtT, CornerCoord, EdgeCoord, cstimer_corners_coord, cstimer_edges_coord, CenterCoord, centers_coord } from \"./Defs\";\nimport { u, d, f, b, l, r, m, e, s} from \"./Defs\";\nimport { FaceletT, FaceletCubeT, corners_coord, edges_coord, u_face, f_face, color_map } from \"./Defs\";\nimport { Typ, Face, C, E, T, U, D, F, B, L, R } from \"./Defs\";\nimport { rand_int, rand_shuffle, getParity, rand_choice, arrayEqual } from \"./Math\";\n\nconst C_MOD = 3;\nconst E_MOD = 2;\nconst T_MOD = 1;\n\nexport class CubieCube {\n    cp: number[] = [];\n    co: number[] = [];\n    ep: number[] = [];\n    eo: number[] = [];\n    tp: number[] = [];\n    // The addition of tp is not necessary, but helps us deal with slice moves in Roux during search and simcube.\n    deserialize(s: string) {\n        let obj = JSON.parse(s)\n        this.set(obj);\n        return this\n    }\n    serialize() {\n        let {cp, co, ep, eo, tp} = this\n        return JSON.stringify({cp, co, ep, eo, tp});\n    }\n\n    Id() : CubieCube {\n        this.set({\n            cp: [0, 1, 2, 3, 4, 5, 6, 7],\n            co: [0, 0, 0, 0, 0, 0, 0, 0],\n            ep: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n            eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            tp: [0, 1, 2, 3, 4, 5]\n        })\n        return this\n    }\n    clone() : CubieCube {\n        return new CubieCube({\n            cp: [...this.cp],\n            co: [...this.co],\n            ep: [...this.ep],\n            eo: [...this.eo],\n            tp: [...this.tp]\n        })\n    }\n    constructor(value?: {cp: number[], co: number[], ep: number[], eo: number[], tp?: number[]} | CubieCube) {\n        if (value instanceof CubieCube) {\n            this.set({\n                cp: value.cp, co: value.co, ep: value.ep, eo: value.eo, tp: value.tp\n            })\n        }\n        else if (value) {\n            this.cp = value.cp\n            this.co = value.co\n            this.ep = value.ep\n            this.eo = value.eo\n            this.tp = value.tp || [0, 1, 2, 3, 4, 5] // UD FB LR\n        } else {\n            this.Id()\n        }\n    }\n    set(value: {cp?: number[], co?: number[], ep?: number[], eo?: number[], tp?: number[]} | CubieCube) {\n        this.cp = value.cp || this.cp\n        this.co = value.co || this.co\n        this.ep = value.ep || this.ep\n        this.eo = value.eo || this.eo\n        this.tp = value.tp || this.tp\n    }\n    _apply_partial(o: Array<number>, p: Array<number>, oc: Array<OriChg>, pc: Array<PermChg>, mod: number) {\n        let o_new = [...o];\n        let p_new = [...p];\n\n        for (let i = 0; i < oc.length; i++) {\n            //let [src, dst] = pc[i];\n            let src = pc[i][0], dst = pc[i][1];\n            p_new[dst] = p[src];\n            o_new[dst] = (o[src] + oc[i]) % mod;\n        }\n        return [o_new, p_new]\n    }\n    _apply_partial_perm(p: Array<number>, pc: Array<PermChg>, mod: number) {\n        let p_new = [...p];\n\n        for (let i = 0; i < pc.length; i++) {\n            //let [src, dst] = pc[i];\n            let src = pc[i][0], dst = pc[i][1];\n            p_new[dst] = p[src];\n        }\n        return p_new\n    }\n\n    // all side-effect-less\n    apply_one(move: Move) {\n        let [co, cp] = this._apply_partial(this.co, this.cp, move.coc, move.cpc, C_MOD)\n        let [eo, ep] = this._apply_partial(this.eo, this.ep, move.eoc, move.epc, E_MOD)\n        let tp = this._apply_partial_perm(this.tp, move.tpc, T_MOD)\n        return new CubieCube({ co, cp, eo, ep, tp })\n    }\n\n    static generate_apply_partial_func_perm(pc: Array<PermChg>, mod: number, p: string) {\n        return `\n        let ${p}_new = [...${p}];\n        src = 0, dst = 0;\n        ${Array(pc.length).fill(0).map( (_, i) => {\n            let src = pc[i][0], dst = pc[i][1];\n            return `\n                ${p}_new[${dst}] =  ${p}[${src}];\n            `\n        }).join(\"\\n\")}\n        // return [ ${p}_new]\n        `\n    }\n    static generate_apply_partial_func(oc: Array<OriChg>, pc: Array<PermChg>, mod: number, o: string, p: string) {\n        return `\n        let ${o}_new = [...${o}];\n        let ${p}_new = [...${p}];\n        src = 0, dst = 0;\n        ${Array(oc.length).fill(0).map( (_, i) => {\n            let src = pc[i][0], dst = pc[i][1], ori = oc[i];\n            return `\n                ${p}_new[${dst}] =  ${p}[${src}];\n                ${o}_new[${dst}] = (${o}[${src}] + ${ori}) % ${mod};\n            `\n        }).join(\"\\n\")}\n        // return [${o}_new, ${p}_new]\n        `\n    }\n    static generate_apply_func(move: Move) : (c: CubieCube) => CubieCube {\n        // eslint-disable-next-line no-new-func\n        return new Function(\"cube\", `\n        let {co, cp, eo, ep, tp} = cube;\n        ${CubieCube.generate_apply_partial_func(move.coc, move.cpc, C_MOD, \"co\", \"cp\")}\n        ${CubieCube.generate_apply_partial_func(move.eoc, move.epc, E_MOD, \"eo\", \"ep\")}\n        ${CubieCube.generate_apply_partial_func_perm(move.tpc, T_MOD, \"tp\")}\n        return ({ co: co_new, cp: cp_new, eo: eo_new,\n            ep: ep_new, tp: tp_new })\n        `) as (c: CubieCube) => CubieCube\n    }\n\n    apply(move: Move | Array<Move> | MoveSeq | string): CubieCube {\n        if (Array.isArray(move) || move instanceof MoveSeq) {\n            let moves = Array.isArray(move) ? move : move.moves\n            let cube = this.clone()\n            for (let i = 0; i < moves.length; i++) {\n                cube = cube.apply_one(moves[i])\n            }\n            return cube\n        } else if (typeof move === \"string\") {\n            return this.apply(new MoveSeq(move))\n        }\n        else {\n            return this.apply_one(move)\n        }\n    }\n\n    static _rotate_coord(fs: Face[]) {\n        let faces = [...fs] as Face[]\n        let last_face = faces[faces.length - 1];\n        for (let i = faces.length - 1; i > 0; i--) {\n            faces[i] = faces[i - 1];\n        }\n        faces[0] = last_face\n        return faces\n    }\n    static _backward_rotate_coord(fs: Face[]){\n        let faces = [...fs] as Face[]\n        let first_face = faces[0]\n        for (let i = 0; i < faces.length - 1; i++) {\n            faces[i] = faces[i + 1];\n        }\n        faces[faces.length - 1] = first_face\n        return faces\n    }\n\n    // facelet mapping: from position to piece\n    _to_facelet_mapping(corners_coord: CornerCoord[], edges_coord: EdgeCoord[], centers_coord: CenterCoord[]) {\n        let facelet_mapping : [Face[], Face[]][]= []\n\n        for (let i = 0; i < 8; i++) {\n            let pos = corners_coord[i] as Face[]\n            let piece = corners_coord[this.cp[i]] as Face[]\n\n            for (let j = 0; j < this.co[i];j++) {\n                piece = CubieCube._rotate_coord(piece)\n            }\n            facelet_mapping.push([pos, piece])\n        }\n        for (let i = 0; i < 12; i++) {\n            let pos = edges_coord[i] as Face[]\n            let piece = edges_coord[this.ep[i]] as Face[]\n            for (let j = 0; j < this.eo[i];j++) {\n                piece = CubieCube._rotate_coord(piece)\n            }\n            facelet_mapping.push([pos, piece])\n        }\n        for (let i = 0; i<6;i++) {\n            let pos = centers_coord[i]\n            let piece = centers_coord[this.tp[i]] as Face[]\n            facelet_mapping.push([ pos, piece])\n        }\n        return facelet_mapping\n    }\n\n    _from_facelet_mapping (fm: [Face[], Face[]][], custom_corners_coord: CornerCoord[], custom_edges_coord: EdgeCoord[], custom_centers_coord: CenterCoord[] ) {\n        let cube = new CubieCube()\n\n        let match_pos_piece = (pos: Face[], piece: Face[], coord: Face[][], parity: number) : [number, number, number]=> {\n            let expected = new Map(coord.map( (x, i) => [x.toString(), i]))\n            let ori = 0\n            while (!expected.has(pos.toString())) {\n                pos = CubieCube._backward_rotate_coord(pos)\n                ori--;\n                if (ori <= -parity) break;\n            }\n            while (!expected.has(piece.toString())) {\n                piece = CubieCube._backward_rotate_coord(piece)\n\n                ori++;\n                if (ori >= 10) {\n                    console.warn(\"can't match piece\", piece, expected)\n                    break\n                }\n            }\n\n            ori = (ori + parity) % parity;\n            return [ori, expected.get(pos.toString())!, expected.get(piece.toString())! ]\n        }\n\n        for (let coord_pair of fm) {\n            let pos = coord_pair[0], piece = coord_pair[1]\n            let coord : Face[][] = (pos.length === 2) ? custom_edges_coord :\n                        (pos.length === 3) ? custom_corners_coord :\n                         custom_centers_coord ;\n            let [newOri,newpos,newPerm] = match_pos_piece(pos, piece, coord, pos.length);\n\n            //console.log( pp([pos, piece]), [newOri, newpos,newPerm])\n            if (pos.length === 2) {\n                cube.eo[newpos] = newOri;\n                cube.ep[newpos] = newPerm;\n            } else if (pos.length === 3){\n                cube.co[newpos] = newOri;\n                cube.cp[newpos] = newPerm;\n            } else {\n                cube.tp[newpos] = newPerm;\n            }\n        }\n        return cube\n    }\n\n    to_cstimer_cube() {\n        let facelet_mapping = this._to_facelet_mapping(corners_coord, edges_coord, centers_coord)\n        let cube = this._from_facelet_mapping(facelet_mapping, cstimer_corners_coord, cstimer_edges_coord, centers_coord)\n        return cube\n    }\n\n    is_solveable() {\n        if (this.tp[0] !== 0) {\n            this.apply(new MoveSeq(\"M2\")) // assuming lse\n        }\n        let perm_correct = (getParity(this.cp) + getParity(this.ep)) % 2 === 0\n        let ori_correct = (this.co.reduce((x, y) => x + y, 0) % 3 === 0) && (this.eo.reduce((x, y) => x + y, 0) % 2 === 0)\n        return perm_correct && ori_correct\n    }\n\n    changeBasis(s: MoveSeq) {\n        // only take x and y for now\n        let facelet_mapping = this._to_facelet_mapping(corners_coord, edges_coord, centers_coord)\n\n        let transformed_mapping = s.moves.reduce( (mapping, move) : [Face[], Face[]][] => {\n            let face_mapping = Object.fromEntries(move.tpc)\n            //console.log(\"applying face mapping for \", move.name, face_mapping)\n            //console.log(\"before\", pp(mapping))\n            let result = mapping.map( ([face_pos, face_target]) =>\n                [face_pos.map(f => face_mapping[f] ?? f ),\n                 face_target.map(f => face_mapping[f] ?? f) ]\n            )\n            //console.log('after', pp(result))\n            return result as any\n        } , facelet_mapping)\n        //console.log(s.toString(), facelet_mapping, transformed_mapping)\n        let cube = this._from_facelet_mapping(transformed_mapping, corners_coord, edges_coord, centers_coord)\n        return cube\n        //let cube = this._from_facelet_mapping(facelet_mapping, corners_coord, edges_coord, centers_coord)\n    }\n}\n\n\n/* Moves */\n/* We will generate all the moves based on the base moves and rotations, and return them in an array */\nexport class Move {\n    cpc: Array<PermChg> = [];\n    coc: Array<OriChg> = [];\n    epc: Array<PermChg> = [];\n    eoc: Array<OriChg> = [];\n    tpc: Array<PermChg> = [];\n    name: string = \"\";\n    constructor(arg?: Array<Move> | CubieCube | Move | MoveT, name?: string) {\n        if (Array.isArray(arg)) {\n            this.from_moves(arg, name!)\n        } else if (arg instanceof Move){\n            this.cpc = [...arg.cpc]\n            this.coc = [...arg.coc]\n            this.epc = [...arg.epc]\n            this.eoc = [...arg.eoc]\n            this.tpc = [...arg.tpc]\n            this.name = name!\n        } else if (arg instanceof CubieCube) {\n            this.from_cube(arg, name!)\n        } else if (arg) {\n            this.set(arg)\n        }\n    }\n    set(move: Move | MoveT) {\n        this.cpc = move.cpc\n        this.coc = move.coc\n        this.epc = move.epc\n        this.eoc = move.eoc\n        this.tpc = move.tpc\n        this.name = move.name\n    }\n    from_cube(cube: CubieCube, name: string) {\n        let get_change = (p: Array<number>, o: Array<number>, acc_p: Array<PermChg>, acc_o: Array<OriChg>) => {\n            for (let i = 0; i < p.length; i++) {\n                if (i === p[i] && o[i] === 0) {\n                } else {\n                    acc_p.push([p[i], i]);\n                    acc_o.push(o[i]);\n                }\n            }\n        }\n        get_change(cube.cp, cube.co, this.cpc, this.coc);\n        get_change(cube.ep, cube.eo, this.epc, this.eoc);\n        get_change(cube.tp, [0, 0, 0, 0, 0, 0], this.tpc, []);\n        this.name = name\n        return this\n    }\n    from_moves (moves: Move[], name: string) {\n        this.from_cube(new CubieCube().apply(moves), name)\n        return this\n    }\n    clone() {\n        return new Move(this, this.name)\n    }\n    static make_rot_set(move: Move): Array<Move> {\n        return [move,\n            new Move().from_moves([move, move], move.name + \"2\"),\n            new Move().from_moves([move, move, move], move.name + \"'\"),\n        ]\n    }\n\n    static generate_base_moves = () => {\n        let make_rot_set = Move.make_rot_set\n        let us = make_rot_set(new Move(u));\n        let fs = make_rot_set(new Move(f));\n        let rs = make_rot_set(new Move(r));\n        let ls = make_rot_set(new Move(l));\n        let ds = make_rot_set(new Move(d));\n        let bs = make_rot_set(new Move(b));\n        let ms = make_rot_set(new Move(m));\n        let es = make_rot_set(new Move(e));\n        let ss = make_rot_set(new Move(s));\n\n        let rw = new Move([new Move(r), ms[2]], \"r\")\n        let rws = make_rot_set(rw)\n        let lw = new Move([new Move(l), new Move(m)], \"l\")\n        let lws = make_rot_set(lw)\n        let uw = new Move([new Move(u), new Move(e)], \"u\")\n        let uws = make_rot_set(uw)\n        let fw = new Move([new Move(f), new Move(s)], \"f\")\n        let fws = make_rot_set(fw)\n\n        let x = new Move([new Move(r), ls[2], ms[2]], \"x\")\n        let xs = make_rot_set(x)\n        let y = new Move([new Move(u), new Move(e), ds[2]], \"y\")\n        let ys = make_rot_set(y)\n        let z = new Move([x, y, x, x, x], \"z\")\n        let zs = make_rot_set(z)\n\n        let id = new Move(new CubieCube(), \"id\")\n        let moves = [\n            id,\n            us, fs, rs, ls, ds, bs, ms, es, ss,\n            xs, ys, zs,\n            rws, lws, uws, fws\n        ].flat()\n        let moves_dict: { [key: string]: Move } = Object.create({})\n        moves.forEach(m => moves_dict[m.name] = m)\n        return moves_dict\n    }\n    static all: {[key: string]: Move} = Move.generate_base_moves();\n\n    inv(): Move {\n        let name: string\n        switch (this.name[this.name.length - 1]) {\n            case \"'\": name = this.name.slice(0, this.name.length - 1); break\n            case \"2\": name = this.name; break\n            default: name = this.name + \"'\"\n        }\n        return Move.all[name]\n    }\n\n    toString() {\n        return this.name\n    }\n}\n\n\nexport class MoveSeq {\n    moves: Move[] = [];\n\n    constructor(moves: Move[] | string) {\n        if (typeof moves === \"string\") {\n            this.parse(moves);\n        } else {\n            this.moves = moves\n        }\n    }\n\n    static quarterMap : {[key: string]: string} = ({\n        \"U2\": \"U'\",\n        \"R2\": \"R'\",\n        \"r2\": \"r'\",\n        \"M2\": \"M'\",\n        \"L2\": \"L\",\n    });\n    toQuarter() {\n        let nm : Move[] = []\n        for (let i = 0 ; i < this.moves.length; i++) {\n            let m = this.moves[i]\n            if (m.name[1] === \"2\") {\n                let k = MoveSeq.quarterMap[m.name] || m.name[0]\n                nm.push(Move.all[ k ])\n                nm.push(Move.all[ k ])\n            } else {\n                nm.push(m)\n            }\n        }\n        return new MoveSeq(nm)\n    }\n\n    static _combine(move1: Move, move2: Move) : MoveSeq {\n        const getCnt = (name : string) => {\n            if (name.length === 1) return 1\n            return name[1] === \"2\" ? 2 : 3\n        }\n        const getStr = (cnt : number) => {\n            return (cnt === 1) ? \"\" : (cnt === 2 ? \"2\" : \"'\")\n        }\n        if (move1.name[0] === move2.name[0]) {\n            let cnt = (getCnt(move1.name) + getCnt(move2.name)) % 4\n            if (cnt === 0) return new MoveSeq([])\n            else return new MoveSeq([ Move.all[move1.name[0] + getStr(cnt)] ])\n        } else {\n            return new MoveSeq([move1, move2])\n        }\n    }\n\n    remove_setup() {\n        let rotset = new Set([\"x\", \"x'\", \"x2\", \"y\", \"y'\", \"y2\", \"z\", \"z'\", \"z2\"]);\n        while (this.moves.length > 0 && rotset.has(this.moves[0].name)) {\n            this.moves.shift()\n        }\n        return this\n    }\n\n    parse_line(str: string) {\n        let tokens = []\n        let token = \"\"\n        let comment_idx = str.search(/\\/\\//)\n        if (comment_idx > -1) str = str.slice(0, comment_idx)\n        for (let i = 0; i < str.length; i++) {\n            let ch = str[i]\n            if (ch === '2' || ch === '\\'') {\n                if (token.length === 1) {\n                    token += str[i];\n                    tokens.push(token)\n                    token = \"\"\n                }\n            } else if (ch === ' ') {\n                if (token.length > 0) {\n                    tokens.push(token); token = \"\";\n                }\n            } else {\n                const ord = ch.charCodeAt(0)\n                if ( (65 <= ord && ord < 65 + 26) || (97 <= ord && ord < 97 + 26)) {\n                    if (token.length > 0) {\n                        tokens.push(token)\n                        token = \"\"\n                    }\n                    token += str[i]\n                }\n            }\n        }\n        let moves = []\n        if (token.length > 0) tokens.push(token);\n        for (let token of tokens) {\n            let move = Move.all[token]\n            if (move) {\n                moves.push(move)\n            }\n        }\n        return moves\n    }\n    parse(str: string) {\n        this.moves = str.split(\"\\n\").map(x => this.parse_line(x)).flat()\n        return this\n    }\n\n    collapse() : MoveSeq {\n        let newMoves : Move[] = []\n        let moves = this.moves\n        while (moves.length > 0) {\n            const nextMove = moves.shift()!\n            if (newMoves.length === 0) {\n                newMoves.push(nextMove)\n            } else {\n                const move = newMoves.pop()!\n                const combined = MoveSeq._combine(move, nextMove)\n                for (let m of combined.moves)\n                    newMoves.push(m)\n            }\n        }\n        return new MoveSeq(newMoves);\n    }\n\n    inv() {\n        let moves: Move[] = this.moves.slice(0).reverse().map(x => x.inv()).flat()\n        return new MoveSeq(moves)\n    }\n\n    slice(n: number) {\n        let moves: Move[] = this.moves.slice(0, n)\n        return new MoveSeq(moves)\n    }\n\n    length() {\n        return this.moves.length\n    }\n\n    static add_auf(moves: Array<Move>, auf_moves?: Array<Move | MoveSeq>) {\n        auf_moves = auf_moves || [ Move.all[\"id\"], Move.all[\"U\"], Move.all[\"U'\"], Move.all[\"U2\"]]\n        let auf_move = rand_choice(auf_moves)\n        if (auf_move instanceof MoveSeq) {\n            moves.concat(auf_move.moves)\n        } else {\n            moves.push(auf_move)\n        }\n    }\n\n    toString(useMetric?: string) {\n        return this.moves.map(m => m.toString()).join(\" \") + \" \" + (useMetric ? \"(\" + this.moves.length + \")\" : \"\")\n    }\n}\n\n/* Faces */\nlet FaceletCube = function () {\n    let mult_move = (face: FaceletT, move: Move): FaceletT => {\n        let face_new: FaceletT = [...face]\n        let mod_for_typ = (typ: Typ) => {\n            switch (typ) {\n                case C: return 3;\n                case E: return 2;\n                case T: return 1\n            }\n        }\n        let work = (p: PermChg, o: number, typ: Typ) => {\n            let mod = mod_for_typ(typ)\n            let [p1, p2] = p\n            for (let i = 0; i < face.length; i++) {\n                let [p_curr, o_curr, typ_curr] = face[i];\n                if (typ_curr === typ && p_curr === p1) {\n                    face_new[i] = [p2, (o_curr + o) % mod, typ]\n                }\n            }\n        }\n        for (let i = 0; i < move.cpc.length; i++) {\n            work(move.cpc[i], move.coc[i], C)\n        }\n        for (let i = 0; i < move.epc.length; i++) {\n            work(move.epc[i], move.eoc[i], E)\n        }\n        for (let i = 0; i < move.tpc.length; i++) {\n            work(move.tpc[i], 0, T)\n        }\n        return face_new\n    }\n    let color_of_c = (p: number, o1: number, o2: number) =>\n    corners_coord[p][(3 - o1 + o2) % 3];\n    let color_of_e = (p: number, o1: number, o2: number) =>\n        edges_coord[p][(2 - o1 + o2) % 2];\n    let color_of_t = (p: number) => [U, D, F, B, L, R][p]\n\n    let color_of_sticker = (cube: CubieCube, sticker: StickerT) => {\n        let [p, o, typ] = sticker\n        if (typ === C) {\n            return color_of_c(cube.cp[p], cube.co[p], o)\n        } else if (typ === E) {\n            return color_of_e(cube.ep[p], cube.eo[p], o)\n        } else if (typ === T) {\n            return color_of_t(cube.tp[p])\n        } else {\n            throw Error(\"unidentified type \" + typ)\n        }\n    }\n\n    let from_cubie_partial = (cube: CubieCube, facelet: FaceletT) => {\n        return facelet.map(s => color_of_sticker(cube, s))\n    }\n    let from_cubie_partial_masked = (cube: CubieCube, facelet: FaceletT, mask: Mask) => {\n        return facelet.map(([p, o, typ]) => {\n            if (typ === C) {\n                if (mask.cp[cube.cp[p]] === 1)\n                    return color_of_c(cube.cp[p], cube.co[p], o)\n                else\n                    return Face.X\n            } else if (typ === E) {\n                if (mask.ep[cube.ep[p]] === 1)\n                    return color_of_e(cube.ep[p], cube.eo[p], o)\n                else\n                    return Face.X\n            } else if (typ === T) {\n                if (mask.tp && mask.tp[cube.tp[p]] === 0)\n                    return Face.X\n                else\n                    return color_of_t(cube.tp[p])\n            } else {\n                throw Error(\"unidentified type \" + typ)\n            }\n        })\n    }\n\n    let moves = Move.all\n    let generate_base_facelets = () => {\n        let d_face = mult_move(f_face, moves[\"x'\"])\n        let l_face = mult_move(f_face, moves[\"y\"])\n        let r_face = mult_move(f_face, moves[\"y'\"])\n        let b_face = mult_move(f_face, moves[\"y2\"])\n        return {\n            d_face, l_face, r_face, b_face\n        }\n    }\n    let { d_face, l_face, r_face, b_face } = generate_base_facelets()\n\n    let from_cubie = (cube: CubieCube, mask?: Mask): FaceletCubeT => {\n        //console.log(\"converting from cube\", cube)\n        let faces = [u_face, d_face, f_face, b_face, l_face, r_face]\n        if (mask)\n            return faces.map((facelet) => from_cubie_partial_masked(cube, facelet, mask))\n        else\n            return faces.map((facelet) => from_cubie_partial(cube, facelet))\n    }\n\n    let as_actrm = (fcube: FaceletCubeT, faces: 'lr' | 'fb', uu_only: boolean): FaceletCubeT => {\n        // U_face index 0\n        // algorithm: for U face and 0..2 of FBLR face, filter by lr|fb + u sticker\n        // additionally, if uu_only == 1, filter 0..2 of FBLR face by lr|fb only.\n        const U_IDX = 0\n        const F_IDX = 2\n        const nmcll_faces = (faces === 'lr') ? [Face.L, Face.R] : [Face.F, Face.B]\n        const u_or_nmcll_faces = [Face.U, ...nmcll_faces]\n        return fcube.map((stickers, idx) => {\n            if (idx === U_IDX) {\n                return stickers.map(s => u_or_nmcll_faces.includes(s) ? s : Face.X)\n            }\n            if (idx >= F_IDX) {\n                return stickers.map((s, fidx) =>\n                    ((uu_only ? nmcll_faces : u_or_nmcll_faces).includes(s) || fidx > 2)\n                   ? s\n                   : Face.X)\n            }\n            return [...stickers]\n        })\n    }\n\n    let as_kata = (fcube: FaceletCubeT) => {\n        // find out where are the recog stickers and grey out the rest\n        console.log(fcube)\n        let {F,B,L,R,U} = Face\n        const shape_maps = [\n            // prioritize all recog stickers on U (Pi, H)\n            [[U, 0], [U, 2], [U, 6], [U, 8]],\n            // next, find recog stickers in T shape\n            [[U, 0], [U, 2], [L, 2], [R, 0]],\n            [[U, 2], [U, 8], [B, 2], [F, 0]],\n            [[U, 6], [U, 8], [L, 0], [R, 2]],\n            [[U, 0], [U, 6], [B, 0], [F, 2]],\n            // default: recog stickers for L\n            [[U, 2], [U, 6], [F, 2], [B, 2]],\n            [[U, 0], [U, 8], [L, 2], [R, 2]],\n            // default: recog stickers for O (solved)\n            [[F, 0], [F, 2], [R, 0], [R, 2]],\n        ]\n        let found = false;\n        for (let map of shape_maps) {\n            let match_count = 0;\n            for (let [f, i] of map) {\n                match_count += (fcube[f][i] !== Face.U) ? 1 : 0;\n            }\n            if (match_count === map.length) {\n                // found recog shape, now make all non-U pieces X\n                for (let f of [Face.L, Face.R, Face.F, Face.B, Face.U]) {\n                    for (let i = 0; i < ((f === Face.U) ? 9 : 3); i++) {\n                        if (fcube[f][i] !== Face.U) {\n                            let is_recog = Array(4).fill(0).map((_, j) => (map[j][0] === f && map[j][1] === i)).includes(true)\n                            if (!is_recog) {\n                                fcube[f][i] = Face.X;\n                            }\n                        }\n                    }\n                }\n                found = true;\n                break;\n            }\n        }\n        //console.log(fcube)\n        if (!found) {\n            alert(\"recog shape not found\")\n        }\n        return fcube;\n    }\n\n    let to_unfolded_cube_str = (faceletCube: FaceletCubeT): String => {\n        let face_count = [0, 0, 0, 0, 0, 0];\n        let str_face_map: { [key: string]: Face } = {\n            \"U\": U, \"D\": D, \"F\": F, \"B\": B, \"L\": L, \"R\": R\n        }\n        let face_str_map = \"UDFBLR\"\n        let color_cube = \"\"\n        for (let i = 0; i < color_map.length; i++) {\n            let face_char = color_map[i];\n            if (str_face_map.hasOwnProperty(face_char)) {\n                let face: number = str_face_map[face_char] as number;\n                let count = face_count[face];\n                let color = faceletCube[face][count]\n                color_cube += face_str_map[color]\n                face_count[face] += 1;\n            } else {\n                color_cube += color_map[i];\n            }\n        }\n        return color_cube;\n    }\n\n\n    return {\n        from_cubie,\n        to_unfolded_cube_str,\n        color_of_sticker,\n        color_of_e,\n        as_actrm,\n        as_kata,\n        faces: {\n            u_face, d_face, l_face, r_face, f_face, b_face\n        }\n    }\n}()\n\ntype Mask = {\n    co?: number[],\n    eo?: number[],\n    tp?: number[],\n    cp: number[],\n    ep: number[],\n}\nexport type MaskT = Mask;\nfunction mask_copy (m: Mask) {\n    return {\n        co: m.co && [...m.co],\n        eo: m.eo && [...m.eo],\n        tp: m.tp && [...m.tp],\n        cp: [...m.cp],\n        ep: [...m.ep]\n    }\n}\n\nconst lse_mask: Mask = {\n    cp: [1, 1, 1, 1, 1, 1, 1, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1],\n}\n\nconst lse_4c_mask: Mask = {\n    cp: [1, 1, 1, 1, 1, 1, 1, 1],\n    ep: [0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1],\n    eo: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n}\n\nconst solved_mask : Mask = {\n    cp: [1, 1, 1, 1,  1, 1, 1, 1],\n    ep:[1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1],\n}\nconst empty_mask : Mask = {\n    cp: [0, 0, 0, 0, 0, 0, 0, 0],\n    ep: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n}\nconst dl_solved_mask : Mask = {\n    cp: [0, 0, 0, 0, 0, 0, 0, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]\n}\nconst bl_solved_mask : Mask = {\n    cp: [0, 0, 0, 0, 0, 0, 0, 0],\n    ep: [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]\n}\nconst fs_back_mask: Mask = {\n    cp: [0, 0, 0, 0, 0, 1, 0, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\n\nconst fs_front_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 0, 0, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\n\nconst fb_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 0, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\n\nconst f2b_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 1, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1],\n    tp: [0, 0, 0, 0, 1, 1]\n}\n\nconst zhouheng_mask: Mask = {\n    cp: [0, 0, 0, 0, 0, 0, 0, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst fbdr_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 0, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst ss_front_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 0, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst ss_back_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 1, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst ssdp_front_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 0, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst ssdp_back_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 1, 0],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst ssdp_both_mask: Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 1, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n    tp: [0, 0, 0, 0, 1, 1]\n}\n\nconst sb_mask : Mask = {\n    cp: [0, 0, 0, 0, 1, 1, 1, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1],\n    tp: [0, 0, 0, 0, 1, 1]\n}\nconst cmll_mask : Mask = {\n    cp: [1, 1, 1, 1, 1, 1, 1, 1],\n    ep: [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1],\n    tp: [0, 0, 0, 0, 1, 1]\n}\n\nlet CubeUtil = (() => {\n    let is_cube_solved = (cube: CubieCube) => {\n        let id = new CubieCube()\n        return arrayEqual(cube.co, id.co) &&\n               arrayEqual(cube.eo, id.eo) &&\n               arrayEqual(cube.cp, id.cp) &&\n               arrayEqual(cube.ep, id.ep)\n    }\n\n    let is_solved = (cube: CubieCube, mask: Mask) => {\n        let {co: co_, cp, eo: eo_, ep, tp: tp_} = mask\n        let co = co_ || cp\n        let eo = eo_ || ep\n        let tp = tp_ || Array(6).fill(1)\n        let c_true = co.every( (_, i) =>  (cp[i] === 0 || cube.cp[i] === i)\n                        && (co[i] === 0 || cube.co[i] === 0) )\n        if (!c_true) return false\n        let e_true = eo.every( (_, i) =>  (ep[i] === 0 || cube.ep[i] === i)\n        && (eo[i] === 0 || cube.eo[i] === 0) )\n        if (!e_true) return false\n        let t_true = tp.every( (_, i) =>  (tp[i] === 0 || cube.tp[i] === i) )\n        return t_true\n    }\n\n    function ext(stickers: StickerT[], f: Face) : StickerExtT[] {\n        return stickers.map(x => {\n            let [a, b, c] = x;\n            return [a,b,c,f]\n        })\n    }\n\n    let { u_face, d_face, l_face, r_face, f_face, b_face } = FaceletCube.faces\n    let stickers = [ ...ext(u_face, U), ...ext(d_face, D),\n        ...ext(l_face, L), ...ext(r_face, R), ...ext(f_face,F),  ...ext(b_face, B)]\n\n    let find_pairs = function() {\n        // enumerate each sticker\n        let edge_stickers = stickers.filter(s => s[2] === Typ.E)\n        let corner_stickers = stickers.filter(s => s[2] === Typ.C)\n\n        let ep_stickers : StickerExtT[][] = Array(12).fill(0).map(_ => Array(0))\n        edge_stickers.map(s => ep_stickers[s[0]].push(s) )\n\n        let cp_stickers : StickerExtT[][] = Array(8).fill(0).map(_ => Array(0))\n        corner_stickers.map(s => cp_stickers[s[0]].push(s))\n\n        const epcp_pairs : [number, number][] = []\n        for (let e = 0; e < 12; e++) {\n            for (let c = 0; c < 8; c++) {\n                let efs = ep_stickers[e]\n                let cfs = cp_stickers[c]\n\n                let match = 0;\n                efs.forEach( (e) => {\n                    cfs.forEach( (c) => { if (e[3] === c[3]) match++ })\n                })\n                if (match === 2) {\n                    epcp_pairs.push( [e, c] )\n                }\n            }\n        }\n\n\n        let get_color = (cube: CubieCube, s: StickerExtT) => {\n            return FaceletCube.color_of_sticker(cube, [s[0], s[1], s[2]] )\n        }\n        let func = (cube: CubieCube) => {\n            // now we process the cube\n            let connected_pairs : [number, number][]= []\n            //console.log(\"All neighboring pairs \", epcp_pairs)\n            for (let [ep, cp] of epcp_pairs) {\n                let efs = ep_stickers[ep]\n                let cfs = cp_stickers[cp]\n                let cnt = 0;\n                efs.forEach( (e) => {\n                    const c = cfs.filter( (c) => e[3] === c[3])[0]\n                    if (get_color(cube, e) === get_color(cube, c)) cnt++;\n                })\n                if (cnt === 2) {\n                    connected_pairs.push([ep, cp])\n                }\n            }\n            return connected_pairs\n        }\n        return func\n    }()\n\n    let is_mask_solved2 = (cube: CubieCube, { co, eo, cp, ep }: Mask, premove: (Move | Move[])[]) => {\n        //let moves = [ [], Move.all[\"U\"], Move.all[\"U'\"], Move.all[\"U2\"] ]\n        co = co || cp\n        eo = eo || ep\n        for (let move of premove) {\n            let cube1 = cube.apply(move)\n            let solved = true\n            for (let i = 0; i < 8 && solved; i++) {\n                if ((co[i] && cube1.co[i] !== 0)\n                    || (cp[i] && cube1.cp[i] !== i)) {\n                    solved = false;\n                }\n            }\n            for (let i = 0; i < 12 && solved; i++) {\n                if ((eo[i] && cube1.eo[i] !== 0)\n                    || (ep[i] && cube1.ep[i] !== i)) {\n                    solved = false;\n                }\n            }\n            if (solved) return true;\n        }\n        return false;\n    }\n\n    const u_premove = [[], Move.all[\"U\"], Move.all[\"U'\"], Move.all[\"U2\"]]\n    const m2_premove = [[], Move.all[\"M2\"]]\n\n    let is_cmll_solved = (cube: CubieCube) => {\n        return is_mask_solved2(cube, lse_mask, u_premove)\n    }\n\n    const oris = [\"\", \"y\", \"y'\", \"y2\", \"x2\", \"x2y\", \"x2y'\", \"x2y2\",\n        \"x\", \"xy\", \"xy'\", \"xy2\", \"x'\", \"x'y\", \"x'y'\", \"x'y2\",\n        \"z\", \"zy\", \"zy'\", \"zy2\", \"z'\", \"z'y\", \"z'y'\", \"z'y2\"];\n    let rebase_to_edge = (cube: CubieCube, ep: number): [CubieCube, string] => {\n        for (let ori of oris) {\n            const cube_rebased = cube.apply(ori)\n            if ((cube_rebased.ep[ep] === ep)) {\n                return [cube_rebased, ori]\n            }\n        }\n        return [cube, \"\"]\n    }\n\n    let get_random_with_mask = ({ co, eo, cp, ep }: Mask): CubieCube => {\n        co = co || cp\n        eo = eo || ep\n        // get_random -- figure out which masks are 0, and assign random to these\n        let random_ori = (ori_mask: number[], typ: Typ) => {\n            let ori = Array(ori_mask.length).fill(0)\n            let mod = (typ === C) ? 3 : 2\n            let sum: number\n            do {\n                sum = 0\n                for (let i in ori_mask) {\n                    if (ori_mask[i] === 0) {\n                        ori[i] = rand_int(mod)\n                        sum += ori[i]\n                    }\n                }\n            } while (sum % mod > 0)\n            return ori\n        }\n        let random_perm = (perm_mask: number[]) => {\n            let perm: number[] = Array(perm_mask.length).fill(0)\n            let undecided: number[] = []\n            for (let i = 0; i < perm_mask.length; i++) {\n                if (perm_mask[i] === 0) {\n                    undecided.push(i)\n                } else {\n                    perm[i] = i\n                }\n            }\n            rand_shuffle(undecided)\n            for (let i = 0, cnt = 0; i < perm_mask.length; i++) {\n                if (perm_mask[i] === 0) {\n                    perm[i] = undecided[cnt]\n                    cnt += 1\n                }\n            }\n            return perm\n        }\n        let cp_rand, ep_rand, par\n        do {\n            [cp_rand, ep_rand] = [random_perm(cp), random_perm(ep)]\n            par = (getParity(cp_rand) + getParity(ep_rand)) & 1\n        } while (par > 0)\n\n        return new CubieCube({\n            co: random_ori(co, C),\n            cp: cp_rand,\n            eo: random_ori(eo, E),\n            ep: ep_rand,\n        })\n    }\n\n    let get_random_lse = (): CubieCube => {\n        let cube = get_random_with_mask(lse_mask)\n        return cube.apply(rand_choice(m2_premove))\n    }\n\n\n\n    return {\n        is_cmll_solved,\n        is_solved,\n        get_random_lse,\n        get_random_with_mask,\n        is_cube_solved,\n        find_pairs,\n        stickers,\n        rebase_to_edge\n    }\n})()\n\nexport abstract class Storage {\n    abstract name: string;\n    abstract serialize(): string;\n    abstract deserialize(x: string): void;\n    abstract _setDefault(): void;\n    save() {\n        window.localStorage.setItem(this.name, this.serialize());\n    }\n    load() {\n        const item = window.localStorage.getItem(this.name)\n        if (item) this.deserialize(item);\n        else this._setDefault();\n    }\n}\n\nexport class ColorScheme extends Storage {\n    // UDFBLR\n    // specify the colors for uf\n    // how to do this?\n    static default_colors = {\n        \"G\": \"#00b500\",\n        \"B\": \"#0000ff\",\n        \"R\": \"#ff0000\",\n        \"O\": \"#ff8800\",\n        \"Y\": \"#ffff00\",\n        \"W\": \"#ffffff\",\n        \"X\": \"#bfbfbf\"\n    }\n    name = \"colorscheme\";\n    colors: {[key:string]:string} = {};\n    // UDFBLR from UF\n    // INFERR UFR from UF?\n    static valid_schemes = [\n        \"WYGBOR\",\n        \"WYBGRO\",\n        \"WYROGB\",\n        \"WYORBG\",\n        \"YWGBRO\",\n        \"YWBGOR\",\n        \"YWROBG\",\n        \"YWORGB\",\n\n        \"GBWYRO\",\n        \"GBYWOR\",\n        \"GBROYW\",\n        \"GBORWY\",\n        \"BGWYOR\",\n        \"BGYWRO\",\n        \"BGROWY\",\n        \"BGORYW\",\n\n        \"ORWYGB\",\n        \"ORYWBG\",\n        \"ORGBYW\",\n        \"ORBGWY\",\n        \"ROWYBG\",\n        \"ROYWGB\",\n        \"ROGBWY\",\n        \"ROBGYW\",\n    ]\n    static valid_schemes_map = function() {\n        return new Map(ColorScheme.valid_schemes.map(x => [ x[0] + x[2], x]))\n    }();\n    constructor(suppressLoad?: boolean) {\n        super();\n        if (!suppressLoad) {\n            this.load();\n        }\n    }\n    toUserInput() {\n        return \"GBROYWX\".split('').map(x => this.colors[x])\n    }\n    set( colors:{[key:string]:string} | string[]) {\n        let newScheme = new ColorScheme(true);\n        if (Array.isArray(colors)) {\n            colors.forEach( (color, i) => newScheme.colors[\"GBROYWX\"[i]] = color )\n        } else {\n            newScheme.colors = {...this.colors, ...colors};\n        }\n        newScheme.save();\n        return newScheme\n    }\n    setWithDefault() {\n        let newScheme = new ColorScheme(true);\n        newScheme._setDefault();\n        newScheme.save();\n        return newScheme\n    }\n    _setDefault() { this.colors = ColorScheme.default_colors; };\n    serialize() {\n        return JSON.stringify(this.colors)\n    }\n    deserialize(s: string) {\n        this.colors = JSON.parse(s)\n    }\n    getColorsForOri(s: string) {\n        let faces = (ColorScheme.valid_schemes_map.get(s) || ColorScheme.valid_schemes_map.get(\"WG\")) + \"X\";\n        let arr : string[] = []\n        for (let i = 0; i < faces.length; i++) {\n            arr.push(this.colors[faces[i]]!)\n        }\n        return arr\n    }\n}\n\nlet Mask = {\n    lse_mask, fs_back_mask, fs_front_mask, fbdr_mask, fb_mask, f2b_mask, sb_mask, cmll_mask, ss_front_mask, ss_back_mask,\n    ssdp_front_mask, ssdp_back_mask, ssdp_both_mask, empty_mask, dl_solved_mask, bl_solved_mask, solved_mask, zhouheng_mask, lse_4c_mask,\n    copy: mask_copy\n}\n\nexport { FaceletCube, CubeUtil, Mask }\n","import { CubieCube, Move } from './CubeLib';\nimport { Face } from './Defs';\nimport { cartesianProduct } from './Math';\nif ((globalThis as any).$RefreshReg$ === undefined) {\n    // hack for disabling refresh plugin in web worker\n    (globalThis as any).$RefreshReg$ = () => {};\n    (globalThis as any).$RefreshSig$ = () => () => {};\n}\n\nexport type PrunerConfig = {\n    size: number,\n    encode: (cube : CubieCube) => number,\n    solved_states: CubieCube[],\n    max_depth: number,\n    moveset: string[],\n    rev_lookup_depth?: number,\n    name: string\n}\n\nexport type PrunerT = {\n    init: () => void,\n    query: (c : CubieCube) => number,\n    equal: (c1 : CubieCube, c2: CubieCube) => boolean,\n    encode: (c : CubieCube) => number,\n    moveset: Move[],\n    max_depth: number,\n    size: number\n}\n\nenum PrunerPiece {\n    S, O, I, X\n}; // Solved, Oriented, Ignore, Exclude\nconst { S, I } = PrunerPiece\n\nexport type PrunerDef = {\n    corner: PrunerPiece[],\n    edge:   PrunerPiece[],\n    center: PrunerPiece[],\n    solved_states: string[],\n    moveset: string[],\n    max_depth: number,\n    name: string\n}\n\nlet htm_rwm = [\"U\", \"U2\", \"U'\", \"F\", \"F2\", \"F'\", \"R\", \"R2\", \"R'\",\n    \"r\", \"r2\", \"r'\", \"D\", \"D2\", \"D'\", \"M\", \"M'\", \"M2\", \"B\", \"B'\", \"B2\"]\nlet rrwmu = [\"U\", \"U'\", \"U2\", \"R\", \"R'\", \"R2\",\n    \"r\", \"r'\", \"r2\", \"M'\", \"M\", \"M2\"]\nlet rrwmu_m_first = [\"U\", \"U'\", \"U2\", \"R\", \"R'\", \"R2\", \"M'\", \"M\", \"M2\",\n\"r\", \"r'\", \"r2\"]\nlet rrwmu_f = [\"U\", \"U'\", \"U2\", \"R\", \"R'\", \"R2\",\n    \"r\", \"r'\", \"r2\", \"M'\", \"M\", \"M2\", \"F'\", \"F\", \"F2\"]\nlet rrwmu_b = [\"U\", \"U'\", \"U2\", \"R\", \"R'\", \"R2\",\n    \"r\", \"r'\", \"r2\", \"M'\", \"M\", \"M2\", \"B'\", \"B\", \"B2\"]\nlet htm_rwm_uw = [\"U\", \"U2\", \"U'\", \"F\", \"F2\", \"F'\", \"R\", \"R2\", \"R'\",\n    \"r\", \"r2\", \"r'\", \"u\", \"u2\", \"u'\", \"M\", \"M'\", \"M2\", \"B\", \"B'\", \"B2\"]\nlet htm_rwm_fws = [\"U\", \"U2\", \"U'\", \"F\", \"F2\", \"F'\", \"R\", \"R2\", \"R'\",\n    \"r\", \"r2\", \"r'\", \"M\", \"M'\", \"M2\", \"D\", \"D'\", \"D2\",\n    \"f\", \"f'\", \"f2\", \"S'\", \"S\", \"S2\"] // TODO: suppress the other S for OH mode?\n\nlet xyz = [\"x\", \"x'\", \"x2\", \"y\", \"y'\", \"y2\", \"z\", \"z'\", \"z2\"]\n\nexport function Pruner(config: PrunerConfig) : PrunerT {\n    let dist: Uint8Array;\n    let { size, encode, solved_states, max_depth, moveset: moveset_str, name} = config\n    let moveset = moveset_str.map(x => Move.all[x])\n    let initialized = false\n    let level_states = [[...solved_states]]\n    function init() {\n        if (initialized) return\n        initialized = true\n        dist = new Uint8Array(size).fill(255)\n        for (let state of solved_states) {\n            dist[encode(state)] = 0\n        }\n        let frontier = [...solved_states]\n        let total_expanded = frontier.length\n        for (let i = 0; i < max_depth; i++) {\n            //console.log(\"pruner: expanding depth \", i)\n            let new_frontier = []\n            for (let state of frontier) {\n                for (let move of moveset) {\n                    let newState = state.apply(move) // clone\n                    let idx = encode(newState)\n                    if (dist[idx] === 255) {\n                        dist[idx] = i + 1;\n                        new_frontier.push(newState)\n                    }\n                }\n            }\n            frontier = new_frontier\n            if (config.rev_lookup_depth && i + 1 <= config.rev_lookup_depth) {\n                level_states.push([...frontier])\n            }\n            total_expanded += frontier.length\n        }\n        //console.log(`${name} pruning table generated. depth = ${max_depth}. size = ${total_expanded}`)\n        if (config.rev_lookup_depth) {\n            // console.log(`${name} pruning reverse lookup generated. depth = ${config.rev_lookup_depth}. size = ${level_states.map(x => x.length).reduce((x,y)=>x+y)}`)\n        }\n    }\n    function query(cube: CubieCube) {\n        let d = dist[encode(cube)]\n        if (d === 255) return max_depth + 1;\n        return d\n    }\n    function equal(cube1: CubieCube, cube2: CubieCube) {\n        return encode(cube1) === encode(cube2)\n    }\n    return  {\n        init,\n        query,\n        equal,\n        encode,\n        moveset,\n        max_depth,\n        size\n    }\n}\n\n\n\nlet prunerFactory = function(def: PrunerDef): PrunerConfig {\n    // edge\n    if (def.corner.length !== 8 || def.edge.length !== 12 || def.center.length !== 6) {\n        throw new Error(\"Invalid pruner def\");\n    }\n    const {S, O, I, X} = PrunerPiece\n    const def_to_idx = (d : PrunerPiece[], count_all?: boolean) => {\n        let curr_idx = 0, idx_arr = []\n        for (let i = 0; i < d.length; i++) {\n            if (d[i] === S || (count_all && (d[i] === O || d[i] === I))) {\n                idx_arr.push(curr_idx++);\n            } else idx_arr.push(-1);\n        }\n        return idx_arr;\n    }\n    let eosize = def.edge.filter(x => x === S || x === O).length\n    let epsize = def.edge.filter(x => x === S).length\n    let eisize = def.edge.filter(x => x !== X).length\n    let esize = Math.pow(2, eosize) * Math.pow(eisize, epsize)\n    let ep_idx = def_to_idx(def.edge, false);\n    let e_idx = def_to_idx(def.edge, true);\n\n    let cosize = def.corner.filter(x => x === S || x === O).length\n    let cpsize = def.corner.filter(x => x === S).length\n    let cisize = def.corner.filter(x => x !== X).length\n    let csize = Math.pow(3, cosize) * Math.pow(cisize, cpsize)\n    let cp_idx = def_to_idx(def.corner, false);\n    let c_idx = def_to_idx(def.corner, true);\n\n    let tosize = def.center.filter(x => x === O).length\n    let tpsize = def.center.filter(x => x === S).length\n    let tisize = def.center.filter(x => x !== X).length\n    let tsize = Math.pow(2, tosize) * Math.pow(tisize, tpsize)\n    let tp_idx = def_to_idx(def.center, false);\n\n    let size = esize * csize * tsize;\n\n    function encode(cube: CubieCube) {\n        let eo = 0, ep = 0, co = 0, cp = 0, to = 0, tp = 0, e, c, t\n        for (let i = 0; i < 12; i++) {\n            switch (def.edge[cube.ep[i]]) {\n                case S:\n                    eo = eo * 2 + cube.eo[i];\n                    ep = ep + Math.pow(eisize, ep_idx[cube.ep[i]]) * e_idx[i];\n                    break;\n                case O:\n                    eo = eo * 2 + cube.eo[i];\n                    break;\n            }\n        }\n        e = ep * Math.pow(2, eosize) + eo\n        for (let i = 0; i < 8; i++) {\n            switch (def.corner[cube.cp[i]]) {\n                case S:\n                    co = co * 3 + cube.co[i];\n                    cp = cp + Math.pow(cisize, cp_idx[cube.cp[i]]) * c_idx[i];\n                    break;\n                case O:\n                    co = co * 3 + cube.co[i];\n                    break;\n            }\n        }\n        c = cp * Math.pow(3, cosize) + co\n        for (let i = 0; i < 6; i++) {\n            switch (def.center[cube.tp[i]]) {\n                case S:\n                    tp = Math.pow(tisize, tp_idx[cube.tp[i]]) + i;\n                    break;\n                case O:\n                    to = to * 3 + (cube.tp[i] / 2) | 0;\n                    break;\n            }\n        }\n        t = tp * Math.pow(3, tosize) + to\n        return e * csize * tsize + c * tsize + t\n    }\n\n    const solved_states = def.solved_states.map( m => new CubieCube().apply(m))\n    const moveset = def.moveset\n    const max_depth = def.max_depth\n    const name = def.name\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name\n    }\n}\n\n\nlet fbdrPrunerConfigGen = (max_depth: number) : PrunerConfig => {\n    const esize = Math.pow(24, 4)\n    const csize = Math.pow(24, 2)\n    const size = esize * csize\n\n    function encode(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        if (cube.cp[i] === 4) {\n          c1 = i * 3 + cube.co[i]\n        } else if (cube.cp[i] === 5) {\n          c2 = i * 3 + cube.co[i];\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0, e3 = 0, e4 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 5 : e1 = i * 2 + cube.eo[i]; break;\n              case 8 : e2 = i * 2 + cube.eo[i]; break;\n              case 9 : e3 = i * 2 + cube.eo[i]; break;\n              case 7 : e4 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24 * 24 * 24) + e2 * (24 * 24) + e3 * 24 + e4\n      return enc_c + 24 * 24 * enc_e\n    }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n    const moveset = htm_rwm\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"fbdr\"\n    }\n}\n\nlet fbdrPrunerConfig = fbdrPrunerConfigGen(5)\n\n// let fbPrunerConfigAuto = prunerFactory({\n//     corner: [I,I,I,I,S,S,I,I],\n//     edge:   [I,I,I,I,I,S,I,I,S,S,I,I],\n//     center: [I,I,I,I,S,I],\n//     solved_states: [\"id\"],\n//     moveset: htm_rwm,\n//     max_depth: 5\n// });\n\n\nlet fbAtBLPrunerConfigGen = (max_depth: number) : PrunerConfig => {\n    const esize = Math.pow(24, 2)\n    const csize = Math.pow(24, 2)\n    const tsize = 6\n    const size = esize * csize * tsize\n\n    function encode(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 4: c1 = i * 3 + cube.co[i]; break;\n            case 5: c2 = i * 3 + cube.co[i]; break;\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 5 : e1 = i * 2 + cube.eo[i]; break;\n              case 8 : e2 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24) + e2\n      let t1 = 0\n      for (let i = 0; i < 6; i++) {\n         if (cube.tp[i] === Face.L) {\n            t1 = i;\n         }\n      }\n      const enc_t = t1\n      return enc_e * (csize * tsize) + enc_c * tsize + enc_t\n    }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    const moveset = htm_rwm_fws\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        // rev_lookup_depth: 3,\n        name: \"fb\"\n    }\n}\n\nlet fbAtDLPrunerConfigGen = (max_depth: number) : PrunerConfig => {\n    const esize = Math.pow(24, 2)\n    const csize = Math.pow(24, 2)\n    const tsize = 6\n    const size = esize * csize * tsize\n\n    function encode(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 4: c1 = i * 3 + cube.co[i]; break;\n            case 5: c2 = i * 3 + cube.co[i]; break;\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 8 : e1 = i * 2 + cube.eo[i]; break;\n              case 9 : e2 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24) + e2\n      let t1 = 0\n      for (let i = 0; i < 6; i++) {\n         if (cube.tp[i] === Face.L) {\n            t1 = i;\n         }\n      }\n      const enc_t = t1\n      return enc_e * (csize * tsize) + enc_c * tsize + enc_t\n    }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    const moveset = htm_rwm_uw\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        // rev_lookup_depth: 3,\n        name: \"fb\"\n    }\n}\n\nlet fbPrunerConfigGen = (max_depth: number) : PrunerConfig => {\n    const esize = Math.pow(24, 3)\n    const csize = Math.pow(24, 2)\n    const size = esize * csize\n\n    function encode(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 4: c1 = i * 3 + cube.co[i]; break;\n            case 5: c2 = i * 3 + cube.co[i]; break;\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0, e3 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 5 : e1 = i * 2 + cube.eo[i]; break;\n              case 8 : e2 = i * 2 + cube.eo[i]; break;\n              case 9 : e3 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24 * 24) + e2 * (24) + e3\n      return enc_e * (24 * 24) + enc_c\n    }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    const moveset = htm_rwm\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        // rev_lookup_depth: 3,\n        name: \"fb\"\n    }\n}\n\nlet fbAtBLPrunerConfig = fbAtBLPrunerConfigGen(5)\nlet fbAtDLPrunerConfig = fbAtDLPrunerConfigGen(5)\nlet fbPrunerConfig = fbPrunerConfigGen(5)\nlet ssPrunerConfig = (is_front: boolean) => {\n    const size = Math.pow(24, 3)\n    const c1 = is_front ? 7 : 6;\n    const e1 = is_front ? 11 : 10\n    const e2 = 7\n    function encode(cube:CubieCube) {\n      let v = [0 ,0, 0]\n      for (let i = 0; i < 8; i++) {\n        if ( cube.cp[i] === c1) v[0] = i * 3 + cube.co[i]\n      }\n      for (let i = 0; i < 12; i++) {\n          if (cube.ep[i] === e1) v[1] = i * 2 + cube.eo[i];\n          else if (cube.ep[i] === e2) v[2] = i * 2 + cube.eo[i]\n      }\n      return v[0] + v[1] * 24 + v[2] * 24 * 24\n    }\n\n    const moves = [[]]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move))\n    const max_depth = 8\n    const moveset = rrwmu\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"ss\" + (is_front ? \"-front\" : \"-back\")\n    }\n}\n\nlet ssDpPrunerConfig = (is_front: boolean) => {\n    const size = Math.pow(24, 2)\n    const c1 = is_front ? 7 : 6;\n    const e1 = 7\n    function encode(cube:CubieCube) {\n      let v0 = 0, v1 = 0\n      for (let i = 0; i < 8; i++) {\n        if ( cube.cp[i] === c1) v0 = i * 3 + cube.co[i]\n      }\n      for (let i = 0; i < 12; i++) {\n          if (cube.ep[i] === e1) v1 = i * 2 + cube.eo[i];\n      }\n      return v0 + v1 * 24\n    }\n\n    const moves = [\"\", \"R\", \"R2\", \"R'\"]\n    const solved_states = moves.map( (move : string) => new CubieCube().apply(move))\n    const max_depth = 8\n    const moveset = rrwmu_m_first\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"ssdp\" + (is_front ? \"-front\" : \"-back\")\n    }\n}\n\nlet sbPrunerConfig = function(){\n    const esize = Math.pow(24, 3)\n    const csize = Math.pow(24, 2)\n    const size = esize * csize\n\n    function encode(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 6: c1 = i * 3 + cube.co[i]; break;\n            case 7: c2 = i * 3 + cube.co[i]; break;\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0, e3 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 7  : e1 = i * 2 + cube.eo[i]; break;\n              case 10 : e2 = i * 2 + cube.eo[i]; break;\n              case 11 : e3 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24 * 24) + e2 * (24) + e3\n      return enc_e * (24 * 24) + enc_c\n    }\n\n    const moves = [[]]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    const moveset = rrwmu\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth: 6,\n        moveset,\n        // rev_lookup_depth: 3,\n        name: \"sb_rRUM\"\n    }\n}()\n\nlet lpSbPrunerConfigsAuto = (lp_front: boolean) => [\n    prunerFactory({\n        corner: lp_front ? [I,I,I,I,S,I,I,S] : [I,I,I,I,I,S,S,I],\n        edge:   lp_front ? [I,I,I,I,I,I,I,S,S,I,I,S] : [I,I,I,I,I,I,I,S,I,S,S,I],\n        center: [I,I,I,I,I,I],\n        solved_states: [\"id\"],\n        moveset: lp_front ? rrwmu_f : rrwmu_b,\n        max_depth: 5,\n        name: \"FBLP+SSdiag\"\n    }),\n    prunerFactory({ // SB\n        corner: [I,I,I,I,I,I,S,S],\n        edge:   [I,I,I,I,I,I,I,S,I,I,S,S],\n        center: [I,I,I,I,I,I],\n        solved_states: [\"id\"],\n        moveset: lp_front ? rrwmu_f : rrwmu_b,\n        max_depth: 5,\n        name: \"SB with LP\"\n    }),\n];\n\nlet lpSbSbPrunerConfigGen = (lp_front: boolean, max_depth: number) : PrunerConfig => {\n    const esize = Math.pow(24, 3)\n    const csize = Math.pow(24, 2)\n    const size = esize * csize\n    function encode(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 6: c1 = i * 3 + cube.co[i]; break;\n            case 7: c2 = i * 3 + cube.co[i]; break;\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0, e3 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 7 : e1 = i * 2 + cube.eo[i]; break;\n              case 10 : e2 = i * 2 + cube.eo[i]; break;\n              case 11 : e3 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24 * 24) + e2 * (24) + e3\n      return enc_e * (24 * 24) + enc_c\n    }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    const moveset = (lp_front ? rrwmu_f : rrwmu_b)\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"lpsb-sb\" + (lp_front ? \"+front-lp\" : \"+back-lp\")\n    }\n}\n\nlet lpSbDiagPrunerConfigGen = (lp_front: boolean, max_depth: number) : PrunerConfig => {\n    const esize = Math.pow(24, 3)\n    const csize = Math.pow(24, 2)\n    const size = esize * csize\n    function encode_f(cube:CubieCube) {\n      let c1 = 0, c2 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 4: c1 = i * 3 + cube.co[i]; break;\n            case 7: c2 = i * 3 + cube.co[i]; break;\n        }\n      }\n      const enc_c = c1 * 24 + c2\n      let e1 = 0, e2 = 0, e3 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 7 : e1 = i * 2 + cube.eo[i]; break;\n              case 8 : e2 = i * 2 + cube.eo[i]; break;\n              case 11 : e3 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24 * 24) + e2 * (24) + e3\n      return enc_e * (24 * 24) + enc_c\n    }\n    function encode_b(cube:CubieCube) {\n        let c1 = 0, c2 = 0\n        for (let i = 0; i < 8; i++) {\n          switch (cube.cp[i]) {\n              case 5: c1 = i * 3 + cube.co[i]; break;\n              case 6: c2 = i * 3 + cube.co[i]; break;\n          }\n        }\n        const enc_c = c1 * 24 + c2\n        let e1 = 0, e2 = 0, e3 = 0\n        for (let i = 0; i < 12; i++) {\n            switch (cube.ep[i]) {\n                case 7 : e1 = i * 2 + cube.eo[i]; break;\n                case 9 : e2 = i * 2 + cube.eo[i]; break;\n                case 10 : e3 = i * 2 + cube.eo[i]; break;\n            }\n        }\n        const enc_e = e1 * (24 * 24) + e2 * (24) + e3\n        return enc_e * (24 * 24) + enc_c\n      }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    const moveset = (lp_front ? rrwmu_f : rrwmu_b)\n\n    return {\n        size,\n        encode: lp_front ? encode_f : encode_b,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"lpsb-2sq\" + (lp_front ? \"+front-lp\" : \"+back-lp\")\n    }\n}\n\nlet lpSbPrunerConfigs = (lp_front: boolean) => [\n    lpSbSbPrunerConfigGen(lp_front, 5),\n    lpSbDiagPrunerConfigGen(lp_front, 5)\n];\n\nlet fsPrunerConfig = (is_front: boolean) => {\n    const size = Math.pow(24, 3)\n    const c1 = is_front ? 4 : 5;\n    const e1 = is_front ? 8 : 9;\n    const e2 = 5\n    function encode(cube:CubieCube) {\n      let v0 = 0, v1 = 0, v2 = 0\n      for (let i = 0; i < 8; i++) {\n        if ( cube.cp[i] === c1) v0 = i * 3 + cube.co[i]\n      }\n      for (let i = 0; i < 12; i++) {\n          if (cube.ep[i] === e1) v1 = i * 2 + cube.eo[i];\n          else if (cube.ep[i] === e2) v2 = i * 2 + cube.eo[i]\n      }\n      return v0 + v1 * 24 + v2 * 24 * 24\n    }\n\n    const moves = [[]]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move))\n\n    const max_depth = 5\n    const moveset = htm_rwm\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"fs\" + (is_front ? \"-front\" : \"-back\")\n    }\n}\n\nlet fsPseudoPrunerConfig = (is_front: boolean) => {\n    const size = Math.pow(24, 3)\n    const c1 = is_front ? 5 : 4; // pseudo FS: front solved == FL solved and DL+DBL paired up D* away from solved\n    const e1 = is_front ? 8 : 9;\n    const e2 = 5\n    function encode(cube:CubieCube) {\n        let v0 = 0, v1 = 0, v2 = 0\n        for (let i = 0; i < 8; i++) {\n          if ( cube.cp[i] === c1) v0 = i * 3 + cube.co[i]\n        }\n        for (let i = 0; i < 12; i++) {\n            if (cube.ep[i] === e1) v1 = i * 2 + cube.eo[i];\n            else if (cube.ep[i] === e2) v2 = i * 2 + cube.eo[i]\n        }\n        return v0 + v1 * 24 + v2 * 24 * 24\n    }\n    const pre_moves = is_front ? [\"D\"] : [\"D'\"]\n    const solved_states = pre_moves.map( (move : string) => new CubieCube().apply(move))\n\n    const max_depth = 5\n    const moveset = htm_rwm\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"fs-pseudo\" + (is_front ? \"-front\" : \"-back\")\n    }\n}\n\nlet fELineP1PrunerConfig = (is_front: boolean) => {\n    const size = Math.pow(24, 3)\n    const c1 = is_front ? 5 : 4; // FS Eline: front solved == FL + BL solved and DBL staged in DFL, D* away from solved\n    const e1 = 8;\n    const e2 = 9;\n    function encode(cube:CubieCube) {\n        let v0 = 0, v1 = 0, v2 = 0\n        for (let i = 0; i < 8; i++) {\n          if ( cube.cp[i] === c1) v0 = i * 3 + cube.co[i]\n        }\n        for (let i = 0; i < 12; i++) {\n            if (cube.ep[i] === e1) v1 = i * 2 + cube.eo[i];\n            else if (cube.ep[i] === e2) v2 = i * 2 + cube.eo[i]\n        }\n        return v0 + v1 * 24 + v2 * 24 * 24\n    }\n    const pre_moves = is_front ? [\"D\"] : [\"D'\"]\n    const solved_states = pre_moves.map( (move : string) => new CubieCube().apply(move))\n\n    const max_depth = 5\n    const moveset = htm_rwm\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"feline\" + (is_front ? \"-front\" : \"-back\")\n    }\n}\n\nlet fsDrPrunerConfig = (is_front: boolean) => {\n    const size = Math.pow(24, 4)\n    const c1 = is_front ? 4 : 5;\n    const e1 = is_front ? 8 : 9;\n    const e2 = 5\n    const e3 = 7\n    function encode(cube:CubieCube) {\n      let v0 = 0, v1 = 0, v2 = 0, v3 = 0\n      for (let i = 0; i < 8; i++) {\n        if ( cube.cp[i] === c1) v0 = i * 3 + cube.co[i]\n      }\n      for (let i = 0; i < 12; i++) {\n        const ep = cube.ep[i]\n        const eo = cube.eo[i]\n        if (ep === e1) v1 = i * 2 + eo;\n        else if (ep === e2) v2 = i * 2 + eo;\n        else if (ep === e3) v3 = i * 2 + eo;\n      }\n      return v0 + v1 * 24 + v2 * (24 * 24) + v3 * (24 * 24 * 24)\n    }\n\n    const moves = [[]]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move))\n\n    const max_depth = 5\n    const moveset = htm_rwm\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"fs\" + (is_front ? \"-front\" : \"-back\")\n    }\n}\n\n// let fsPrunerConfigAuto = (is_front: boolean) => prunerFactory({\n//         corner: is_front ? [I,I,I,I,S,I,I,I] : [I,I,I,I,I,S,I,I] ,\n//         edge:   is_front ? [I,I,I,I,I,S,I,I,S,I,I,I] : [I,I,I,I,I,S,I,I,I,S,I,I] ,\n//         center: [I,I,I,I,S,I],\n//         solved_states: [\"id\"],\n//         moveset: htm_rwm,\n//         max_depth: 4\n// });\n\nlet fbssPrunerConfigsManual = (is_front: boolean, max_depth?: number) : PrunerConfig[] => {\n    // make a line+ss solver\n    max_depth = max_depth || 5\n    const esize = Math.pow(24, 3) // 3 edges\n    const csize = Math.pow(24, 3) // 3 corners\n    const size = esize * csize\n\n    function encode_front(cube:CubieCube) {\n      let c1 = 0, c2 = 0, c3 = 0\n      for (let i = 0; i < 8; i++) {\n        switch (cube.cp[i]) {\n            case 4 : c1 = i * 3 + cube.co[i]; break\n            case 5 : c2 = i * 3 + cube.co[i]; break\n            case 7 : c3 = i * 3 + cube.co[i]; break\n        }\n      }\n      const enc_c = c1 * (24 * 24) + c2 * 24 + c3\n      let e1 = 0, e2 = 0, e3 = 0\n      for (let i = 0; i < 12; i++) {\n          switch (cube.ep[i]) {\n              case 5 : e1 = i * 2 + cube.eo[i]; break;\n              case 7 : e2 = i * 2 + cube.eo[i]; break;\n              case 11 : e3 = i * 2 + cube.eo[i]; break;\n          }\n      }\n      const enc_e = e1 * (24 * 24) + e2 * 24 + e3\n      return enc_c + csize * enc_e\n    }\n\n    function encode_back(cube:CubieCube) {\n        let c1 = 0, c2 = 0, c3 = 0\n        for (let i = 0; i < 8; i++) {\n          switch (cube.cp[i]) {\n              case 4 : c1 = i * 3 + cube.co[i]; break\n              case 5 : c2 = i * 3 + cube.co[i]; break\n              case 6 : c3 = i * 3 + cube.co[i]; break\n          }\n        }\n        const enc_c = c1 * (24 * 24) + c2 * 24 + c3\n        let e1 = 0, e2 = 0, e3 = 0\n        for (let i = 0; i < 12; i++) {\n            switch (cube.ep[i]) {\n                case 5 : e1 = i * 2 + cube.eo[i]; break;\n                case 7 : e2 = i * 2 + cube.eo[i]; break;\n                case 10 : e3 = i * 2 + cube.eo[i]; break;\n            }\n        }\n        const enc_e = e1 * (24 * 24) + e2 * 24 + e3\n        return enc_c + csize * enc_e\n    }\n\n    const moves = [[]]//, Move.parse(\"L R'\"), Move.parse(\"L' R\"), Move.parse(\"L2 R2\")]\n    const solved_states = moves.map( (move : Move[]) => new CubieCube().apply(move) )\n\n    //const moveset : Move[] = [\"U\", \"U2\", \"U'\", \"F\", \"F2\", \"F'\", \"R\", \"R2\", \"R'\",\n    //\"r\", \"r2\", \"r'\", \"D\", \"D2\", \"D'\", \"M\", \"M'\", \"M2\", \"B\", \"B'\", \"B2\"].map(s => Move.all[s])\n\n    const moveset = htm_rwm\n\n    return [\n        fbdrPrunerConfigGen(max_depth),\n        {\n            size,\n            encode: (is_front ? encode_front : encode_back),\n            solved_states,\n            max_depth,\n            moveset,\n            name: \"liness-\" + (is_front ? \"front\" : \"back\")\n        },\n    ]\n}\n\n// let fbssPrunerConfigsAuto = (is_front: boolean) => [\n//     prunerFactory({\n//         corner: is_front ? [I,I,I,I,S,S,I,S]: [I,I,I,I,S,S,S,I],\n//         edge:   [I,I,I,I,I,I,I,I,I,I,I,I],\n//         center: [I,I,I,I,I,I],\n//         solved_states: [\"id\"],\n//         moveset: htm_rwm,\n//         max_depth: 5,\n//         name: \"fbss-corner\"\n//     }),\n//     prunerFactory({\n//         corner: [I,I,I,I,I,I,I,I],\n//         edge:   [I,I,I,I,I,S,I,S,S,S,is_front ? I : S,is_front ? S : I],\n//         center: [I,I,I,I,I,I],\n//         solved_states: [\"id\"],\n//         moveset: htm_rwm,\n//         max_depth: 5,\n//         name: \"fbss-edge\"\n//     }),\n// ]\n\nlet fbssPrunerConfigs = fbssPrunerConfigsManual\n\nlet lsePrunerConfig : PrunerConfig = function() {\n    const size = Math.pow(12, 6) * 4 * 4 / 2 // TODO: optimize this plz\n    const edge_encode = [0, 1, 2, 3, 4, -1, 5, -1, -1, -1, -1, -1];\n    function encode(cube:CubieCube) {\n      let enc = [0, 0, 0, 0, 0, 0]\n      for (let i = 0; i < 12; i++) {\n        let idx = edge_encode[cube.ep[i]];\n        if (idx > 0) {\n            enc[idx] = edge_encode[i] * 2 + cube.eo[i];\n        }\n      }\n      let edge_enc = 0;\n      for (let i = 0; i < 6; i++) {\n        edge_enc = edge_enc * 12 + enc[i];\n      }\n      return edge_enc * 4 * 4 + cube.tp[0] * 4 + cube.cp[0]// center[0] and cp[0] must be (0-3)\n    }\n\n    const moves = [Move.all[\"id\"]]\n    const solved_states = moves.map( m => new CubieCube().apply(m))\n\n    const max_depth = 7\n    const moveset = [\"U\", \"U'\", \"U2\", \"M'\", \"M\", \"M2\"]\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"lse\"\n    }\n}()\n\nfunction eolrPrunerConfig(center_flag: number, barbie_mode?: string): PrunerConfig {\n    const size = 6 * 6 * Math.pow(2, 6) * 4 * 2 // TODO: optimize this plz\n\n    const edge_encode = [0, 1, 0, 2, 0, -1, 0, -1, -1, -1, -1, -1];\n    const edge_idx = [0, 1, 2, 3, 4, -1, 5, -1, -1, -1, -1, -1];\n    function encode(cube:CubieCube) {\n      let eo = 0, ep = 0\n      for (let i = 0; i < 12; i++) {\n        let idx = edge_encode[cube.ep[i]];\n        if (idx >= 0) {\n            eo = eo * 2 + cube.eo[i]\n        }\n        if (idx > 0) {\n            ep += Math.pow(6, idx - 1) * edge_idx[i]\n        }\n      }\n      // make no distinction between centers M2 apart\n      return (eo * 36 + ep) * 4 * 2 + ~~(cube.tp[0] / 2) * 4 + cube.cp[0]// center[0] and cp[0] must be (0-3)\n    }\n\n    const moves_ac = cartesianProduct( [\"U'\", \"U\"], [\"M2\"], [\"\", \"U\", \"U'\", \"U2\"] ).map(x => x.join(\" \"))\n    const moves_mc = cartesianProduct( [\"M'\"], [\"U\", \"U'\"], [\"M2\"], [\"\", \"U\", \"U'\", \"U2\"]).map(x => x.join(\" \"))\n    let moves: string[] = []\n    if (center_flag & 0x01) moves = moves.concat(moves_ac)\n    if (center_flag & 0x10) moves = moves.concat(moves_mc)\n\n    const barb_moves_ac = [\"U\", \"U'\"]\n    const barb_moves_mc = [\"M U\", \"M U'\"]\n    let barb_moves: string[] = []\n    if (center_flag & 0x01) barb_moves = barb_moves.concat(barb_moves_ac)\n    if (center_flag & 0x10) barb_moves = barb_moves.concat(barb_moves_mc)\n\n    const pre_moves = barbie_mode === \"barbie\" ? barb_moves :\n        (barbie_mode === \"ab4c\" ? [\"id\"] : moves)\n\n    const solved_states = pre_moves.map( m => new CubieCube().apply(m))\n\n    const max_depth = 20\n    const moveset = [\"U\", \"U'\", \"U2\", \"M'\", \"M\", \"M2\"]\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"eolr-\" + center_flag + \"-\" + barbie_mode\n    }\n}\n\nlet eodmPrunerConfig : PrunerConfig = (function(){\n    const size = 6 * 6 * Math.pow(2, 6) * 4\n\n    const edge_encode = [0, 0, 0, 0, 1, -1, 2, -1, -1, -1, -1, -1];\n    const edge_idx = [0, 1, 2, 3, 4, -1, 5, -1, -1, -1, -1, -1];\n    function encode(cube:CubieCube) {\n      let eo = 0, ep = 0\n      for (let i = 0; i < 12; i++) {\n        let idx = edge_encode[cube.ep[i]];\n        if (idx >= 0) {\n            eo = eo * 2 + cube.eo[i]\n        }\n        if (idx > 0) {\n            ep += Math.pow(6, idx - 1) * edge_idx[i]\n        }\n      }\n      // make no distinction between centers M2 apart\n      return (eo * 36 + ep) * 4 + cube.tp[0]\n    }\n\n    const solved_states = [new CubieCube()]\n    const max_depth = 20\n    const moveset = [\"U\", \"U'\", \"U2\", \"M'\", \"M\", \"M2\"]\n\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"eodm\"\n    }\n})()\n\nlet centerPrunerConfig : PrunerConfig = (function(){\n    const size = 6 * 6\n    const solved_states = [new CubieCube()]\n    const max_depth = 3\n    const moveset = xyz\n    function encode(cube:CubieCube) {\n        return cube.tp[0] * 6 + cube.tp[2]; // UD FB LR\n    }\n    return {\n        size,\n        encode,\n        solved_states,\n        max_depth,\n        moveset,\n        name: \"center\"\n    }\n})()\n\nexport { fbdrPrunerConfig, fsPrunerConfig, fsDrPrunerConfig, fsPseudoPrunerConfig, fELineP1PrunerConfig, sbPrunerConfig, ssPrunerConfig, ssDpPrunerConfig,\n    fbPrunerConfig, fbAtDLPrunerConfig, fbAtBLPrunerConfig, lsePrunerConfig, eolrPrunerConfig,\n    prunerFactory, fbssPrunerConfigs, lpSbPrunerConfigs, eodmPrunerConfig, centerPrunerConfig }","import { CubieCube, Move, MoveSeq } from './CubeLib';\nimport { arrayEqual } from './Math';\n\nimport { PrunerT, fbdrPrunerConfig, fbssPrunerConfigs, fsPrunerConfig, fsDrPrunerConfig, fsPseudoPrunerConfig, fELineP1PrunerConfig, sbPrunerConfig, ssPrunerConfig, ssDpPrunerConfig, fbPrunerConfig, lsePrunerConfig, PrunerConfig, eolrPrunerConfig, lpSbPrunerConfigs, fbAtDLPrunerConfig, fbAtBLPrunerConfig, eodmPrunerConfig, centerPrunerConfig } from './Pruner';\n\nimport {initialize as min2phase_init, solve as min2phase_solve} from \"../lib/min2phase/min2phase-wrapper\"\nimport { __DEV__ } from '../settings';\n\nimport { CachedPruner } from './CachedSolver';\n\ntype SolverConfig = {\n    is_solved: (cube : CubieCube) => boolean,\n    moveset: Move[],\n    pruners: PrunerT[],\n    pruneSeenEncodings?: boolean\n}\n\ntype Accumulator = {\n    solutions: MoveSeq[],\n    capacity: number\n}\n\nexport type SolverT = {\n    solve: (cube : CubieCube, l : number, r : number, c : number) => MoveSeq[],\n    is_solved: (cube : CubieCube) => boolean,\n    getPruners: () => PrunerT[]\n}\n\n\nfunction Solver(config: SolverConfig) : SolverT{\n    const MAX_STATE_COUNT = 3000000\n    let { moveset, is_solved, pruners } = config\n    let state_count = 0, prune_count = 0;\n    let accum : Accumulator\n    let max_depth : number\n    let min_depth : number\n\n    enum SState {\n        CONTINUE,\n        STOP\n    };\n\n    function solve_depth(cube: CubieCube, min_depth_: number, max_depth_: number, accum_: Accumulator) {\n        accum = accum_\n        max_depth = max_depth_\n        min_depth = min_depth_\n        state_count = 0\n        prune_count = 0\n        search(cube, 0, [])\n        return accum\n    }\n\n    let nextMoves : {[move: string] : Move[] }= Object.create({})\n    function generateNextMoveTable() {\n        function getAvailableMove(name : string) {\n            switch (name[0]) {\n                case \"U\": return moveset.filter(k => k.name[0] !== \"U\" && k.name[0] !== \"u\");\n                case \"u\": return moveset.filter(k => k.name[0] !== \"u\");\n                case \"D\": return moveset.filter(k => k.name[0] !== \"U\" && k.name[0] !== \"D\");\n                case \"R\": {\n                    let base = moveset.filter(k => k.name[0] !== \"R\" && k.name[0] !== \"r\");\n                    // we want to represent all Rr's as RM's. This demands M&r to always be enabled together.\n                    if (name === \"R\") return base.filter(k => k.name !== \"M'\")\n                    if (name === \"R'\") return base.filter(k => k.name !== \"M\")\n                    if (name === \"R2\") return base.filter(k => k.name !== \"M2\")\n                    return base\n                }\n                case \"L\": return moveset.filter(k => k.name[0] !== \"R\" && k.name[0] !== \"M\" && k.name[0] !== \"L\" && k.name[0] !== \"r\");\n                case \"r\": return moveset.filter(k => k.name[0] !== \"R\" && k.name[0] !== \"M\" && k.name[0] !== \"L\" && k.name[0] !== \"r\");\n                case \"M\": return moveset.filter(k => k.name[0] !== \"R\" && k.name[0] !== \"M\" && k.name[0] !== \"L\" && k.name[0] !== \"r\");\n                // f precede F. f'F represented as S'. S' must be standalone (no F/f/S allowed in its neighbor)\n                case \"F\": return moveset.filter(k => k.name[0] !== \"F\" && k.name[0] !== \"f\" && k.name[0] !== \"S\");\n                case \"f\": {\n                    const base = moveset.filter(k => k.name[0] !== \"S\" && k.name[0] !== \"f\")\n                    if (name === \"f'\") return base.filter(k => k.name !== \"F\")\n                    else if (name === \"f\") return base.filter(k => k.name !== \"F'\")\n                    else if (name === \"f2\") return base.filter(k => k.name !== \"F2\")\n                    else return base\n                }\n                case \"S\": return moveset.filter(k => k.name[0] !== \"F\" && k.name[0] !== \"B\" && k.name[0] !== \"S\" && k.name[0] !== \"f\");\n                case \"B\": return moveset.filter(k => k.name[0] !== \"F\" && k.name[0] !== \"B\");\n\n                case \"E\": return moveset.filter(k => k.name[0] !== \"U\" && k.name[0] !== \"D\" && k.name[0] !== \"E\");\n                default: return moveset\n            }\n        }\n        for (let move of moveset) {\n            nextMoves[move.name] = getAvailableMove(move.name)\n        }\n    }\n    generateNextMoveTable()\n\n    function expand(cube: CubieCube, depth: number, solution: Move[]) : SState{\n        const availableMoves : Move[] = solution.length > 0 ? nextMoves[solution[solution.length - 1].name] : moveset\n        let seen_encodings : Set<BigInt|number> | null = null\n        let prune = config.pruneSeenEncodings\n        if (prune) {\n            seen_encodings = new Set()\n            if (pruners.length === 1)\n                seen_encodings.add(pruners[0].encode(cube))\n            else  {\n                let n = BigInt(pruners[0].encode(cube)) * BigInt(pruners[1].size) + BigInt(pruners[1].encode(cube))\n                seen_encodings.add(n)\n            }\n        }\n        for (let move of availableMoves) {\n            let new_cube = cube.apply_one(move)\n            let enc = (pruners.length === 1) ? pruners[0].encode(new_cube) :\n                BigInt(pruners[0].encode(new_cube)) * BigInt(pruners[1].size) + BigInt(pruners[1].encode(new_cube))\n\n            if (seen_encodings == null || !seen_encodings.has(enc)) {\n                seen_encodings?.add(enc)\n                solution.push(move)\n                let st : SState = search(new_cube, depth + 1, solution)\n                solution.pop()\n                if (st === SState.STOP) {\n                    return SState.STOP\n                }\n            }\n        }\n        return SState.CONTINUE\n    }\n\n    function try_push(solution: Move[], depth: number) {\n        if (depth < min_depth) return SState.CONTINUE\n        if (accum.solutions.length < accum.capacity) {\n            let flag = true\n            for (let sol of accum.solutions) {\n                if (arrayEqual(sol.moves, solution)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                accum.solutions.push(new MoveSeq([...solution]))\n            }\n        }\n\n        if (accum.solutions.length === accum.capacity) {\n            return SState.STOP\n        } else {\n            return SState.CONTINUE\n        }\n    }\n\n    function search(cube: CubieCube, depth: number, solution: Move[]) : SState {\n        state_count++;\n        if (state_count > MAX_STATE_COUNT) {\n            return SState.STOP\n        }\n        if (is_solved(cube)) {\n            return try_push(solution, depth)\n        } else {\n            if (depth >= max_depth) return SState.CONTINUE;\n            let d = Math.max(...pruners.map(p => p.query(cube)))\n            if (d + depth > max_depth) {\n                prune_count++;\n                return SState.CONTINUE\n            } else {\n                return expand(cube, depth, solution)\n            }\n        }\n    }\n\n    function solve(cube: CubieCube, depth_l: number, depth_r: number, capacity: number) {\n        let accum : Accumulator = {\n            solutions: [],\n            capacity\n        }\n        for (let i = depth_l; i <= depth_r; i++) {\n            accum = solve_depth(cube, depth_l, i, accum)\n            if (accum.solutions.length === accum.capacity || state_count >= MAX_STATE_COUNT) {\n                break;\n            }\n        }\n        if (__DEV__) console.log(`Number of states = ${state_count}, pruned = ${prune_count}`);\n        return accum.solutions\n    }\n\n    function getPruners() {\n        return pruners\n    }\n    return { solve, is_solved, getPruners }\n};\n\nfunction solverFactory(prunerConfig: PrunerConfig) {\n    let pruner = CachedPruner.get(prunerConfig) //Pruner(prunerConfig)\n    pruner.init()\n\n    let is_solved = (cube: CubieCube) => pruner.query(cube) === 0;\n\n    let config = {\n        is_solved,\n        moveset: prunerConfig.moveset.map(s => Move.all[s]),\n        pruners: [pruner],\n        pruneSeenEncodings: true\n    }\n\n    let solver = Solver(config)\n    return solver\n}\n\nexport function solverFactory2(prunerConfigs: PrunerConfig[]) {\n    let pruners = prunerConfigs.map(pc => {\n        return CachedPruner.get(pc)\n    })\n    pruners.forEach(p => p.init())\n    //let solvedEncodings = prunerConfig.solved_states.map(s => prunerConfig.encode(s))\n    let is_solved = (cube: CubieCube) => pruners.every(p => p.query(cube) === 0)\n\n    let config : SolverConfig = {\n        is_solved,\n        moveset: prunerConfigs[0].moveset.map(s => Move.all[s]),\n        pruners,\n        pruneSeenEncodings: true\n    }\n    let solver = Solver(config)\n    return solver\n}\n\n\nlet FbSolver = () => solverFactory(fbPrunerConfig)\n\nlet FbSolverAtDL = () => solverFactory(fbAtDLPrunerConfig)\n\nlet FbSolverAtBL = () => solverFactory(fbAtBLPrunerConfig)\n\nlet FbdrSolver = () => solverFactory(fbdrPrunerConfig)\n\nlet SsSolver = (is_front: boolean) => solverFactory(ssPrunerConfig(is_front))\n\nlet SsDpSolver = (is_front: boolean) => solverFactory(ssDpPrunerConfig(is_front))\n\n// hand-crafted encoders are much faster though...\nlet FbssSolver =  (is_front: boolean) => solverFactory2(fbssPrunerConfigs(is_front))\n\nlet LpsbSolver = (is_front: boolean) => solverFactory2(lpSbPrunerConfigs(is_front))\nlet SbSolver = () => solverFactory(sbPrunerConfig)\n\nlet FsSolver = (is_front: boolean) => solverFactory(fsPrunerConfig(is_front))\nlet FsPseudoSolver = (is_front: boolean) => solverFactory(fsPseudoPrunerConfig(is_front))\nlet FELineP1Solver = (is_front: boolean) => solverFactory(fELineP1PrunerConfig(is_front))\nlet FsDrSolver = (is_front: boolean) => solverFactory(fsDrPrunerConfig(is_front))\n\nlet LSESolver = () => solverFactory(lsePrunerConfig)\n\nlet EOLRSolver = (center_flag: number, barbie_mode?: string) =>\n    solverFactory(eolrPrunerConfig(center_flag, barbie_mode))\n\nlet EOdMSolver = () => solverFactory(eodmPrunerConfig)\n\nlet CenterSolver = () => solverFactory(centerPrunerConfig)\n\nlet Min2PhaseSolver : () => SolverT = function() {\n    // polyfill for min2phase\n\n    min2phase_init();\n    function solve(cube : CubieCube, l : number, r : number, c : number) {\n        console.assert(arrayEqual(cube.tp, new CubieCube().tp), \"Cube center is not solved: \" + cube.tp)\n        const transformed_cube = cube.to_cstimer_cube()\n        console.assert( transformed_cube.is_solveable(), \"Cube must be solveable\")\n        let solution = min2phase_solve(transformed_cube);\n        return [ new MoveSeq(solution).inv() ]\n    }\n    function is_solved(cube: CubieCube) {\n        return true\n    }\n    function getPruners() {\n        return []\n    }\n    return {\n        solve,\n        is_solved,\n        getPruners\n    }\n}\n\n\n\nexport { FbdrSolver, FbSolver, FbSolverAtDL, FbSolverAtBL, SbSolver, FbssSolver, FsSolver, FsDrSolver, FsPseudoSolver, FELineP1Solver, SsSolver, SsDpSolver, Min2PhaseSolver, LSESolver, EOLRSolver, LpsbSolver, EOdMSolver, CenterSolver }","import {initialize, solve as min2phaseSolve, Min2PhaseCube} from \"./min2phase.js\"\nimport { CubieCube } from \"../CubeLib\";\n\nexport {initialize}\n\nfunction toMin2Phase(state: CubieCube): Min2PhaseCube {\n  // Note: this is its own inverse.\n  // const conjugate = {\n  //   EDGE: { permutation: [ 1, 0, 3, 2, 5, 4, 7, 6, 8, 9, 11, 10 ],\n  //           orientation: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] },\n  //   CORNER: { permutation: [ 0, 3, 2, 1, 4, 5, 6, 7 ],\n  //             orientation: [ 0, 0, 0, 0, 0, 0, 0, 0 ] },\n  //   CENTER: { permutation: [ 0, 1, 2, 3, 4, 5 ],\n  //             orientation: [ 0, 0, 0, 0, 0, 0 ] }\n  // };\n  // const pseudo = Combine(def, Combine(def, conjugate, Invert(def, state)), conjugate);\n\n  return {\n    cp: state.cp,\n    co: state.co,\n    ep: state.ep,\n    eo: state.eo\n  }\n}\n\nexport function solve(state: CubieCube): string {\n  return min2phaseSolve(toMin2Phase(state));\n}\n","import { Pruner, PrunerConfig, PrunerT } from './Pruner';\nimport { FbdrSolver, SolverT, FsSolver, FsDrSolver, FsPseudoSolver, FELineP1Solver, SsSolver, SsDpSolver, SbSolver, FbSolver, FbSolverAtBL, FbSolverAtDL, FbssSolver, LpsbSolver, Min2PhaseSolver, LSESolver, EOLRSolver, EOdMSolver, CenterSolver} from './Solver';\n\nlet all_solvers = [\n\"fbdr\",\"fb\", \"fs-front\", \"fs-back\", \"ss-front\", \"ss-back\", \"min2phase\",\n\"fsdr-front\", \"fsdr-back\",\n\"lse\", \"eolrac\", \"eolrmc\", \"eolr\", \"eolrac-b\", \"eolrmc-b\", \"eolr-b\", \"sb\", \"eodm\" ]\n\nlet CachedPruner = function() {\n    let cache : Map<string, PrunerT> = new Map()\n    function get(pc: PrunerConfig) {\n        let pcs = JSON.stringify(pc)\n        if (!cache.has(pcs)) {\n            let pruner = Pruner(pc)\n            cache.set(pcs, pruner)\n            return pruner\n        } else {\n            return cache.get(pcs) as PrunerT\n        }\n    }\n    return { get }\n}()\n\nlet CachedSolver = function() {\n    let cache : Map<string, SolverT> = new Map()\n    function get(s: string) {\n        if (!cache.has(s)) {\n            switch (s) {\n                case \"fbdr\": cache.set(s, FbdrSolver()); break\n                case \"fb\": cache.set(s, FbSolver()); break\n                case \"fb@dl\": cache.set(s, FbSolverAtDL()); break\n                case \"fb@bl\": cache.set(s, FbSolverAtBL()); break\n                case \"fs-front\": cache.set(s, FsSolver(true)); break\n                case \"fs-back\": cache.set(s, FsSolver(false)); break\n                case \"fs-pseudo-front\": cache.set(s, FsPseudoSolver(true)); break\n                case \"fs-pseudo-back\": cache.set(s, FsPseudoSolver(false)); break\n                case \"felinep1-front\": cache.set(s, FELineP1Solver(true)); break\n                case \"felinep1-back\": cache.set(s, FELineP1Solver(false)); break\n                case \"fsdr-front\": cache.set(s, FsDrSolver(true)); break\n                case \"fsdr-back\": cache.set(s, FsDrSolver(false)); break\n                case \"ss-front\": cache.set(s, SsSolver(true)); break\n                case \"ss-back\": cache.set(s, SsSolver(false)); break\n                case \"ssdp-front\": cache.set(s, SsDpSolver(true)); break\n                case \"ssdp-back\": cache.set(s, SsDpSolver(false)); break\n                case \"fbss-front\": cache.set(s, FbssSolver(true)); break\n                case \"fbss-back\": cache.set(s,FbssSolver(false)); break\n                case \"lpsb-front\": cache.set(s,LpsbSolver(true)); break\n                case \"lpsb-back\": cache.set(s,LpsbSolver(false)); break\n                case \"sb\": cache.set(s, SbSolver()); break\n\n                case \"min2phase\": cache.set(s, Min2PhaseSolver()); break\n                case \"lse\": cache.set(s, LSESolver()); break\n                case \"lse-ab4c\": cache.set(s, EOLRSolver(0x01, \"ab4c\")); break\n                case \"eolrac\": cache.set(s, EOLRSolver(0x01)); break\n                case \"eolrmc\": cache.set(s, EOLRSolver(0x10)); break\n                case \"eolr\": cache.set(s, EOLRSolver(0x11)); break\n                case \"eolrac-b\": cache.set(s, EOLRSolver(0x01, \"barbie\")); break\n                case \"eolrmc-b\": cache.set(s, EOLRSolver(0x10, \"barbie\")); break\n                case \"eolr-b\": cache.set(s, EOLRSolver(0x11, \"barbie\")); break\n                case \"eodm\" : cache.set(s, EOdMSolver()); break\n\n                case \"center\": cache.set(s, CenterSolver()); break\n            }\n        }\n        return cache.get(s) as SolverT\n    }\n    return {get}\n}()\n\nexport {CachedSolver, CachedPruner, all_solvers}","import { CubieCube, MoveSeq } from \"./CubeLib\";\nimport two_gram_meter from './two_gram_v1.json'\nexport abstract class Evaluator {\n    abstract evaluate(moves: MoveSeq) : number;\n    abstract name : string;\n}\nexport class SeqEvaluator extends Evaluator {\n    name = \"sequential\";\n    static moveCost_gen() {\n        let pairs: [string, number][] = [\n            [\"U\", 0.8], [\"U'\", 0.8], [\"U2\", 1.0],\n            [\"R\", 0.8], [\"R'\", 0.8], [\"R2\", 1.2],\n            [\"r\", 1], [\"r'\", 1], [\"r2\", 1.3],\n            [\"L\", 1], [\"L'\", 1], [\"L2\", 1.4],\n            [\"F\", 1.4], [\"F'\", 1.4], [\"F2\", 1.8],\n            [\"f\", 1.4], [\"f'\", 1.4], [\"f2\", 1.8],\n            [\"B\", 1.6], [\"B'\", 1.6], [\"B2\", 2.0],\n            [\"D\", 1.3], [\"D'\", 1.3], [\"D2\", 1.6],\n            [\"M\", 1.5], [\"M'\", 1.2], [\"M2\", 1.6],\n            [\"S\", 3.0], [\"S'\", 1.3], [\"S2\", 2.0],\n            [\"E\", 1.5], [\"E'\", 1.5], [\"E2\", 2.4],\n        ];\n        let costMap = new Map(pairs);\n        return costMap;\n    }\n    static moveCost = SeqEvaluator.moveCost_gen();\n\n    evaluate(moves: MoveSeq) {\n        let sum = 0;\n        for (let m of moves.moves) {\n            const value = (SeqEvaluator.moveCost.get(m.name)) || 1.4;\n            sum += value;\n        }\n        // 090822: solutions should be primarily sorted by HTM to guarantee that an optimal solution can always be returned by the solver\n        return moves.moves.length * 100 + sum;\n    }\n\n}\n\nexport class QTMEvaluator extends Evaluator {\n    name = \"qtm\";\n    evaluate(moves: MoveSeq) {\n        let sum = 0;\n        for (let m of moves.moves) {\n            sum += m.name[1] === \"2\" ? 2 : 1;\n        }\n        return sum * 100 + moves.moves.length;\n    }\n}\n\nexport class RawEvaluator extends Evaluator {\n    name = \"raw\";\n    evaluate(moves: MoveSeq) {\n        return moves.moves.length;\n    }\n}\n\n\nexport class TwoGramEvaluator extends Evaluator {\n    name = \"two-gram\";\n    static meter = two_gram_meter as {[s: string]: string};\n    evaluate(moves_input: MoveSeq) {\n        let score = 0\n        let moves = [\"\", ...moves_input.moves.map(x => x.name), \"\"]\n        for (let i =0; i < moves.length - 1; i++) {\n            let two_gram = moves[i] + moves[i + 1]\n            let curr_score = Number.parseFloat(TwoGramEvaluator.meter[two_gram])\n            if (Number.isNaN(curr_score)) {\n                curr_score = 0.3;\n            }\n            score += curr_score;\n        }\n        return score\n    }\n}\n\n// support right-hand heavy for now only\nenum DPGrip {\n    HOME = 0,\n    R_AWAY,\n    Rp_AWAY,\n    R2_AWAY,\n    DEAD_END\n};\nexport class DPEvaluator extends Evaluator {\n    name = \"dp\";\n    \n    static moveCost_gen() {\n        const HI = 10\n        // TODO: Add combo move + regripk some might be fast\n        let pairs: {[move: string]: number[]} = {\n            // array representing cost of performing move at grip \n            // easiest quarter moves are evaluated at 1 (RUFBDrM'), harder at 1.5 (M), \n               // forced ones at 3\n            // easiest double moves as 1.5, harder ones at 2(M2), forced at 2.5\n            // RH quarter grip in the direction of R at 3\n            // RH quarter grip in the direction of R' at 3\n            // RH quarter grip in the direction of R2 at 4\n            // HI means cost is too high (i.e. regrip is needed)\n\n            // TODO: add \"end state\"\n            \"U\":  [1, 2, HI, HI],\n            \"U'\": [1, 1, 1, 1],\n            \"U2\": [1.5, 1.5, 1.5, 1.5],\n            \"R\":  [1, 1, 1, HI],\n            \"R'\": [1, 1, 1, HI],\n            \"R2\": [1.5, 1.5, 1.5, 1.5],\n            \"F\":  [2.5, HI, 1, HI],\n            \"F'\": [1, 1.5, 1, HI],\n            \"F2\": [HI, 2, 2, HI],\n            \"D\":  [1, 1, 1, HI],\n            \"D'\": [1, 2, 1, HI],\n            \"D2\": [1.5, 1.5, 1.5, HI],\n            \"B\":  [HI, 1, 3, HI],\n            \"B'\": [3, 1.5, 1, HI],\n            \"B2\": [4, 2, 2, HI],\n            \"r\":  [1, 1, 1, HI],\n            \"r'\": [1, 1, 1, HI],\n            \"r2\": [1.5, HI, 1.5, HI],\n            \"M\":  [1, 2, 2, HI],\n            \"M'\": [1, 1.5, 1.5, 2],\n            \"M2\": [1.5, 2, 2, 3],\n        };\n        return pairs\n    }\n    static moveCost = DPEvaluator.moveCost_gen();\n    static moveTransition_gen(): {[key: string]: number[]}{\n        let {R_AWAY, R2_AWAY, HOME, Rp_AWAY, DEAD_END} = DPGrip\n        return {\n            //     HOME  ,  R_AWAY , Rp_AWAY ,  R2_AWAY\n            \"R\":  [R_AWAY,  R2_AWAY, HOME    , DEAD_END],\n            \"R'\": [Rp_AWAY, HOME   , DEAD_END,  R_AWAY ],\n            \"R2\": [R2_AWAY, Rp_AWAY,R_AWAY,  HOME ],\n\n            \"r\":  [R_AWAY,  R2_AWAY, HOME    , DEAD_END],\n            \"r'\": [Rp_AWAY, HOME   , DEAD_END,  R_AWAY ],\n            \"r2\": [R2_AWAY, Rp_AWAY,R_AWAY,  HOME ],\n        }\n    }\n    static moveTransition = DPEvaluator.moveTransition_gen();\n\n    static regripCost_gen() {\n        const HI = 10\n        let pairs: number[][] = [\n            // HOME\n            [0, 2, 2, 3],\n            // R AWAY\n            [1.5, 0, 2, 2],\n            // R' AWAY\n            [1.5, 3, 0, HI],\n            // R2 AWAY\n            [3, 2, HI, 0]\n        ]\n        return pairs\n    }\n    static regripCost = DPEvaluator.regripCost_gen();\n\n    evaluate(moves_input: MoveSeq) {\n        return this.evaluate_with_plan(moves_input).cost\n    }\n    evaluate_with_plan(moves_input: MoveSeq) {\n        // allow \n        const HI = 1e5\n        const allow_any_start = true\n        const len = moves_input.moves.length\n        const DP = Array(len + 1).fill(null).map(() => [HI, HI, HI, HI])\n        const DP_path = Array(len + 1).fill(null).map(() => Array(4).fill(null).map(() => [-1, -1]))\n\n        const regripCost = DPEvaluator.regripCost\n        const moveCost = DPEvaluator.moveCost\n        const moveTransition = DPEvaluator.moveTransition\n        if (allow_any_start) {\n            DP[0] = [0, 0, 0, HI]\n        } else {\n            DP[0] = [0, HI, HI, HI] \n        }\n        for (let i = 0; i < len; i++) {\n            const move = moves_input.moves[i].name\n            for (let prev_grip = 0; prev_grip < 4; prev_grip++) {\n                for (let shifted_grip = 0; shifted_grip < 4; shifted_grip++) {\n                    const cur_scheme = DP[i][prev_grip] + regripCost[prev_grip][shifted_grip] + moveCost[move][shifted_grip]\n                    const cur_grip = moveTransition[move] ? moveTransition[move][shifted_grip] : shifted_grip\n                    if (cur_grip === DPGrip.DEAD_END) continue\n                    if (cur_scheme < DP[i+1][cur_grip]) {\n                        DP[i+1][cur_grip] = cur_scheme\n                        DP_path[i+1][cur_grip] = [prev_grip, shifted_grip]\n                    }\n                }\n            }\n        }\n        // assume not take account cost of readjuting to home grip at the end\n        // Now, find optimal plan\n        let optimal_cost = HI\n        let optimal_ending_grip = -1\n        for (let grip = 0; grip < 4; grip++) {\n            if (DP[len][grip] < optimal_cost) {\n                optimal_cost = DP[len][grip]\n                optimal_ending_grip = grip\n            }\n        }\n        let current_grip = optimal_ending_grip\n        let optimal_plan: [number, number][] = [[current_grip, current_grip]]\n        for (let i = len; i >= 1; i--) {\n            const [previous_grip, previous_shifted_grip] = DP_path[i][current_grip]\n            optimal_plan.push([previous_grip, previous_shifted_grip])\n            current_grip = previous_grip\n        }\n        optimal_plan.reverse()\n\n        let grip_str = [\n            \"HOME\", \"R GRIP\", \"R' GRIP\", \"R2 GRIP\"\n        ]\n        let desc = `start from ${grip_str[optimal_plan[0][0]]}` \n        let current_segment : string[] = []\n        for (let i = 0; i < len; i++) {\n            let [g1, g2] = optimal_plan[i]\n            let move = moves_input.moves[i].name\n            if (g1 === g2) current_segment.push(move)\n            else {\n                desc += `, do ${current_segment.join(\" \")}, regrip to ${grip_str[g2]}`\n                current_segment = [move]\n            }\n        }\n        if (current_segment.length) desc += `, do ${current_segment.join(\" \")}`\n        desc += `, end in ${grip_str[optimal_plan[len][0]]}`\n        return {\n            alg: moves_input.toString(),\n            cost: optimal_cost,\n            //plan: optimal_plan,\n            desc: desc\n        }\n    }\n}\n\n\n\nexport class MovementEvaluator extends Evaluator {\n    name = \"movement\";\n    evaluate(moves_input: MoveSeq) {\n        let cube = new CubieCube()\n        let moves = moves_input.inv().moves\n        //let fb_corners = [4, 5]\n        //let fb_edges = [5, 8, 9]\n        let movement = 0\n        for (let i = 0; i < moves.length - 1; i++) {\n            let cube1 = cube.apply_one(moves[i])\n            let stationary = 0\n            for (let j = 0; j < 8; j++) {\n                if ((cube.cp[j] === 4 || cube.cp[j] === 5) && (cube.cp[j] === cube1.cp[j])) {\n                    stationary++\n                }\n            }\n            for (let j = 0; j < 12; j++) {\n                if ((cube.ep[j] === 5 || cube.ep[j] === 8 || cube.ep[j] === 9) && (cube.ep[j] === cube1.ep[j])) {\n                    stationary++\n                }\n            }\n            if (moves[i].name[1] === \"2\") {\n                movement += 2 * (5 - stationary);\n            } else {\n                movement += 5 - stationary;\n            }\n            cube = cube1\n        }\n        return movement\n    }\n}\n//ames: [\"sequential\", \"two-gram\", \"QTM\", \"default\"],\nexport function getEvaluator(s: string) {\n    switch (s) {\n        case \"Default\": return new SeqEvaluator();\n        case \"two-gram\": return new TwoGramEvaluator();\n        case \"QTM\": return new QTMEvaluator();\n        case \"dp\": return new DPEvaluator();\n        case \"movement\": return new MovementEvaluator();\n        case \"raw\": return new RawEvaluator(); \n        default :\n            return new SeqEvaluator();\n    }\n} \n","import { CubeUtil, CubieCube, Mask, Move, MoveSeq } from './CubeLib';\nimport { CachedSolver } from '../lib/CachedSolver';\nimport { getEvaluator } from '../lib/Evaluator';\n\nexport type fbStageT = \"fb\" | \"fs\" | \"pseudo-fs\" | \"fs-combo\" | \"felinep1\"\n\nexport type AnalyzerState = {\n    scramble: string,\n    post_scramble: string, // the part of solution leading up to the stage under analysis\n    full_solution: SolutionDesc[],\n    stage: string,\n    orientation: string,\n    pre_orientation: string,\n    num_solution: number,\n    fb_stage: fbStageT\n    show_mode: string, //\"foreach\" | \"combined\"\n    hide_solutions: boolean\n}\nexport let initialState : AnalyzerState = {\n    scramble: \"\",\n    post_scramble: \"\",\n    full_solution: [],\n    stage: \"fb\",\n    orientation: \"x2y\",\n    pre_orientation: \"\",\n    num_solution: 1,\n    fb_stage: \"fb\",\n    show_mode: \"foreach\",\n    hide_solutions: true\n}\n\nexport type SolverConfig = {\n    premoves?: string[],\n    num_solution: number,\n    upper_limit: number,\n    lower_limit?: number,\n    evaluator?: string\n  }\n\nexport type SolutionDesc = {\n    solution: MoveSeq,\n    premove: string,\n    score: number,\n    orientation?: string,\n    stage: string,\n    fb_tag?: string\n}\n\nfunction is_fb_solved(cube: CubieCube, oris: MoveSeq[]) {\n    for (let ori of oris) {\n        let cube1 = cube.changeBasis(ori).apply(ori.inv())\n        if (CubeUtil.is_solved(cube1, Mask.fb_mask)) return ori\n    }\n    return null\n}\n\n\n\nexport function analyze_roux_solve(cube: CubieCube, solve: MoveSeq) {\n    //todo: break up half turns to detect cancellation in between stages\n    let oris = get_oris(\"cn\").map(m => new MoveSeq(m))\n    let pres = [\"\", \"x\", \"x'\", \"x2\"].map(m => new MoveSeq(m))\n    const defaultSolution = {\n        solution: [], premove: \"\", orientation: \"\", stage: \"\", score: 0\n    }\n    // figure out which fb gets solved first\n    let stages = [\"fb\", \"ss\", \"sp\", \"cmll\", \"lse\"]\n    let solution : SolutionDesc[] = [];\n    let current_moves : Move[] = []\n    let stage_idx = 0\n    let getMasksForStage = (s: string) => {\n        switch (s) {\n            case \"ss\": return [Mask.ss_front_mask, Mask.ss_back_mask]\n            case \"sp\": return [Mask.sb_mask]\n            case \"cmll\": return [Mask.cmll_mask]\n            case \"lse\": return [Mask.solved_mask]\n            default: return [Mask.solved_mask]\n        }\n    }\n\n    let moves = [ Move.all[\"id\"], ...solve.moves]\n    for (let move of moves) {\n        cube = cube.apply(move)\n        if (move.name !== \"id\") current_moves.push(move)\n\n        if (stage_idx === 0) {\n            let res = is_fb_solved(cube, oris)\n            if (res !== null) {\n                let orientation = res\n                solution.push({ ...defaultSolution,\n                    solution: new MoveSeq(current_moves),\n                    orientation: orientation.moves.join(\"\"),\n                    stage: \"fb\"\n                })\n                stage_idx++\n                current_moves = []\n                cube = cube.changeBasis(orientation).apply(orientation.inv())\n            }\n        }\n        else if (stage_idx !== 3) {\n            let stage = stages[stage_idx]\n            let masks = getMasksForStage(stage)\n            if (masks.some(mask => CubeUtil.is_solved(cube, mask))) {\n                solution.push({ ...defaultSolution,\n                    solution: new MoveSeq(current_moves),\n                    stage\n                })\n                stage_idx++\n                current_moves = []\n            }\n        } else {\n            if (CubeUtil.is_cmll_solved(cube)) {\n                solution.push({ ...defaultSolution,\n                    solution: new MoveSeq(current_moves),\n                    stage: \"cmll\"\n                })\n                stage_idx++\n                current_moves = []\n            }\n        }\n        if (stage_idx >= stages.length) break\n    }\n    if (current_moves.length > 0) {\n        solution.push({ ...defaultSolution,\n            solution: new MoveSeq(current_moves),\n            stage: \"unknown\"\n        })\n    }\n    return solution\n}\n\nfunction solve(solver_str: string, cube: CubieCube, config: SolverConfig) {\n    const solver = CachedSolver.get(solver_str)\n    let { premoves, num_solution, upper_limit } = config\n    let ev = getEvaluator(config.evaluator || \"sequential\")\n    let solver_num_solution = (num_solution < 10) ? 10 : num_solution\n    let solutions = (premoves || [\"\"]).map(pm =>\n        solver.solve(cube.apply(pm), 0, upper_limit, solver_num_solution)\n            .map(x => ({premove: pm, solution: x, score: ev.evaluate(x)}))\n    ).flat()\n    return solutions.sort( (x, y) => x.score - y.score).slice(0, num_solution)\n}\n\n\nconst get_oris = (ori: string, preori?: string) => {\n    let oris : string[] = []\n    if (ori === \"x2y\") {\n        oris = (preori === \"\") ? [\"\", \"y\", \"y'\", \"y2\", \"x2\", \"x2y\", \"x2y'\", \"x2y2\"] :\n        (preori === \"x\") ? [\"x\", \"xy\", \"xy'\", \"xy2\", \"x'\", \"x'y\", \"x'y'\", \"x'y2\"] :\n        [\"z\", \"zy\", \"zy'\", \"zy2\", \"z'\", \"z'y\", \"z'y'\", \"z'y2\"]\n\n    } else if (ori === \"cn\") {\n        oris = [\"\", \"y\", \"y'\", \"y2\", \"x2\", \"x2y\", \"x2y'\", \"x2y2\",\n                \"x\", \"xy\", \"xy'\", \"xy2\", \"x'\", \"x'y\", \"x'y'\", \"x'y2\",\n                \"z\", \"zy\", \"zy'\", \"zy2\", \"z'\", \"z'y\", \"z'y'\", \"z'y2\"]\n    }\n    return oris\n}\nfunction analyze_fb(state: AnalyzerState, cube: CubieCube): SolutionDesc[] {\n    let config : SolverConfig = {\n        premoves: [\"\", \"x\", \"x'\", \"x2\"],\n        num_solution: state.num_solution,\n        upper_limit: 9\n    }\n    let oris = get_oris(state.orientation, state.pre_orientation)\n\n    let solutions : SolutionDesc[] = []\n    if (state.fb_stage === \"fb\") {\n        solutions = oris.map(ori => solve(\"fb\", cube.changeBasis(new MoveSeq(ori)), config).map(sol => ({\n        ...sol, orientation: ori, stage: \"fb\"\n        })).sort( (x, y) => x.score - y.score)).flat()\n    } else {\n        const fb_stage_solvers : Record<fbStageT, string[]>= {\n            \"fb\": [\"fb\"],\n            \"fs\": [\"fs-front\", \"fs-back\"],\n            \"pseudo-fs\": [\"fs-pseudo-front\", \"fs-pseudo-back\"],\n            \"felinep1\": [\"felinep1-front\", \"felinep1-back\"],\n            \"fs-combo\": [\"fs-front\", \"fs-back\", \"fs-pseudo-front\", \"fs-pseudo-back\", \"felinep1-front\", \"felinep1-back\"],\n        }\n        const needs_fb_tag = state.fb_stage === \"fs-combo\"\n        // label the fb_tag if we are in fs-combo mode\n        const fb_tag : Record<string, string> = {\n            \"fs-pseudo-front\": \"Ps\",\n            \"fs-pseudo-back\": \"Ps\",\n            \"felinep1-front\": \"Line\",\n            \"felinep1-back\": \"Line\",\n            \"fs-front\": \"FS\",\n            \"fs-back\": \"FS\",\n            \"fb\": \"FB\"\n        }\n        const solvers = fb_stage_solvers[state.fb_stage]\n\n        solutions = oris\n            .map(ori =>\n                solvers\n                    .map(s => solve(s, cube.changeBasis(new MoveSeq(ori)), config)\n                        .map(sol => ({\n                            ...sol,\n                            orientation: ori,\n                            fb_tag: fb_tag[s],\n                            stage: \"fb\"\n                        })))\n                    .flat()\n                    .sort((x, y) => x.score - y.score)\n            )\n            .flat()\n    }\n\n    return solutions\n}\n\nfunction analyze_ss(state: AnalyzerState, cube: CubieCube): SolutionDesc[] {\n    let config : SolverConfig = {\n        num_solution: state.num_solution,\n        upper_limit: 15\n    }\n    let solutions = [\"ss-front\", \"ss-back\"].map(name => solve(name, cube, config).map(sol => ({\n        ...sol, stage: name\n    })).sort( (x, y) => x.score - y.score)).flat()\n    return solutions\n}\n\nfunction analyze_sp(state: AnalyzerState, cube: CubieCube): SolutionDesc[] {\n    let config : SolverConfig = {\n        num_solution: state.num_solution,\n        upper_limit: 10\n    }\n    let solutions = solve(\"sb\", cube, config).map(sol => ({\n        ...sol, stage: \"sp\"\n    })).sort( (x, y) => x.score - y.score)\n\n    return solutions\n}\n\nfunction analyze_lse(state: AnalyzerState, cube: CubieCube): SolutionDesc[] {\n    let config : SolverConfig = {\n        num_solution: state.num_solution,\n        upper_limit: 20\n    }\n    let solutions = solve(\"lse\", cube, config).map(sol => ({\n        ...sol, stage: \"lse\"\n    })).sort( (x, y) => x.score - y.score)\n\n    return solutions\n}\n\n\nexport function analyze(state: AnalyzerState) {\n    let cube = new CubieCube().apply(state.scramble).apply(state.post_scramble)\n    if (state.stage === \"fb\") return analyze_fb(state, cube)\n    else {\n        let ori = new MoveSeq((state.full_solution[0]?.orientation) || \"\")\n        cube = cube.changeBasis(ori).apply(ori.inv())\n        if (state.stage === \"ss\") return analyze_ss(state, cube)\n        else if (state.stage === \"sp\") return analyze_sp(state, cube)\n        else if (state.stage === \"lse\") return analyze_lse(state, cube)\n    }\n    return []\n}","/* eslint-disable no-restricted-globals */\nimport { expose } from 'comlink';\nimport { analyze, AnalyzerState } from '../lib/Analyzer';\n\nexport const obj = {\n    analyze: (state: AnalyzerState) => {\n       \n        console.log(\"received state \", state)\n        return analyze(state)\n    }\n}\n\nexport type AnalyzerWorker = typeof obj\nexpose(obj);"],"sourceRoot":""}